<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chain | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/chain/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-06-03T10:22:44-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Managing Your Backbone Views with the State Pattern]]></title>
    <link href="http://robdodson.me/blog/2012/06/02/managing-your-backbone-views-with-the-state-pattern/"/>
    <updated>2012-06-02T18:22:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/02/managing-your-backbone-views-with-the-state-pattern</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten/">Yesterday I wrote a post to illustrate the concepts behind the State pattern</a> (one of my all time favorite tools). If you're new to this pattern and haven't read my previous post I suggest you start there and read this one after you've had a chance to play around with the ideas.</p>

<p>I wanted to write about this pattern in the context of a Backbone app because I think there's a lot of value in exploring different ways to manage our Views and Models. Here's an example Video Player in which several State objects inherit from a common ancestor, <code>BaseState</code>. I chose to make <code>BaseState</code> extend <code>Backbone.Model</code> because it seemed like the best fit for this kind of thing, although typically when I implement this pattern in other languages I just use generic Objects. I would have done that here but Backbone's <code>extend</code> functionality makes the code so much cleaner.</p>

<p>``` js
var BaseState = Backbone.Model.extend({
  initialize: function(owner) {</p>

<pre><code>this.owner = owner;
</code></pre>

<p>  },
  enter: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  },
  execute: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>console.log('changing to the playing state...');
this.owner.changeState(this.owner.states.playing);
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>console.log('changing to the stopping state...')
this.owner.changeState(this.owner.states.stopping);
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>console.log('changing to the pausing state...')
this.owner.changeState(this.owner.states.pausing);
</code></pre>

<p>  },
  exit: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  }
});</p>

<p>var PlayingState = BaseState.extend({
  execute: function() {</p>

<pre><code>console.log('playing the video!');
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>console.log('already playing!');
</code></pre>

<p>  }
});</p>

<p>var StoppingState = BaseState.extend({
  enter: function() {</p>

<pre><code>console.log('we have entered the stopping state...');
</code></pre>

<p>  },
  execute: function() {</p>

<pre><code>console.log('stopping the video...');
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>console.log('already stopped!');
</code></pre>

<p>  }
});</p>

<p>var PausingState = BaseState.extend({
  execute: function() {</p>

<pre><code>console.log('pausing the video.');
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>console.log('already paused!');
</code></pre>

<p>  }
});
```</p>

<p>Every state inherits from <code>BaseState</code> which means they all create a reference to an <code>owner</code> object in their <code>initialize</code> methods. The <code>owner</code> is going to be our actual <code>VideoPlayer</code> object. Rather than having <code>videoPlayer.play</code> lead to some big weird conditional:</p>

<p>``` js
play: function() {
  if (this.status == 'playing') {</p>

<pre><code>  return;
</code></pre>

<p>  } else if (this.status == 'stopped') {</p>

<pre><code>  // play the video
</code></pre>

<p>  } else if (this.status == 'paused') {</p>

<pre><code>  // unpause and play
</code></pre>

<p>  }
  else if ...
}
```</p>

<p>we're instead going to delegate the work to our State objects. They'll handle switching from one State to the next and so long as we provide the exact same public API methods in each, they should be interchangeable. Inheriting from the same BaseState ensures that all of the States have the same public methods and each State can choose how or if it wants to override them. In our example the <code>StoppingState</code> overrides the <code>enter</code> method to display some text as we're transitioning into this state. Again, you can override some or all of the methods, <code>enter</code> and <code>exit</code> are great for building up/tearing down anything that our state might need and <code>execute</code> is where the main work of our state should happen.</p>

<p>Let's take a look at the <code>VideoPlayer</code> which is a <code>Backbone.View</code> that will leverage our State objects:</p>

<p>``` js
var VideoPlayer = Backbone.View.extend({
  initialize: function() {</p>

<pre><code>this.states = {};
this.states.playing = new PlayingState(this);
this.states.stopping = new StoppingState(this);
this.states.pausing = new PausingState(this);
this.changeState(this.states.pausing);
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>this.state.play();
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>this.state.stop();
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>this.state.pause();
</code></pre>

<p>  },
  changeState: function(state) {</p>

<pre><code>// Make sure the current state wasn't passed in
if (this.state !== state) {
  // Make sure the current state exists before
  // calling exit() on it
  if (this.state) {
    this.state.exit();
  }
  this.state = state;
  this.state.enter();
  this.state.execute();
}
</code></pre>

<p>  }
});
<code>``
You'll notice that</code>VideoPlayer<code>instantiates its own State objects when it is first created. Then whenever we call one of its public methods the call is delegated to whichever state object is currently residing in</code>this.state`.</p>

<p>Let's instantiate a new VideoPlayer to see it in action:</p>

<p>``` js
var videoPlayer = new VideoPlayer();</p>

<p>=> 'pausing the video.'</p>

<p>videoPlayer.play();</p>

<p>=> 'changing to the playing state...'
=> 'playing the video!'</p>

<p>videoPlayer.play();</p>

<p>=> 'already playing!'</p>

<p>videoPlayer.stop();</p>

<p>=> 'changing to the stopping state...'
=> 'we have entered the stopping state...'
=> 'stopping the video...'
```</p>

<p>Hopefully this gives you some food for thought the next time you're trying to wrangle some unwieldy component. I cannot count how many times I've used this pattern in other languages to tidy up and organize my code. I'm looking forward to working with it again in Backbone and I'd love to hear anyone's take on how this can be tweaked or improved. Till tomorrow! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 9:48 pm</li>
<li>Mood: Focused, Hurried</li>
<li>Sleep: 5</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Take Control of your App with the JavaScript State Pattern]]></title>
    <link href="http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten/"/>
    <updated>2012-06-02T00:09:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten</id>
    <content type="html"><![CDATA[<p>Last week I wrote a post about <a href="http://robdodson.me/blog/2012/05/25/backbone-events-framework-communication/">communicating between views in Backbone.js</a> and since then it has easily become my most popular article. The comments have forced me to think about the ways in which I typically manage state in very large Flash applications and how that might translate to JavaScript and Backbone. Today I want to present my all time favorite design pattern, the State pattern, and illustrate how it can help you maintain control of your application. I want to warn you that I'm going to show a rather large block of what looks like repetitive code because I want the pattern to be obvious. In tomorrow's post we'll clean it up and try it out with a Backbone Model and View.</p>

<h3>The State pattern?</h3>

<p>Ok let's get started. I want to write a video player so I'm going to need an object that can handle <code>play</code>, <code>stop</code> and <code>pause</code> states. I would say that there are probably a ton of video players out there that have <code>play</code>, <code>stop</code> and <code>pause</code> methods on them, and I bet many look kind of like this:</p>

<p>``` js
play: function() {</p>

<pre><code>if (this.status == 'playing') {
    return;
} else if (this.status == 'stopped') {
    // play the video
} else if (this.status == 'paused') {
    // unpause and play
}
else if ...
</code></pre>

<p>}
```</p>

<p>Or maybe instead of a long conditional there's a switch statement or something. But <em>essentially</em> you're querying some variable somewhere to check what state the object is in and you're branching your logic as a result. Now, I would argue that this is a really brittle process and probably error prone. You could imagine that in each of those conditional blocks there might be several lines of code: preparing to play, stopping the video, tearing down this or that... Or perhaps if you're moving from one state to another you want to animate something on screen, maybe do some ajax, who knows!? Really no matter what you're doing if you're tossing it into these big conditionals it's going to become a nightmare to manage.</p>

<p>Alternatives? Ok, let's think of our video player in terms of the actions that it performs. Our player can play, it can stop and it can pause. What if instead of play, pause and stop acting as methods on our object, we make each of those states into its <em>own</em> object? So when the play state object is told to play it says 'Hey! I'm already playing. No need to change' and when it's told to stop it says 'Ah stopping, eh? Let me defer to my friend the Stop state object'.</p>

<p>To illustrate this I've written a very simple player which just logs what it's doing as you ask it to change state. I want to point out that this code is neither DRY nor very useful in a real world situation but it's intended to illustrate a point. Hopefully when you see the repetition you'll quickly say to yourself 'Hey! Those state objects could be made into a more general/abstract parent object.' That would be the correct mindset but I thought that if I skipped this part the pattern might not be obvious for those new to it.</p>

<p>``` js
var player = {</p>

<pre><code>state: undefined,
states: {
    playing: {
        initialize: function(target) {
            this.target = target;
        },
        enter: function() {
            console.log('setting up the playing state');
        },
        execute: function() {
            console.log('playing!');
        },
        play: function() {
            console.log('already playing!');
        },
        stop: function() {
            this.target.changeState(this.target.states.stopping);
        },
        pause: function() {
            this.target.changeState(this.target.states.pausing);
        },
        exit: function() {
            console.log('tearing down the playing state');
        }
    },
    stopping: {
        initialize: function(target) {
            this.target = target;
        },
        enter: function() {
            console.log('setting up the stopping state');
        },
        execute: function() {
            console.log('stopping!');
        },
        play: function() {
            this.target.changeState(this.target.states.playing);
        },
        stop: function() {
            console.log('already stopped!');
        },
        pause: function() {
            this.target.changeState(this.target.states.pausing);
        },
        exit: function() {
            console.log('tearing down the stopping state');                
        }
    },
    pausing: {
        initialize: function(target) {
            this.target = target;
        },            
        enter: function() {
            console.log('setting up the pausing state');
        },
        execute: function() {
            console.log('pausing!');
        },
        play: function() {
            this.target.changeState(this.target.states.playing);
        },
        stop: function() {
            this.target.changeState(this.target.states.stopping);
        },
        pause: function() {
            console.log('already paused!');
        },
        exit: function() {
            console.log('tearing down the pausing state!');                
        }
    }
},
initialize: function() {
    this.states.playing.initialize(this);
    this.states.stopping.initialize(this);
    this.states.pausing.initialize(this);
    this.state = this.states.stopping;
},
play: function() {
    this.state.play();
},
stop: function() {
    this.state.stop();
},
pause: function() {
    this.state.pause();
},
changeState: function(state) {
    if (this.state !== state) {
        this.state.exit();
        this.state = state;
        this.state.enter();
        this.state.execute();
    }
}
</code></pre>

<p>};
```</p>

<p>Lots of code, I know. But there is serious value in digesting this pattern so stick with me here and I'll go through it bit by bit. Let's start at the top where we define our object:</p>

<p>``` js
var player = {</p>

<pre><code>state: undefined,
states: {
    playing: {
        initialize: function(target) {
            this.target = target;
        },
        enter: function() {
            console.log('setting up the playing state');
        },
        execute: function() {
            console.log('playing!');
        },
        play: function() {
            console.log('already playing!');
        },
        stop: function() {
            this.target.changeState(this.target.states.stopping);
        },
        pause: function() {
            this.target.changeState(this.target.states.pausing);
        },
        exit: function() {
            console.log('tearing down the playing state');
        }
    },
</code></pre>

<p>... .
<code>``
First we declare our object and give it a property of</code>state<code>which we set to</code>undefined` for now. We're going to be creating state object to delegate all of our method calls to so once we're ready to use our player we'll set its initial state.</p>

<p>The <code>states</code> object (note the plurality) holds all of the different state objects that our player can use. In this version we've defined <code>playing</code>, <code>stopping</code> and <code>pausing</code> but you could also add states like <code>buffering</code> or <code>initializing</code>. Keep in mind that this pattern can be applied to just about anything. For instance, if you were making a game with an old prospector his state objects could be <code>mining</code>, <code>drinking</code> and <code>sleeping</code>. The main thing to remember is that <strong>your state objects should all define the exact same public methods</strong>.</p>

<p>We can skip the <code>stopping</code> and <code>pausing</code> states since they're nearly identical to the <code>playing</code> state. Instead let's jump down to the bottom and look at the last bit.</p>

<p>``` js
initialize: function() {</p>

<pre><code>this.states.playing.initialize(this);
this.states.stopping.initialize(this);
this.states.pausing.initialize(this);
this.state = this.states.stopping;
</code></pre>

<p>},
play: function() {</p>

<pre><code>this.state.play();
</code></pre>

<p>},
stop: function() {</p>

<pre><code>this.state.stop();
</code></pre>

<p>},
pause: function() {</p>

<pre><code>this.state.pause();
</code></pre>

<p>},
changeState: function(state) {</p>

<pre><code>if (this.state !== state) {
    this.state.exit();
    this.state = state;
    this.state.enter();
    this.state.execute();
}
</code></pre>

<p>}
```</p>

<p>In our player's initialize function we give each state a reference to the player object so we can tell it to <code>changeState</code>. We also set our initial state to be the stopping state.</p>

<p>Now let's look at the <code>play</code> method. Do you see how it defers the call to whatever object is currently set as the player's <code>state</code>? Since <code>this.state</code> refers to <code>this.states.stopping</code> we're effectively calling the <code>play</code> method of the <code>stopping</code> state object. Go look at the other state objects to see how they respond to having their <code>play</code> methods called. In the case of <code>states.stopping</code>, calling <code>play</code> is going to tell its <code>target</code> (which is just a reference to the player) to <code>changeState</code>, passing in the <code>states.playing</code> state.</p>

<p><code>changeState</code> is kind of an awesome method because it does a ton of work but it does it very elegantly and efficiently. For starters it makes sure that the state we've asked to change to is actually different than our current state. Then it tells our current state to <code>exit()</code>. A state's <code>exit()</code> method is a great place to tear down any constructs that we may have built to support that action. Next it sets our current state to the new state. Lastly, it calls <code>enter()</code> (a good place to build up supporting constructs) and <code>execute()</code>, which is where we do the main work of our state. That's pretty straightforward right?</p>

<p>Since <code>play</code>, <code>pause</code> and <code>stop</code> are members of our player's public API, <strong>all of our states must also implement those methods.</strong> Otherwise you would get an error if you called <code>play()</code> on the object and its state did not support that method. Keep this in mind when you're designing your state objects.</p>

<h3>Aaaaand we're off!</h3>

<p>Let's look at our player in action:</p>

<p>```
// We start off in the stopping state
// So when we call stop...
player.initialize();
player.stop();</p>

<p>=> 'already stopped!'</p>

<p>// Let's move to the playing state
player.play();</p>

<p>=> 'tearing down the stopping state'
=> 'setting up the playing state'
=> 'playing!'</p>

<p>// Quick call pause!
player.pause();</p>

<p>=> 'tearing down the playing state'
=> 'setting up the pausing state'
=> 'pausing!'</p>

<p>// Um... call pause like 3 times cuz
// I'm a button masher!!!
player.pause();
player.pause();
player.pause();</p>

<p>=> 'already paused!'
=> 'already paused!'
=> 'already paused!'</p>

<p>// OK call play again!
player.play();</p>

<p>=> 'tearing down the pausing state!'
=> 'setting up the playing state'
=> 'playing!'
```</p>

<h3>I like it, but...</h3>

<p>Before you run for the hills due to the sheer volume of boilerplate code I want to remind you that almost all of this repetition can easily be cleaned up. If we defined a base state that all of our other states extended then they would only need to override the methods that they cared about. For instance, the <code>stopping</code> state and <code>pausing</code> state both tell their target to <code>changeState</code> when someone calls <code>play</code>. This kind of functionality is easily moved into a base state. Also if you have no need for <code>enter</code> and <code>exit</code> methods those can be removed or also thrown into the base state. I'll dig into this more tomorrow but for now play around with the example and leave some feedback if you have comments or suggestions. Thanks!</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 12:10 am</li>
<li>Mood: Tired, Drunk</li>
<li>Sleep: 7</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to use EJS in Express]]></title>
    <link href="http://robdodson.me/blog/2012/05/31/how-to-use-ejs-in-express/"/>
    <updated>2012-05-31T11:34:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/31/how-to-use-ejs-in-express</id>
    <content type="html"><![CDATA[<p>Here's a quick explanation of how to use EJS instead of Jade in your Express projects. This is super easy and covered well in the documentation but I wanted to put it here since that's what I worked on today :)</p>

<p>To start I'll create a new project from the command line:</p>

<p><code>
express foobar
cd foobar
npm install
</code></p>

<p>Now that I have my foobar project created I need to install <code>ejs</code>.</p>

<p><code>
npm install ejs
</code></p>

<p>If you're within your project directory this will place ejs in the <code>node_modules</code> dir. Let's also add it to our package.json.</p>

<p>```
{
  "name": "foobar",
  "version": "0.0.1",
  "private": true,
  "dependencies": {</p>

<pre><code>"express": "~2.5.8",
"ejs": "~0.7.1"
</code></pre>

<p>  }
}
<code>``
The tilde operator means that we require ejs verion 0.7.1 or greater but only up to the next major release. So the following are equivalent:</code>"~1.2" = ">=1.2.0 &lt;2.0.0"`. For a deeper explanation of package.json and NPM in general <a href="http://howtonode.org/introduction-to-npm">checkout this great post</a>.</p>

<h3>Leaving Jade for EJS</h3>

<p>If you're using the boilerplate that Express generates then it should be setup to use Jade as the rendering engine for its views. I think that Jade is cool but I need to baby step into Node/Express and make sure I understand everything that's going on instead of trying to consume so many different tools at once. With this in mind I decided to switch from Jade to EJS at least in the beginning because the syntax has no learning curve. To change your rendering engine you'll need to either add or edit the following call:</p>

<p><code>js
app.set('view engine', 'ejs');
</code></p>

<p>The boilerplate should have this set to <code>jade</code> inside of a configuration block. Once we've changed that line to read <code>ejs</code> we're ready to start writing some views.</p>

<h3>Setting up your layout</h3>

<p>By default Express' boilerplate will look for a file named layout in our views directory. Let's write one called <code>layout.ejs</code>:</p>

<p>``` html views/layout.ejs
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Pivotal Search&lt;/title&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;

&lt;!-- HTML5 shim, for IE6-8 support of HTML elements --&gt;
&lt;!--[if lt IE 9]&gt;
  &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;

&lt;!-- styles --&gt;
&lt;link href="stylesheets/style.css" rel="stylesheet"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;%- body %&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>This is all really straightforward with the exception of the <code>&lt;%- body %&gt;</code> line which basically works like a <code>yield</code> in erb. Whatever template we pass to Express' <code>response.render()</code> function will fill this dependency, here's an example:</p>

<p><code>js app.js
app.get('/', function(req, res) {
  res.render('index', { title: 'The index page!' })
});
</code></p>

<p>``` html views/index.ejs</p>

<div class="title">
    <%= title %>
</div>


<p>```
<img class="center" src="https://s3.amazonaws.com/robdodson/images/rendering_the_index_template.png" title="'Rendering the index template'" ></p>

<p>Furthermore we can use partials with Express and EJS like so:</p>

<p>``` html views/layout.ejs
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Pivotal Search&lt;/title&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;

&lt;!-- HTML5 shim, for IE6-8 support of HTML elements --&gt;
&lt;!--[if lt IE 9]&gt;
  &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;

&lt;!-- styles --&gt;
&lt;link href="stylesheets/style.css" rel="stylesheet"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;%- partial('header.ejs') %&gt;
&lt;%- body %&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` html views/header.ejs
<header></p>

<pre><code>My awesome header!
</code></pre>

<p></header></p>

<hr>


<p>```</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/rendering_the_header_partial.png" title="'Rendering the header partial'" ></p>

<p>And there ya go! Simple but hopefully useful if you're just getting started like I am :) - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 11:36 am</li>
<li>Mood: Eager, Alert</li>
<li>Sleep: 7</li>
<li>Hunger: 7</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using jQuery Deferred to Load an Underscore Template]]></title>
    <link href="http://robdodson.me/blog/2012/05/30/using-jquery-deferred-to-load-an-underscore-template/"/>
    <updated>2012-05-30T08:53:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/30/using-jquery-deferred-to-load-an-underscore-template</id>
    <content type="html"><![CDATA[<p>Today's post is meant to scratch an itch I had the other day regarding templates. My friend wanted to load an underscore template along with some JSON data but wasn't sure what the best approach would be. Since I'm using Backbone Boilerplate I've gotten used to having my template loading method already stubbed out for me. Here's the one they use:</p>

<p>``` js
fetchTemplate: function(path, done) {
  var JST = window.JST = window.JST || {};
  var def = new $.Deferred();</p>

<p>  // Should be an instant synchronous way of getting the template, if it
  // exists in the JST object.
  if (JST[path]) {</p>

<pre><code>if (_.isFunction(done)) {
  done(JST[path]);
}

return def.resolve(JST[path]);
</code></pre>

<p>  }</p>

<p>  // Fetch it asynchronously if not available from JST, ensure that
  // template requests are never cached and prevent global ajax event
  // handlers from firing.
  $.ajax({</p>

<pre><code>url: path,
type: "get",
dataType: "text",
cache: false,
global: false,

success: function(contents) {
  JST[path] = _.template(contents);

  // Set the global JST cache and return the template
  if (_.isFunction(done)) {
    done(JST[path]);
  }

  // Resolve the template deferred
  def.resolve(JST[path]);
}
</code></pre>

<p>  });</p>

<p>  // Ensure a normalized return value (Promise)
  return def.promise();
}
```</p>

<p>Not having previous experience working with <a href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a> I was initially put-off by the idea of just copy/pasting this function over to him, especially since I couldn't explain what was going on. I knew that I probably wanted to use Deferreds and Promises but I wasn't sure how best to explain the concepts nor did this method seem to do much in the way of loading JSON, it was just for loading templates. Since my friend only wanted to load 1 template and 1 JSON file I thought it best for us to start small, and to write something that we could easily debug. Knowing I wanted to use Deferreds I found <a href="http://msdn.microsoft.com/en-us/magazine/gg723713.aspx">this wonderful article by Addy Osmani and Julian Aubourg</a> detailing how Deferreds work. It is VERY comprehensive and for our purposes I only needed to read the first few paragraphs before I had enough to start.</p>

<p>In a nutshell deferreds are objects which contain promises (also objects). Promises can be in various states, <code>pending</code>, <code>resolved</code> or <code>rejected</code>. Once you have a deferred (or it's promise) you can hook functions on to it so when it changes from a <code>pending</code> to <code>resolved</code> state all those functions fire. It's actually the promise that changes state but you can use the deferred like a promise because in most cases it will just proxy the calls to its promise object. Using deferreds can be nice for several reasons. For starters, you can avoid the jQuery <em>pyramid of doom</em></p>

<p>``` js</p>

<p>// NOOOOOOoooooooooo</p>

<p>$.ajax({
  url: 'foo.php',
  success: function() {</p>

<pre><code>$.ajax({
  url: 'bar.php',
  success: function() {
    $.ajax({
      url: 'baz.php',
      success: function() {
        ...
      }
    })
  }
})
</code></pre>

<p>  }
})</p>

<p>```</p>

<p>Secondly your deferreds/promises are little tokens that you can hand out from your services so other actors don't have to get all up in your ajax guts. Someone makes an API request, you give em a token, when it resolves they play with the data.</p>

<p>``` js
function doSomethingWithHugeData(data) {
  console.log("man, look at all these 1's and 0's!");
}</p>

<p>var dfd = myService.getSomeHugeData();
dfd.done(doSomethingWithHugeData);
```</p>

<p>This is a much nicer approach than passing in a callback that your service will need to execute whenever it finishes getting its data. Your service shouldn't care about your callbacks. It should care about getting data and letting people know when that data's been got! :D</p>

<h3>But I digress...</h3>

<p>We were <em>trying</em> to load some JSON and a template, so let's get back to the task at hand. Since we know that we have two ajax calls, one for the JSON and one for the template, and we know that we don't really want to do anything till both of these calls have completed we've got a perfect use case for <a href="http://api.jquery.com/jQuery.when/">$.when</a>. <code>when</code> accepts a list of deferreds/promises and acts as one big deferred, waiting for all of its children to resolve before it resolves. This is a nice way to build a sequencer. In our case we're going to take  two ajax calls and toss them into <code>$.when</code>. When it resolves we'll use <code>$.then</code> to tell it what our success and failure callbacks should be.</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Deferred Sandbox&lt;/title&gt;
&lt;script src="jquery.js"&gt;&lt;/script&gt;
&lt;script src="underscore.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;div id="main"&gt;&lt;/div&gt;

&lt;script&gt;
  $(function() {

    function successFunc(jsonRes, templateRes) {
      var json = _.first(jsonRes);
      var template = _.first(templateRes);
      var compiled = _.template(template, json);
      $('#main').html(compiled);
    }

    function failureFunc() {
      console.log('fail whale!');
    }

    $.when(
      $.ajax("person.json"),
      $.ajax("person.template.html")
    ).then(successFunc, failureFunc);

  });
&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>In our case everything is in the same folder as index.html so there's no need for any paths. Keep in mind that in most (all?) browsers you'll need to be running a local server for the above code to actually work. In Chrome, at least, you can't run an html file from file:// and have it load external resources, it'll complain that the access-origin is not allowed.</p>

<p>Let me take a moment to explain <code>$.then</code> a little bit. We know that <code>$.ajax</code> returns a deferred, and that the deferred's promise can be in three states: <code>pending</code>, <code>resolved</code>, <code>rejected</code>. So if we did something like this:</p>

<p><code>js
var dfd = $.ajax('foobar.php');
</code></p>

<p><code>dfd</code> would be a deferred object with a <code>pending</code> promise. Deferred's let us link methods up to them for when their state changes. These methods are: <code>done()</code>, <code>fail()</code>, <code>always()</code>, <code>progress()</code>, and <code>then()</code>. There are more but <a href="http://api.jquery.com/category/deferred-object/">I'll let the documentation explain them.</a> <code>done()</code> and <code>fail()</code> each accept either a single callback or an array of callbacks to be fired when the deferred changes to either the <code>resolved</code> or <code>rejected</code> state.</p>

<p>``` js
function successFunc() {
  console.log('success! do stuff with data!');
}</p>

<p>function failureFunc() {
  console.log('failure! um...give up!');
}</p>

<p>var service = {
  getJSON: function() {</p>

<pre><code>return $.ajax('person.json');
</code></pre>

<p>  }
};</p>

<p>service.getJSON()
.done(successFunc)
.fail(failureFunc);</p>

<p>```</p>

<p><code>always()</code> fires its callbacks regardless of whether the deferred was <code>resolved</code> or <code>rejected</code>. This might be a good place to put any cleanup code. <code>progress()</code> is fired during any progress events that the process might emit. Finally there's <code>then()</code> which is what we're using in our template example. <code>then()</code> is essentially shorthand for <code>done()</code> and <code>fail()</code> so you can pass it two callbacks or two arrays of success/fail callbacks.</p>

<p>Hopefully that's helpful for you all and you can go back and clean up some of those pyramids that might be lingering in your code. Till tomorrow! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 8:00 am</li>
<li>Mood: Reserved, Sedate</li>
<li>Sleep: 7</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing AMD Backbone Modules]]></title>
    <link href="http://robdodson.me/blog/2012/05/29/testing-backbone-modules/"/>
    <updated>2012-05-29T08:03:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/29/testing-backbone-modules</id>
    <content type="html"><![CDATA[<p>Continuing from <a href="http://robdodson.me/blog/2012/05/28/mocking-requests-with-mocha-chai-and-sinon/">yesterday's post</a> I'm going to start to incorporate Backbone into my BDD setup. I'm going to use the <a href="https://github.com/tbranyen/backbone-boilerplate">Backbone Boilerplate</a> and <a href="https://github.com/backbone-boilerplate/grunt-bbb">grunt-bbb</a> to setup a new project. If you're new to the boilerplate or grunt-bbb <a href="http://robdodson.me/blog/2012/05/17/getting-familiar-with-backbone-boilerplate/">checkout my previous post on getting started.</a></p>

<h3>Shiny and new</h3>

<p>I've created a new directory called <code>amd-tests</code> and once I <code>cd</code> inside I run <code>bbb init</code> to template out a new project. By default the boilerplate uses Require.js and AMD modules and we have a little example one already created for us. It's called, well, Example :) We'll use this to create our model for testing since I know that everyone should be on the same page with this module.</p>

<p>I'm going to change our model's name from Example.Model to Example.Photo so our terminalogy won't get muddy. We'll give it some default properties for <code>src</code> and <code>caption</code>. Later on we'll test that a freshly created model has these same defaults. When we're done setting up our <code>/app/example.js</code> file should look like this. Keep in mind that the boilerplate adds a lot of stuff to get us started so you can ignore everything that isn't Example.Photo</p>

<p>``` js /app/example.js
define([
  "namespace",</p>

<p>  // Libs
  "use!backbone"</p>

<p>  // Modules</p>

<p>  // Plugins
],</p>

<p>function(namespace, Backbone) {</p>

<p>  // Create a new module
  var Example = namespace.module();</p>

<p>  // !!! Our awesome new model !!!
  Example.Photo = Backbone.Model.extend({</p>

<pre><code>defaults: {
  src: '/images/placeholder.jpg',
  caption: 'Waiting for content...'
}
</code></pre>

<p>  });</p>

<p>  Example.Collection = Backbone.Collection.extend({ /<em> ... </em>/ });
  Example.Router = Backbone.Router.extend({ /<em> ... </em>/ });</p>

<p>  // This will fetch the tutorial template and render it.
  Example.Views.Tutorial = Backbone.View.extend({</p>

<pre><code>template: "app/templates/example.html",

render: function(done) {
  var view = this;

  // Fetch the template, render it to the View element and call done.
  namespace.fetchTemplate(this.template, function(tmpl) {
    view.el.innerHTML = tmpl();

    // If a done function is passed, call it with the element
    if (_.isFunction(done)) {
      done(view.el);
    }
  });
}
</code></pre>

<p>  });</p>

<p>  // Required, return the module for AMD compliance
  return Example;</p>

<p>});
```
Now comes the rather tricky part. We need to create a test runner HTML file that can incorporate mocha, chai and sinon. It also has to load our Example module and maintain all of that module's dependencies. I spent a <em>ton</em> of time on IRC today sorting this out so here is my current best stab at things based on some <a href="https://gist.github.com/2655876">VERY generous gists</a> from <a href="https://github.com/kmiyashiro">Kelly Miyashiro.</a></p>

<p>Let's start with the index.html file that'll be our test runner:</p>

<p>``` html test/index.html
<html>
<head>
  <meta charset="utf-8">
  <title>Mocha Tests</title>
  <link rel="stylesheet" href="mocha/mocha.css" />
  <script src="../assets/js/libs/require.js"></script>
  <script src="mocha/mocha.js"></script>
  <script src="sinon/sinon.js"></script>
  <script src="config.js"></script>
</head>
<body>
  <script></p>

<pre><code>require([
  '../test/test.example'
], runMocha);
</code></pre>

<p>  </script>
  <div id="mocha"></div>
</body>
</html>
```</p>

<p>The first thing we do is add require.js, then mocha and sinon. Why no Chai? Good question. Kelly didn't do it so I didn't do it. If anyone wants to cite the pros and cons of this approach I'm all ears. Next we add our own config.js that is specific to our tests. We might have a config.js somewhere else that runs our main app but we'll also need this one to run our tests. Finally we have a script block sitting on top of our <code>#mocha</code> div. The script block loads in our specs (in this case I've only written one but you can do multiple specs here). A final argument to the require call is <code>runMocha</code>. Essentially this is the function that is executed <em>AFTER</em> the modules have finished loading. In our case runMocha is located inside the new config.js we've defined just for our tests. Let's take a look at it now.</p>

<p>``` js test/config.js
require.config({</p>

<pre><code>// Base URL relative to the test runner
// Paths are relative to this
baseUrl: '../app',
paths: {
    // Testing libs
    'chai'          : '../test/chai/chai',
    'common'        : '../test/common',
    'jquery'        : '../assets/js/libs/jquery',
    'underscore'    : '../assets/js/libs/underscore',
    'backbone'      : '../assets/js/libs/backbone',
    'use'           : '../assets/js/plugins/use'
},
use: {
    backbone: {
        deps: ['use!underscore', 'jquery'],
        attach: 'Backbone'
    },
    underscore: {
        attach: '_'
    },
    mocha: {
        attach: 'mocha'
    }
},
priority: [
    'jquery',
    'underscore',
    'common'
]
</code></pre>

<p>});</p>

<p>mocha.setup({</p>

<pre><code>ui: 'bdd',
ignoreLeaks: true
</code></pre>

<p>});</p>

<p>// Protect from barfs
console = window.console || function() {};</p>

<p>var runMocha = function() {</p>

<pre><code>mocha.run();
</code></pre>

<p>};
```</p>

<p>Lots of stuff here but nothing to get alarmed about. <a href="http://robdodson.me/blog/2012/05/17/getting-familiar-with-backbone-boilerplate/">If you've read my previous getting started post you'll know all about the config.js file.</a> Go back and read the previous post if none of this makes sense to you. The thing to take note of is the <code>priority</code> array and the <code>runMocha</code> function at the bottom of the page. I don't have much experience with the priority array and I didn't find much documentation on it but Kelly uses it <a href="https://gist.github.com/2655876">in the gists</a> to make sure that jQuery, chai and any chai plugins are properly setup on the page.</p>

<p>``` js test/common.js
// Include and setup all the stuff for testing
define(function(require) {</p>

<pre><code>window.$ = window.jQuery = require('jquery');
window.chai         = require('chai');
window.expect       = chai.expect;
</code></pre>

<p>});
```</p>

<p>Good practice? Bad practice? I'm not sure and I would love comments if anyone has a take on things. Underneath the priority array is a setup function which sends some configuration parameters to mocha. <code>ignoreLeaks</code> is useful because it's easy for mocha to see jQuery or any other global variable as a good reason to abort a test. IMO that's what JSLint/Hint is for, and bailing everytime you see a global is going to make testing 3rd party code especially difficult. My advice, leave it off. Finally we call <code>mocha.run()</code> via the <code>runMocha</code> function. Remember that this function is executed inside our test runner after all the specs are loaded, like so:</p>

<p>``` html test/index.html</p>

<script>
    require([
      '../test/test.example'
    ], runMocha);
  </script>


<p>```</p>

<p>Doing it this way guarantees that all the dependencies our module needs will be loaded before we start running our tests.</p>

<h3>Oh right, the tests!</h3>

<p>Wow! OK so hopefully you're still with me because after all of that we <em>still</em> need to generate some tests. Since it's getting late I'm just going to put together a really simple spec to make sure our default values are being set on the model.</p>

<p>I've created a file called <code>test.example.js</code> which will test our <code>Example</code> module.</p>

<p>``` js test/test.example.js
define(function(require) {
  var Example = require('modules/example');</p>

<p>  describe('Example', function() {</p>

<pre><code>describe('Photo', function() {
  var photo = new Example.Photo();
  it('should have proper defaults', function(done) {
      expect(photo.get('src')).to.equal('/images/placeholder.jpg');
      expect(photo.get('caption')).to.equal('Waiting for content...');
      done();
  });
});
</code></pre>

<p>  });
});
```</p>

<p>It isn't amazing but it gets us started testing our module. I'm explicitly calling <code>done()</code> at the end of our test because I saw mention on StackOverflow that you should do this when testing AMD modules in the browser with mocha otherwise you can get false passing tests. Not sure if it's absolutely necessary but I guess better safe than sorry!</p>

<p>At this point I'm exhausted and hopefully you have a decent head start on your tests. I know that this post jumps around a lot so please take a moment <a href="https://github.com/robdodson/backbone-boilerplate-mocha">to grab the repo I've posted which contains all the source code.</a> Again. Caveat. I'm learning along with you so there are lots of newbie mistakes being made, I'm sure. I really want to hear your feedback if you have any. Good luck!</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here</a></p>

<ul>
<li>Time: 8:04 am</li>
<li>Mood: Awake, Antsy</li>
<li>Sleep: 6</li>
<li>Hunger: 3</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
</feed>
