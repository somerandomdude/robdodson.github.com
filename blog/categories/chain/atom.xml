<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chain | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/chain/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-05-28T15:09:05-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mocking Requests with Mocha, Chai and Sinon]]></title>
    <link href="http://robdodson.me/blog/2012/05/28/mocking-requests-with-mocha-chai-and-sinon/"/>
    <updated>2012-05-28T11:20:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/28/mocking-requests-with-mocha-chai-and-sinon</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/05/27/testing-backbone-boilerplate-with-mocha-and-chai/">After a bit of a rocky start yesterday</a> I've finally got Mocha and Chai running in the browser which is great. Today I'd like to test out some of the async functionality of Mocha. This seems to be the big selling point for most people so we'll kick the tires a bit.</p>

<h3>Basic Async Tests with Mocha and Chai</h3>

<p>I wrote a little Node service that we'll consume for testing purposes. This is my first <a href="http://nodejs.org/">Node</a> and <a href="http://expressjs.com/">Express</a> app so apologies if it's lamesauce. I used the <code>express</code> command to boilerplate a project called <code>pickles</code> with some very basic routes:</p>

<p>``` js
// Routes</p>

<p>var count = 100;</p>

<p>app.get('/', function(req, res) {
  res.send('Welcome to the Pickle Store!');
});</p>

<p>app.get('/pickles', function(req, res) {
  res.json({</p>

<pre><code>count: count,
message: 'oh boy, ' + count + ' pickles!'
</code></pre>

<p>  });
});</p>

<p>app.get('/pickles/add/:num', function(req, res) {
  count += parseInt(req.params.num);
  res.json({</p>

<pre><code>add: req.params.num,
message: 'you added ' + req.params.num + ' pickles to the pickle barrel!'
</code></pre>

<p>  });
});</p>

<p>app.listen(3000, function(){
  console.log("Express server listening on port %d in %s mode", app.address().port, app.settings.env);
});
```
We'll need to make sure our node service is running for our tests to work and all of our URLs will point at localhost:3000. Obviously you wouldn't want this for a production setting but it'll be fine for demonstration purposes.</p>

<p>Here is our really simple Mocha spec. We're actually creating a <code>pickelStore</code> object in the spec file itself so we can test against it.</p>

<p>``` js test.pickles.js
var expect = chai.expect;</p>

<p>var pickleStore = {
  pickles: function() {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles',
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  },
  add: function(num) {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles/add/' + num,
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  }
};</p>

<p>describe('Pickle Store', function() {
  describe('#pickles', function() {</p>

<pre><code>pickleStore.pickles();
</code></pre>

<p>  });
});
```</p>

<p>I just want to see if the ajax methods will run and hit our Node service but I'm running into the following issue in Chrome:</p>

<p><code>
XMLHttpRequest cannot load http://localhost:3000/pickles. Origin null is not allowed by Access-Control-Allow-Origin.
</code>
Bummer... :(</p>

<p>OK, what's going on here... To StackOverflow! <a href="http://stackoverflow.com/questions/8456538/origin-null-is-not-allowed-by-access-control-allow-origin/8456586#8456586">Aaaand we have our response.</a> After a bit of googling I came across <a href="http://www.stoimen.com/blog/2010/11/19/diving-into-node-js-very-first-app/">this post</a> which mentions adding <code>res.header('Access-Control-Allow-Origin', '*');</code> to my Node responses. That does the trick. I also found <a href="http://www.stoimen.com/blog/2010/11/19/diving-into-node-js-very-first-app/">this post</a> which describes setting up <a href="https://developer.mozilla.org/en/http_access_control">CORS</a> with Express.</p>

<p>OK hopefully we're done with Node for now. I don't want this to turn into a node tutorial... Let's see if we can get the tests to perform using Mocha. We'll need some way to mock and spy on the ajax because I don't want to test the data coming from the actual service. I've realized I want to <em>simulate</em> the service for client-side Mocha tests. In a future tutorial I'll test the service itself using the Node aspect of Mocha. Kind of silly to lead off this way but whatever, moving on!</p>

<h3>Enter Sinon.js</h3>

<p>I'm going to use <a href="http://sinonjs.org/">Sinon.js</a> to help me mock, stub, fake, spy and do whatever the heck else I need to make sure my client code is solid. After downloading the js file for Sinon you can just add it to our test/index.html under the line where we added mocha.</p>

<p>``` html
<html>
<head>
  <meta charset="utf-8">
  <title>Mocha Tests</title>
  <link rel="stylesheet" href="mocha/mocha.css" />
  <script src="../assets/js/libs/jquery.js"></script>
  <script src="chai/chai.js"></script>
  <script src="mocha/mocha.js"></script>
  <script src="sinon/sinon.js"></script>
  <script>mocha.setup('bdd');</script>
  <script src="test.pickles.js"></script>
  <script></p>

<pre><code>$(function() {
  mocha.run();
})
</code></pre>

<p>  </script>
</head>
<body>
  <div id="mocha"></div>
</body>
</html>
```</p>

<p>Now we can use Sinon in our <code>test.pickles.js</code> file to get a handled on our ajax. Let's first test that an ajax call is made when we run the <code>pickles()</code> method of the <code>pickleStore</code> object. We'll make sure this first test fails, then we'll change the spec to make it pass.</p>

<p>``` js test.pickles.js
var expect = chai.expect;</p>

<p>var pickleStore = {
  pickles: function() {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles',
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  },
  add: function(num) {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles/add/' + num,
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  }
};</p>

<p>describe('Pickle Store', function() {
  describe('#pickles', function() {</p>

<pre><code>// Use Sinon to replace jQuery's ajax method
// with a spy.
beforeEach(function() {
  sinon.spy($, 'ajax');
});

// Restor jQuery's ajax method to its
// original state
afterEach(function() { 
  $.ajax.restore();
})

it('should make an ajax call', function(done) {
  pickleStore.pickles();
  expect($.ajax.calledOnce).to.be.false; // see if the spy WASN'T called
  done(); // let Mocha know we're done async testing
});
</code></pre>

<p>  });
});
```
<img class="center" src="https://s3.amazonaws.com/robdodson/images/first_failing_ajax_test.png" title="'Our first failing test with Mocha, Chai and Sinon. Yay!'" ></p>

<p>Changing this line <code>expect($.ajax.calledOnce).to.be.false;</code> from <code>false</code> to <code>true</code> should make our test pass. Yay, first async test in the bag! Next let's try to fake a response from the server. But I'm realizing that the succesful server response should <em>do</em> something to my pickleStore object, otherwise why do I care about the data? So I'm going to update pickelStore with the following success callback on its pickles method:</p>

<p>``` js test.pickles.js
var pickleStore = {
  count: 0,
  status: '',
  pickles: function() {</p>

<pre><code>var self = this;
$.ajax({
  url: 'http://localhost:3000/pickles',
  dataType: 'json',
  success: function(data) {
    self.count = parseInt(data.count);
    self.status = data.status;
  }
});
</code></pre>

<p>  },
  add: function(num) {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles/add/' + num,
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  }
};</p>

<p>... .
```</p>

<p>Now we can test what happens after the server sends a succesful response. But how do we get that response and how do we force the success callback? For that we'll need to use Sinon's <code>stub.yieldsTo</code> method. It's mentioned in <a href="http://sinonjs.org/docs/#stubs">the docs on this page</a> if you scroll down. <code>yieldsTo</code> lets us direct the path of our spy so it will not only pretend to be jQuery's <code>ajax</code> method, but it will also force itself into the <code>success</code> callback with an optional hash of parameters which simulate our service response. Sweet! We'll have to revise the <code>beforeEach</code> in our spec though otherwise Sinon will complain that we're wrapping <code>ajax</code> twice. The updated spec should look like this. Again, take note that we're going to make it fail first by expecting a count of 99 pickles instead of 100.</p>

<p>``` js test.pickles.js
... .</p>

<p>describe('Pickle Store', function() {
  describe('#pickles', function() {</p>

<pre><code>// Use Sinon to replace jQuery's ajax method
// with a spy. This spy will also come with
// some success data.
beforeEach(function() {
  sinon.stub($, 'ajax').yieldsTo('success', {
    count: '100',
    message: 'oh boy, 100 pickles!'
  });
});

// Restor jQuery's ajax method to its
// original state
afterEach(function() { 
  $.ajax.restore();
})

it('should make an ajax call', function(done) {
  pickleStore.pickles();
  expect($.ajax.calledOnce).to.be.true;
  done();
});

it('should update the count', function(done) {      
  pickleStore.pickles();
  expect(pickleStore.count).to.equal(99);
  done();
});
</code></pre>

<p>  });
});
```</p>

<p>Failing as expected. Aaaaand we change the expected count to 100, voila! Passing tests again!</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/passing_yield_test.png" title="'Passing test with Sinon's yieldTo'" ></p>

<p>I'm adding the test for the status update as well so our final <code>#pickles</code> spec should look like this:</p>

<p>``` js test.pickles.js
describe('Pickle Store', function() {
  describe('#pickles', function() {</p>

<pre><code>// Use Sinon to replace jQuery's ajax method
// with a spy. This spy will also come with
// some success data.
beforeEach(function() {
  sinon.stub($, 'ajax').yieldsTo('success', {
    count: '100',
    message: 'oh boy, 100 pickles!'
  });
});

// Restor jQuery's ajax method to its
// original state
afterEach(function() { 
  $.ajax.restore();
})

it('should make an ajax call', function(done) {
  pickleStore.pickles();
  expect($.ajax.calledOnce).to.be.true;
  done();
});

it('should update the count', function(done) {      
  pickleStore.pickles();
  expect(pickleStore.count).to.equal(100);
  done();
});

it('should update the status', function(done) {      
  pickleStore.pickles();
  expect(pickleStore.status).to.equal('oh boy, 100 pickles!');
  done();
});
</code></pre>

<p>  });
});
```</p>

<p>Now let's test the <code>#add</code> method before calling it a day. This method is interesting because all it can really do is update our status message. However, once it's called the value returned by <code>pickles()</code> should have incremented by whatever amount was passed to <code>add()</code>. Let's start by updating our <code>pickleStore</code> so it properly updates the status message after we've called add.</p>

<p>``` js test.pickles.js
var pickleStore = {
  count: 0,
  status: '',
  pickles: function() {</p>

<pre><code>var self = this;
$.ajax({
  url: 'http://localhost:3000/pickles',
  dataType: 'json',
  success: function(data) {
    self.count = parseInt(data.count);
    self.status = data.message;
  }
});
</code></pre>

<p>  },
  add: function(num) {</p>

<pre><code>var self = this;
$.ajax({
  url: 'http://localhost:3000/pickles/add/' + num,
  dataType: 'json',
  success: function(data) {
    self.status = data.message; // &lt;-- update the status message!
  }
});
</code></pre>

<p>  }
};
```</p>

<p>Now that that's in there we'll write a failing spec.</p>

<p>``` js test.pickles.js
describe('#add', function() {</p>

<p>  var amount = 11;</p>

<p>  beforeEach(function() {</p>

<pre><code>sinon.stub($, 'ajax').yieldsTo('success', {
  add: amount,
  message: 'you added ' + amount + ' pickles to the pickle barrel!'
});
</code></pre>

<p>  });</p>

<p>  afterEach(function() {</p>

<pre><code>$.ajax.restore();
</code></pre>

<p>  });</p>

<p>  it('should update the status with the correct amount', function(done) {</p>

<pre><code>pickleStore.add(amount);
expect(pickleStore.status).to.equal('you added ' + 99 + ' pickles to the pickle barrel!');
done();
</code></pre>

<p>  });
});
```</p>

<p>This is not unlike our previous spec, in fact it does even less since we're not checking count.</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/failing_add_test.png" title="'Another failing test.'" ></p>

<p>To make the test pass we change the 99 to <code>amount</code>. I originally wrote the add method thinking I would go back and check the total number of pickles but I've realized now that really that's more of a test for the service and not the front end. The front end shouldn't care if that arithmetic is happening properly, it should just consume data and update its UI. For tomorrow's post I'll try to get an AMD module in here so we can start playing with Backbone again. Thanks!</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 11:21 am</li>
<li>Mood: Irritated, Antsy</li>
<li>Sleep: 8</li>
<li>Hunger: 5</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting started with Mocha and Chai]]></title>
    <link href="http://robdodson.me/blog/2012/05/27/testing-backbone-boilerplate-with-mocha-and-chai/"/>
    <updated>2012-05-27T14:08:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/27/testing-backbone-boilerplate-with-mocha-and-chai</id>
    <content type="html"><![CDATA[<p>Since I was previously doing so much RSpec I want to try to bring some of that over to my JavaScript work. Lately I've been working with the Backbone Boilerplate which is a wonderful jump-start for folks who want to get up and running with AMD and Backbone. Today I'm going to see if I can get a working BDD setup going which will run some very basic tests. In a future post I'll use this new setup to do some BDD with Backbone Boilerplate.</p>

<h3>Setting up Mocha and Chai</h3>

<p>I chose Mocha over Jasmine because I've already worked with Jasmine so there wasn't much mystery there and also because I've heard really good things about Mocha. I think it's cool that if I choose to do a Node.js project Mocha will be able to test both my server and client code.</p>

<p>Unfortunately the documentation for both Mocha and Chai is rather terse when it comes to actually explaining how to get either library working for client side testing. I guess that's understandable since their primary focus is Node but after over an hour of poking around both sites I still don't have anything that functions...</p>

<p>Copying over both the mocha and chai directories into my project I've noticed that each one has a test/browser folder which is refered to in the documentation. Seems like this is how I run my specs. Mocha has a failing set of specs on its opts.html file but otherwise everything seems to pass. Chai has failures in its spec regarding its deep equals operations... Let's see if we can forge ahead and write a test in just mocha.</p>

<p>Here's my html runner setup:</p>

<p>``` html
<html>
<head>
  <meta charset="utf-8">
  <title>Mocha Tests</title>
  <link rel="stylesheet" href="mocha/mocha.css" />
  <script src="../assets/js/libs/jquery.js"></script>
  <script src="mocha/mocha.js"></script>
  <script>mocha.setup('bdd')</script>
  <script src="test.foobar.js"></script>
  <script></p>

<pre><code>$(function() {
  mocha.run();
})
</code></pre>

<p>  </script>
</head>
<body>
  <div id="mocha"></div>
</body>
</html>
```</p>

<p>And here's my first failing test:</p>

<p>``` js
describe('Foobar', function() {
  describe('#sayHello()', function() {</p>

<pre><code>it('should return some text', function() {
  var foobar = {
    sayHello: function() {
      return 'Hello World!';
    }
  };

  assert(foobar.sayHello() === 'funky chicken');
})
</code></pre>

<p>  })
})
```</p>

<p>Using just the above I see the mocha runner fire up but then it immediately breaks saying that <code>assert</code> is not defined. Well...great. <a href="http://visionmedia.github.com/mocha/#browser-support">I'm basing my work on this example</a> but I realize now that I removed the line which included <code>expect.js</code>. Without expect.js we don't have anything to do exceptions for us because Mocha doesn't include any by default.</p>

<p><img class="center" src="/images/no_assert.png" title="'Assert is not defined" ></p>

<p>Looking at some other Mocha examples in the github repo I noticed that they explicitly define the <code>assert</code> method inside the runner. We'll do the same to get things working. Here's my updated runner which now functions as expected. Note the addition of <code>assert</code> after we call <code>mocha.setup('bdd')</code>.</p>

<p>``` js
<html>
<head>
  <meta charset="utf-8">
  <title>Mocha Tests</title>
  <link rel="stylesheet" href="mocha/mocha.css" />
  <script src="../assets/js/libs/jquery.js"></script>
  <script src="mocha/mocha.js"></script>
  <script>mocha.setup('bdd')</script>
  <script></p>

<pre><code>function assert(expr, msg) {
  if (!expr) throw new Error(msg || 'failed');
}
</code></pre>

<p>  </script>
  <script src="test.foobar.js"></script>
  <script></p>

<pre><code>$(function() {
  mocha.run();
})
</code></pre>

<p>  </script>
</head>
<body>
  <div id="mocha"></div>
</body>
</html>
```</p>

<p>Since our <code>assert</code> method takes a <code>msg</code> param we can add that to our test so we get some useful feedback when it fails. Here's the updated spec.</p>

<p>``` js
describe('Foobar', function() {
  describe('#sayHello()', function() {</p>

<pre><code>it('should return some text', function() {
  var foobar = {
    sayHello: function() {
      return 'Hello World!';
    }
  };

  assert(foobar.sayHello() === 'funky chicken', 'Was expecting "Hello World!"');
})
</code></pre>

<p>  })
})
```</p>

<p>That should fail and give us the appropriate message. Changing 'funky chicken' to 'Hello World!' will make the test pass. Yay that only took a few hours...</p>

<p>OK, let's forge ahead and see if we can get chai working so we can use some nicer expectations than our weak <code>assert</code>. I'm including chai.js in place of our <code>assert</code> function.</p>

<p>```
<html>
<head>
  <meta charset="utf-8">
  <title>Mocha Tests</title>
  <link rel="stylesheet" href="mocha/mocha.css" />
  <script src="../assets/js/libs/jquery.js"></script>
  <script src="chai/chai.js"></script> <!-- added chai.js instead of assert -->
  <script src="mocha/mocha.js"></script>
  <script>mocha.setup('bdd')</script>
  <script src="test.foobar.js"></script>
  <script></p>

<pre><code>$(function() {
  mocha.run();
})
</code></pre>

<p>  </script>
</head>
<body>
  <div id="mocha"></div>
</body>
</html>
```</p>

<p>Next we need to update our spec. Chai has 3 different styles of assertions: <code>assert</code>, <code>expect</code> and <code>should</code>. I'll show you how to use each in our foobar spec:</p>

<p>``` js
var assert = chai.assert,</p>

<pre><code>expect = chai.expect,
should = chai.should(); // Note that should has to be executed
</code></pre>

<p>var foobar = {
  sayHello: function() {</p>

<pre><code>return 'Hello World!';
</code></pre>

<p>  }
};</p>

<p>describe('Foobar', function() {
  describe('#sayHello()', function() {</p>

<pre><code>it('should work with assert', function() {
  assert.equal(foobar.sayHello(), 'funky chicken!');
})

it('should work with expect', function() {
  expect(foobar.sayHello()).to.equal('funky chicken!');
})

it('should work with should', function() {
  foobar.sayHello().should.equal('funky chicken!');
})
</code></pre>

<p>  })
})
```</p>

<p><img class="center" src="/images/failing_chai_tests.png" title="'Our failing Chai tests'" ></p>

<p>Changing all those funky chickens to 'Hello World!' should get the tests passing again and now we can use any syntax we like.</p>

<p><img class="center" src="/images/passing_chai_tests.png" title="'Finally some passing Chai tests!'" ></p>

<p>Now all is well and good except the tests that come with Chai are failing in a few places. It looks like some of Chai's methods are borked on my system.</p>

<p><img class="center" src="/images/broken_chai_tests.png" title="'Chai failing its own tests'" ></p>

<p>That does <em>not</em> fill me with confidence. I think there's a very high probability that being a newbie I'm doing something wrong so <a href="https://twitter.com/rob_dodson/status/206893206435151872/photo/1">I've tweeted to Jake Luer, the author of Chai, to figure out if perhaps I'm missing something or if the tools are actually broken.</a> In the meantime I'm not comfortable using a testing framework that's broken.</p>

<p>Sigh... well tomorrow I'll try to import some modules and if Jake hasn't gotten back to me by then I'll use Jasmine to do those tests. Till then!</p>

<ul>
<li>Update: Looks like I managed to clone Chai right as they were updating the repo. Pulling the latest fixed everything. See the comment thread below*</li>
</ul>


<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 2:09 pm</li>
<li>Mood: Awake, Caffeinated, Curious</li>
<li>Sleep: 7</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Penner easing equations with GFX and CSS3]]></title>
    <link href="http://robdodson.me/blog/2012/05/27/penner-easing-equations-with-gfx-and-css3/"/>
    <updated>2012-05-27T00:07:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/27/penner-easing-equations-with-gfx-and-css3</id>
    <content type="html"><![CDATA[<p>This is going to be a bit of lightening post because it's rather late and I need to get to bed. I spent most of the day either eating dim sum or hanging out at the <a href="http://www.meetup.com/San-Francisco-Creative-Coders/">SF Creative Coders BBQ</a> so I've neglected my blogging duties a bit.</p>

<p>I have something which will hopefully be useful for some folks who are getting into CSS3 animations with the Gfx plugin for jQuery. <a href="http://robdodson.me/blog/2012/05/22/css3-transitions-with-gfx/">I've blogged a bit about Gfx before</a> and one of the first things I noticed was the lack of a built in easing library. Coming from the Flash world where <a href="http://www.greensock.com/tweenlite/">TweenLite is king</a> I've grown very accustomed to using Robert Penner's easing equations for great effect. The same equations are used by the jQuery framework to do its animations. Thankfully <a href="http://matthewlein.com/ceaser/">Matthew Lein was kind enough to convert those over to cubic-beziers</a> for those of us doing CSS3 animations. Since Gfx accepts cubic-beziers I moved the equations from Matthew's tool into an AMD compliant module and <a href="https://github.com/robdodson/amd-css3-ease">put it up on Github.</a> It's very simple so if AMD isn't your thing you can just rip those parts out :D</p>

<p>Example usage looks something like this:</p>

<p>``` js
// After requiring the ease module and
// passing it into your View with the
// name 'Ease'</p>

<p>this.$el.gfx({</p>

<pre><code>translateY: '300px'
</code></pre>

<p>}, {</p>

<pre><code>duration: 500,
easing: Ease.easeInExpo 
</code></pre>

<p>});
```</p>

<p>Give it a shot and consider donating to Matthew's project or buying Robert Penner like a million beers!</p>

<ul>
<li>Time: 12:09 am</li>
<li>Mood: Tired, Tipsy</li>
<li>Sleep: 7</li>
<li>Hunger: 0</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone Events: Framework Communication]]></title>
    <link href="http://robdodson.me/blog/2012/05/25/backbone-events-framework-communication/"/>
    <updated>2012-05-25T08:01:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/25/backbone-events-framework-communication</id>
    <content type="html"><![CDATA[<p>I want to figure out how to communicate on a framework level within Backbone. Coming from Flash and <a href="http://www.robotlegs.org/">RobotLegs</a> I'm used to a few MVC conventions that work very well as far as event dispatching goes. In RobotLegs you typically have a framework wide eventDispatcher that anyone can tune into. In a nutshell your View will trigger an event, for instance a user clicking a button, and that will get dispatched to interested framework actors. These can be other Views or, more likely, they can be Commands. The Commands are like single use actions tied directly to events. Think of it like binding every public method of your controller to an event. The Commands will typically effect models, changing them in some way, and the Models will dispatch an event that the Views listen for to update themselves.</p>

<p>Backbone works differently in that Views are often tied directly to their models like so:</p>

<p>``` js
var doc = Documents.first(); // &lt;-- Model object</p>

<p>new DocumentRow({ // &lt;-- View object with model reference
  model: doc,
  id: "document-row-" + doc.id
});
```</p>

<p>When you use this approach it's trivial to tell the view to listen to the model's change event and then call <code>view.render()</code>. Essentially you are munging some of a Controller's responsibilities into the View. That's all well and good but let's say we want to dispatch an event from one view which will affect other views and actors. This event has nothing to do with a model, maybe it's just an animation of some kind that others need to know about. So how do we go about this?</p>

<h3>Communicating between Views in Backbone</h3>

<p>To facilitate this communication we're going to use the <code>app</code> object that Backbone Boilerplate creates for us. If you look in the <code>namespace.js</code> file that comes with the boilerplate you should see a line like this way down at the bottom:</p>

<p><code>js namespace.js
app: _.extend({}, Backbone.Events)
</code>
If you're not familiar with <a href="http://underscorejs.org/#extend">Underscore.js's extend method</a> it basically takes all of the properties and functions of one object and copies them onto another. If you're coming from a language that supports classical inheritence this should feel familiar. In the above example it's creating a new empty object (app), and extending/inheriting from the Backbone.Events object. This means that the <code>app</code> property of the <code>namespace</code> module is basically one big event dispatcher.</p>

<p>So let's create two very simple views in a module called <code>Chatty</code>. One will be <code>Subject</code> and the other <code>Observer</code>. When we click the Subject we want it to dispatch an event that any framework actor can tune into. We'll call this event <code>clicked:subject</code>. When the Observer hears the <code>clicked:subject</code> event we want it to replace its html content with whatever message is sent along.</p>

<p>``` js chatty.js
define([
  "namespace", // &lt;-- see I'm bringing in the namespace module</p>

<p>  // Libs
  "use!backbone"</p>

<p>  // Modules</p>

<p>  // Plugins</p>

<p>],</p>

<p>function(namespace, Backbone) { // &lt;-- make sure to pass namespace as an argument</p>

<p>  // Create a new module
  var Chatty = namespace.module();</p>

<p>  Chatty.Views.Subject = Backbone.View.extend({</p>

<pre><code>tagName: 'div',
className: 'subject',
events: {
  'click': 'onClick'
},
initialize: function() {
  this.render();
  this.$el.html("I'm the Subject. Everyone listen up!");
},
onClick: function(e) {
  namespace.app.trigger('clicked:subject', 'watch it, buster!'); // &lt;-- trigger a framework event
}
</code></pre>

<p>  });</p>

<p>  Chatty.Views.Observer = Backbone.View.extend({</p>

<pre><code>tagName: 'div',
className: 'observer',
initialize: function() {
  this.render();
  this.$el.html("I'm the Observer. Quietly waiting...");

  namespace.app.on('clicked:subject', this.onSubjectClicked, this); &lt;-- listen for framework events
},
onSubjectClicked: function(message) {
  this.$el.html("I heard the Subject say... " + message);
}
</code></pre>

<p>  });</p>

<p>  // Required, return the module for AMD compliance
  return Chatty;</p>

<p>});
```</p>

<p>In our main.js file we're just going to append those two views to the DOM whenever someone hits our route:</p>

<p>``` js main.js
require([
  "namespace",</p>

<p>  // Libs
  "jquery",
  "use!backbone",</p>

<p>  // Modules
  "modules/chatty"
],</p>

<p>function(namespace, $, Backbone, Chatty) {</p>

<p>  // Defining the application router, you can attach sub routers here.
  var Router = Backbone.Router.extend({</p>

<pre><code>routes: {
  "chatty": "chatty"
},

chatty: function() {
  var subject = new Chatty.Views.Subject();
  var observer = new Chatty.Views.Observer();
  $("#main").append(subject.el);
  $("#main").append(observer.el);
}
</code></pre>

<p>  });</p>

<p>  ...
```</p>

<p>And there you have it. When we click on <code>Subject</code> it should replace the content in <code>Observer</code> like so:
<img class="center" src="/images/subject_observer.png" title="'The Observer hears the Subject'" ></p>

<ul>
<li>Time: 8:02 am</li>
<li>Mood: Excited, Rested</li>
<li>Sleep: 6</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone Events: Adding Views to the DOM]]></title>
    <link href="http://robdodson.me/blog/2012/05/24/backbone-events-between-views/"/>
    <updated>2012-05-24T07:23:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/24/backbone-events-between-views</id>
    <content type="html"><![CDATA[<p>Today I want to figure out what kind of events to use when one of my views is added to the DOM. This can have a lot of ramifications for positioning elements around the view and setting up properties on the view itself.</p>

<h3>View Events and the DOM</h3>

<p>After looking around for a bit I've found this <a href="http://documentcloud.github.com/backbone/#FAQ-events">list of the events that Backbone can dispatch.</a> Nothing in there about render or adding elements to the DOM :(</p>

<p>More searching reveals that almost everyone points to the <a href="http://docs.jquery.com/Plugins/livequery">livequery plugin for jQuery.</a> Livequery seems like a mostly deprecated plugin since jQuery has both <code>.live()</code> and <code>.delegate()</code> methods now. The one exception is that livequery will fire a callback when an element is created.</p>

<p>Another alternative is to fire a custom event from my View's render method. While this does seem cleaner than using a plugin unfortunately we might call render over and over again. A middle of the road solution would be to use <code>.one()</code> to bind to the first render event.</p>

<p>In my mind I would like every Backbone View to extend a base class which dispatches a custom <code>addedToDOM</code> event and <code>removedFromDOM</code> event. I'm not sure what the performance cost of using livequery to do this is but let's write it up and maybe we can do a jsPerf later.</p>

<h3>Load a jQuery plugin with AMD</h3>

<p>Let's download livequery <a href="https://github.com/brandonaaron/livequery">from the git repo.</a> Now that we have it we're in another little dilemma. The boilerplate loads jQuery like an AMD module...so how do you use a jQuery plugin with AMD?</p>

<p>It's very possible this is not the intended method but here's how I've gone about solving the problem. Since require.js is only going to load stuff if we specify it as a dependency then we'll need to request the plugin just like any other module. If we put the plugin in our <code>assets/js/plugins</code> folder then we'll already have a path to <code>plugins</code> provided by <code>config.js</code>.</p>

<p>``` js config.js
require.config({
  // Initialize the application with the main application file
  deps: ["main"],</p>

<p>  paths: {</p>

<pre><code>// JavaScript folders
libs: "../assets/js/libs",
plugins: "../assets/js/plugins", // &lt;---- !!! look here! 

// Libraries
jquery: "../assets/js/libs/jquery",
underscore: "../assets/js/libs/underscore",
backbone: "../assets/js/libs/backbone",

// Shim Plugin
use: "../assets/js/plugins/use"
</code></pre>

<p>  },</p>

<p>  use: {</p>

<pre><code>backbone: {
  deps: ["use!underscore", "jquery"],
  attach: "Backbone"
},

underscore: {
  attach: "_"
}
</code></pre>

<p>  }
});
```</p>

<p>Then we can load livequery as if it were any other module. This might seem odd because a dependency gets passed to our pseudo-constructor as an argument:</p>

<p>``` js
define([
  "namespace",</p>

<p>  // Libs
  "use!backbone",</p>

<p>  // Modules</p>

<p>  // Plugins
  "plugins/jquery.livequery"
],</p>

<p>function(namespace, Backbone, livequery) { // &lt;-- see how livequery is passed</p>

<p>...</p>

<p>```</p>

<p>But we're not going to use that argument. It's just there to make sure that <code>jquery.livequery.js</code> gets added to the page. We'll ignore it and use livequery via jquery instead, like so:</p>

<p>``` js
$('#sections').livequery(function() {</p>

<pre><code>console.log('sections added to DOM!');
</code></pre>

<p>}, function() {</p>

<pre><code>console.log('sections removed from DOM!');
</code></pre>

<p>});
<code>``
Keep in mind that require.js and AMD are just tacking the script elements onto the page. Requiring our plugin in this fashion is no different than tacking a</code>script` onto the HTML at runtime.</p>

<p>Here's my example.js file <a href="http://robdodson.me/blog/2012/05/23/how-do-you-switch-between-views-in-backbone/">from the last post</a>, now using livequery to listen for when the element is added to and removed from the DOM.</p>

<p>``` js example.js
define([
  "namespace",</p>

<p>  // Libs
  "use!backbone",</p>

<p>  // Modules</p>

<p>  // Plugins
  "plugins/jquery.livequery"
],</p>

<p>function(namespace, Backbone, livequery) {</p>

<p>  // Create a new module
  var Example = namespace.module();</p>

<p>  // Example extendings
  Example.Model = Backbone.Model.extend({ /<em> ... </em>/ });
  Example.Collection = Backbone.Collection.extend({ /<em> ... </em>/ });
  Example.Router = Backbone.Router.extend({ /<em> ... </em>/ });</p>

<p>  // This will fetch the tutorial template and render it.
  Example.Views.Tutorial = Backbone.View.extend({</p>

<pre><code>template: "app/templates/example.html",

render: function(done) {
  var view = this;

  // Fetch the template, render it to the View element and call done.
  namespace.fetchTemplate(this.template, function(tmpl) {
    view.el.innerHTML = tmpl();

    // If a done function is passed, call it with the element
    if (_.isFunction(done)) {
      done(view.el);
    }
  });
}
</code></pre>

<p>  });</p>

<p>  Example.Views.Left = Backbone.View.extend({</p>

<pre><code>tagName: 'div',
id: 'left-container',
className: 'container'
</code></pre>

<p>  });</p>

<p>  Example.Views.Middle = Backbone.View.extend({</p>

<pre><code>tagName: 'div',
id: 'middle-container',
className: 'container'
</code></pre>

<p>  });</p>

<p>  Example.Views.Right = Backbone.View.extend({</p>

<pre><code>tagName: 'div',
id: 'right-container',
className: 'container'
</code></pre>

<p>  });</p>

<p>  Example.Views.Sections = Backbone.View.extend({</p>

<pre><code>tagName: 'div',
id: 'sections',

leftView: undefined,
middleView: undefined,
rightView: undefined,

events: {
  "click .container":    "onChildClicked"
},

initialize: function() {
  this.leftView = new Example.Views.Left();
  this.middleView = new Example.Views.Middle();
  this.rightView = new Example.Views.Right();

  this.$el.append(this.leftView.render().el);
  this.$el.append(this.middleView.render().el);
  this.$el.append(this.rightView.render().el);

  $('#sections').livequery(function() {
    console.log('sections added to DOM!');
  }, function() {
    console.log('sections removed from DOM!');
  });
},

// We should do this work with events instead of methods
setInitialPosition: function() {
  this.$el.css({left: $(window).width() / 2 - this.$el.width() / 2 });
},

onChildClicked: function($e) {
  var $target = $($e.target);

  switch($e.target.id) {
    case 'left-container':
      this.$el.animate({left: $(window).width() / 2 - $target.width() / 2});
      break;

    case 'middle-container':
      this.$el.animate({left: $(window).width() / 2 - this.$el.width() / 2 });
      break;

    case 'right-container':
      this.$el.animate({left: $(window).width() / 2 - this.$el.width() + $target.width() / 2});
      break;
  }
}
</code></pre>

<p>  });</p>

<p>  // Required, return the module for AMD compliance
  return Example;</p>

<p>});
```</p>

<p>I tried this out by adding and removing the <code>Example.Sections</code> view from the DOM and both console logs fired, so yeah, awesome! In lieu of creating a base class and adding an addedToDOM and removedFromDOM event we can do something like this to achieve that effect:</p>

<p>``` js example.js
initialize: function() {
  this.leftView = new Example.Views.Left();
  this.middleView = new Example.Views.Middle();
  this.rightView = new Example.Views.Right();</p>

<p>  this.$el.append(this.leftView.render().el);
  this.$el.append(this.middleView.render().el);
  this.$el.append(this.rightView.render().el);</p>

<p>  _.bindAll(this); // make sure all the methods of our object have the right 'this'</p>

<p>  $('#sections').livequery(this.onAddedToDOM, this.onRemovedFromDOM);
},</p>

<p>onAddedToDOM: function() {
  console.log('added to DOM!');
},</p>

<p>onRemovedFromDOM: function() {
  console.log('removed from DOM!');
},
```</p>

<ul>
<li>Time: 7:47 am</li>
<li>Mood: Awake, Hot</li>
<li>Sleep: 5</li>
<li>Hunger: 5</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
</feed>
