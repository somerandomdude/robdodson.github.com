<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chain | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/chain/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-06-20T00:32:03-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Crawling pages with Mechanize and Nokogiri]]></title>
    <link href="http://robdodson.me/blog/2012/06/20/crawling-pages-with-mechanize-and-nokogiri/"/>
    <updated>2012-06-20T00:09:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/20/crawling-pages-with-mechanize-and-nokogiri</id>
    <content type="html"><![CDATA[<p>Short post tonight because I spent so much time figuring out the code. It's late and my brain is firing on about 1 cylinder so it took longer than I expected to get everything working.</p>

<p>The scraper that I'm building is supposed to work like a spider and crawl of the pages of my blog. I wasn't sure what the best way to do that was so I started Googling and came up with <a href="http://mechanize.rubyforge.org/">Mechanize.</a> There are other tools built on top of Mechanize, like <a href="https://github.com/felipecsl/wombat">Wombat</a>, but since my task is so simple I figured I could just write everything I needed with Mechanize and Nokogiri. It's usually a better idea to work with simple tools when you're first grasping concepts so you don't get lost in the weeds of some high powered framework.</p>

<p>Since it's late I'll let the code do the talking:</p>

<p>``` ruby crawler.rb
require 'mechanize'</p>

<h1>Create a new instance of Mechanize and grab our page</h1>

<p>agent = Mechanize.new
page = agent.get('http://robdodson.me/blog/archives/')</p>

<h1>Find all the links on the page that are contained within</h1>

<h1>h1 tags.</h1>

<p>post_links = page.links.find_all { |l| l.attributes.parent.name == 'h1' }</p>

<h1>Click on one of our post links and store the response</h1>

<p>post = post_links[1].click
doc = page.parser # Same as Nokogiri::HTML(page.body)
p doc
```</p>

<p>This code is hopefully easy enough to digest. After I get the page I find all of the links which are wrapped inside of an <code>h1</code>. Just as an example I <code>click</code> a link from the list using Array syntax and store the response in another var. You <em>could</em> click all of the links by iterating through the post_links object, and that's what we'll tackle tomorrow. For now I just follow 1 link and use a convenience method to parse the page with Nokogiri. After that we have a Nokogiri <code>doc</code> ready to be manipulated however we see fit.</p>

<p><a href="https://gist.github.com/2958538">Here's a link to the Gist</a> if you'd like to tweak or play with the code. Pop it into <code>irb</code> and give it a shot. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 12:10 am</li>
<li>Mood: Tired, Introspective</li>
<li>Sleep: 4.5</li>
<li>Hunger: 2</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Outputting JSON from Ruby]]></title>
    <link href="http://robdodson.me/blog/2012/06/18/outputting-json-from-ruby/"/>
    <updated>2012-06-18T08:19:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/18/outputting-json-from-ruby</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/06/17/object-oriented-scraper-backed-with-tests-pt-dot-dot-dot-9/">Last night</a> I got the scraper to write an output.txt file which listed all the contents of <code>words_by_selector</code>. Today I want to make it write to JSON instead of plain text and I want to back it with some tests.</p>

<h2>Updating our tests</h2>

<p>Our current test for <code>words_by_selector</code> looks like this:</p>

<p><code>ruby spec/crawler_spec.rb
it "should produce the correct Array of keywords" do
  expected_array = ['hello: 3', 'world: 2', 'foobar: 1']
  actual_array = @crawler.words_by_selector(@options[:post_selector], @options[:ignored_post_selector])
  actual_array.should eq(expected_array)
end
</code>
We're going to need to break that sucker so it'll produce something more like this:</p>

<p>``` ruby spec/crawler_spec.rb
it "should produce the correct Hash of keywords" do
  expected_hash = {</p>

<pre><code>  word_count: [
    {
      word: 'hello',
      count: 3
    },
    {
      word: 'world',
      count: 2
    },
    {
      word: 'foobar',
      count: 1
    },
  ]
}
</code></pre>

<p>  actual_hash = @crawler.words_by_selector(@options[:post_selector], @options[:ignored_post_selector])
  actual_hash.should eq(expected_hash)
end
```</p>

<p>And we update <code>words_by_selector</code> to look like this:</p>

<p>``` ruby tentacles/lib/tentacles/crawler.rb
def words_by_selector(selector, ignored_selector = nil)
  node = nodes_by_selector(selector).first
  if ignored_selector</p>

<pre><code>ignored = node.css(ignored_selector)
ignored.remove()
</code></pre>

<p>  end
  words = words_from_string(node.content)
  count_frequency(words)</p>

<p>  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map! do |word, count|</p>

<pre><code>{ word: word, count: count }
</code></pre>

<p>  end
  { word_count: sorted }
end
```</p>

<p>Our new test should pass. Feel free to flip one of the numbers in the expected_hash to 99 or something to see it fail.</p>

<p>Now let's make sure the runner takes the content out of the crawler and writes it to a JSON file.</p>

<p>``` ruby spec/runner_spec.rb
it "should create a directory for our output" do
  @runner.run
  Dir.exists?('../../output').should be_true
end</p>

<p>it "should output the correct JSON" do
  @runner.run
  File.open("../../output/word_count.json") do |file|</p>

<pre><code>file.each_line do |line|
  puts line
end
</code></pre>

<p>  end
end
```
And in runner.rb...</p>

<p>``` ruby tentacles/lib/tentacles/runner.rb
def run    <br/>
  @crawler = Tentacles::Crawler.from_uri(@options.uri)
  output = @crawler.words_by_selector(@options.post_selector, 'ul:last-child')</p>

<p>  Dir.mkdir('../../output') unless Dir.exists?('../../output')</p>

<p>  File.open("../../output/word_count.json", "w") do |file|</p>

<pre><code>file.puts JSON.pretty_generate(output)
</code></pre>

<p>  end
end
```</p>

<p>And there we go. Our first decent output from the crawler :D -Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 8:20 am</li>
<li>Mood: Awake</li>
<li>Sleep: 6</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed With Tests Pt...9?]]></title>
    <link href="http://robdodson.me/blog/2012/06/17/object-oriented-scraper-backed-with-tests-pt-dot-dot-dot-9/"/>
    <updated>2012-06-17T22:43:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/17/object-oriented-scraper-backed-with-tests-pt-dot-dot-dot-9</id>
    <content type="html"><![CDATA[<p>I just spent a few hours talking to my friend <a href="http://derekbradley.com/">Derek</a>(<a href="https://twitter.com/#!/derekebradley">@derekebradley</a>) about Ruby and it occured to me that I never finished this scraper project. We got awfully far with it but then it kind of died on the vine. <a href="http://robdodson.me/blog/2012/05/06/object-oriented-scraper-backed-with-tests/">Thankfully,</a> <a href="http://robdodson.me/blog/2012/05/07/object-oriented-scraper-backed-with-tests-pt-2/">I</a> <a href="http://robdodson.me/blog/2012/05/08/object-oriented-scraper-backed-with-tests-pt-3/">wrote</a> <a href="http://robdodson.me/blog/2012/05/11/object-oriented-scraper-backed-with-tests-pt-4/">it</a> <a href="http://robdodson.me/blog/2012/05/12/object-oriented-scraper-backed-with-tests-pt-5/">all</a> <a href="http://robdodson.me/blog/2012/05/13/object-oriented-scraper-backed-with-tests-pt-6/">down.</a> <a href="http://robdodson.me/blog/2012/05/15/object-oriented-scraper-backed-with-tests-pt-7/">down.</a> <a href="http://robdodson.me/blog/2012/05/16/object-oriented-scraper-backed-with-tests-pt-8/">down.</a></p>

<p>The fact of the matter is I didn't know where to take the data. I didn't have a design or a layout that I could put it all into. I want to change all that. I want to turn this into something useful. But first I have to make sense of all the code that was written so many weeks ago.</p>

<h2>Tests as documentation...bullshit.</h2>

<p>Ok ok. I should say it's <em>total</em> bullshit to call your tests the documentation because they are helpful. But the fact of the matter is you can get so crafty with RSpec that it makes the tests difficult to read in a useful way. I'm not saying they're illegible, it's just that they leverage features which adds to their thought deficit. Before you go off saying that I wrote them wrong and tests should be all the documentation you need...shutup. They're helpful but I would love it if I had written a bit of Markdown Readme to go with all this...</p>

<h2>Explain yourself</h2>

<p>Let's see if I can regurgitate what this thing currently does in plain English.</p>

<ul>
<li><p>There's a config.yml file. It says what page to scrape, what the CSS selector for a post looks like and what the CSS selector for metadata looks like. The metadata is the list at the bottom of every page listing the time, amount of sleep, coffee, etc.</p></li>
<li><p>There's a command line object, <code>tentacles</code>. It initiates <code>runner.rb</code>. <code>Runner</code> creates an instance of <code>Options</code>. <code>Options</code> loads the config.yml file and parses it, turning its properties into members of the options object.</p></li>
<li><p>It actually doesn't do anything else beyond that. <code>runner.rb</code> stops right there but we have Rspec tests which fake data and check to see if our other classes work. Those other classes are...</p></li>
<li><p><code>crawler.rb</code> should be the real meat of our program. Funny, seeing as how I wrote all this, that I totally can't remember who does what...</p></li>
<li><p><code>crawler.rb</code> has two primary methods: <code>words_by_selector</code> and <code>metadata_by_selector</code>.</p></li>
<li><p><code>words_by_selector</code> returns an array of words and the number of times they've occurred. This array should be in order from most used to least used.</p></li>
<li><p><code>metadata_by_selector</code> returns the content of one of our metadata lists.... I think.</p></li>
</ul>


<h2>Make it work</h2>

<p>With Tim Gunn's mantra we're gonna make this thing work. The tests verify that everything should be at least somewhat functioning. Since I'm a little drunk I can't do a <em>super</em> deep dive but let's see if we can get our runner to write out the contents of <code>words_by_selector</code> to a text file.</p>

<p>``` ruby runner.rb
require 'yaml'
require_relative 'options'
require_relative 'crawler'</p>

<p>module Tentacles
  class Runner</p>

<pre><code>def initialize(config)
  @options = Tentacles::Options.new(config)
end

def run      
  @crawler = Tentacles::Crawler.from_uri(@options.uri)
  output = @crawler.words_by_selector(@options.post_selector, 'ul:last-child')
  File.open("output.txt", "w") do |file|
    output.each do |line|
      file.puts line
    end
  end
end
</code></pre>

<p>  end
end
```</p>

<p>To get this working I <code>cd</code> into the lib/ folder where all the code lives and do an <code>irb -I .</code> so I can require the local files.</p>

<p><code>
require 'runner'
runner = Tentacles::Runner.new('config.yml')
runner.run
</code></p>

<p>After doing that we <em>do</em> get a text file, with copy that looks somewhat correct...</p>

<p><code>
we: 8
to: 8
npm: 6
should: 5
package: 4
our: 4
compliment: 4
git: 3
0: 3
4: 3
need: 3
2: 3
it: 3
node_modules: 3
the: 3
have: 3
be: 3
json: 2
your: 2
any: 2
dependencies: 2
module: 2
and: 2
node: 2
add: 2
xml2json: 2
how: 2
s: 2
in: 2
you: 2
json1: 2
an: 2
3: 2
awesome: 2
version: 2
</code></p>

<p>It looks like the copy from my most recent blog post, plus or minus a few words. Horrible regex aside it <em>kinda</em> works and that's what we're after. Maybe tomorrow we can turn it into some JSON :D Till then. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 10:44 pm</li>
<li>Mood: Drunk, Sleepy</li>
<li>Sleep: 3</li>
<li>Hunger: 4</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Publish your Node Library to NPM]]></title>
    <link href="http://robdodson.me/blog/2012/06/16/publish-your-node-library-to-npm/"/>
    <updated>2012-06-16T23:06:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/16/publish-your-node-library-to-npm</id>
    <content type="html"><![CDATA[<p>Alright, <a href="http://robdodson.me/blog/2012/06/15/how-to-run-a-node-script-from-the-command-line/">contuing from yesterday</a> we want to take our little Node module and make it available to the world as a really awesome command line tool.</p>

<p>The first thing we need to do is register an NPM account.</p>

<p><code>npm adduser</code></p>

<p>Fill in your credentials and it should be ready to go.</p>

<p>If we have any dependencies they should be added to our <code>package.json</code> file. Our simple <code>compliment</code> program doesn't need any extra libraries but we'll add <code>xml2json</code> just to demonstrate how it's done.</p>

<p>``` js package.json
{</p>

<pre><code>"name": "compliment",
"version": "0.0.1",
"description": "Tell us how awesome we are.",
"preferGlobal": "true",
"bin": { "compliment": "compliment.js" },
"author": "Rob Dodson",
"dependencies": {
    "xml2json": "0.2.4"
},
"engines": { "node": "*" }
</code></pre>

<p>}
```</p>

<p>Since we've changed our <code>package.json</code> we need to run <code>npm link</code> again to install the dependency. After that you should have a <code>node_modules/</code> folder in your project root.</p>

<p>Let's put this baby under version control!</p>

<p><code>
git init
echo node_modules/ &gt;&gt; .gitignore # node_modules should be installed by npm
git add .
git commit -am 'Initial commit'
</code></p>

<p>Final step: <code>npm publish</code></p>

<h1>BOOMJAMS! We have us an npm module! - Rob</h1>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 11:06 pm</li>
<li>Mood: Hyper</li>
<li>Sleep: 5</li>
<li>Hunger: 1</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Run a Node Script from the Command Line]]></title>
    <link href="http://robdodson.me/blog/2012/06/15/how-to-run-a-node-script-from-the-command-line/"/>
    <updated>2012-06-15T19:46:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/15/how-to-run-a-node-script-from-the-command-line</id>
    <content type="html"><![CDATA[<p>This post is going to be short and sweet because I have to help my lady pack for her big trip to Germany. Over the past few days I've been messing around with command line tools written in Ruby so today I decided to give it a shot in Node.</p>

<p>We're going to start small in this first post and just get a little script running. After that we'll step it up so it can be distributed using NPM, <a href="http://robdodson.me/blog/2012/06/14/how-to-write-a-command-line-ruby-gem/">just like we did with our previous Ruby gem.</a></p>

<h2>First write some codez</h2>

<p>Make a new directory called <code>compliment</code> and create two files inside of it: <code>comliment.js</code> and <code>package.json</code>.</p>

<p>In <code>compliment.js</code> we're just going to print out some kind words.</p>

<p>``` js compliment/compliment.js</p>

<h1>! /usr/bin/env node</h1>

<p>console.log('you. are. AWESOME!');
```</p>

<p>Simple enough right? Just make sure you include that shebang up at the top which directs the system to use Node to execute our script.</p>

<h2>Package it up</h2>

<p>Ok now that we have our little script we'll give its <code>package.json</code> some love.</p>

<p>``` js compliment/package.json
{</p>

<pre><code>"name": "compliment",
"version": "0.0.1",
"description": "Tell us how awesome we are.",
"preferGlobal": "true",
"bin": { "compliment": "compliment.js" },
"author": "Rob Dodson",
"engines": { "node": "*" }
</code></pre>

<p>}
```</p>

<p>Most of that should be self explanatory. The key aspect is the <code>bin</code> section where you tell it to translate <code>compliment</code> into <code>compliment.js</code>. To install it all we have to do is run <code>npm link</code>. After you've done that you should be able to type <code>compliment</code> and hear how awesome you are!</p>

<p>Keep in mind this isn't distributable just yet, we'll work on that tomorrow. Till then have fun playing with your new powers :D</p>

<ul>
<li>Rob</li>
</ul>


<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 8:18 am</li>
<li>Mood: Awake, Antsy</li>
<li>Sleep: 6</li>
<li>Hunger: 2</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
</feed>
