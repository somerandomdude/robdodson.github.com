<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chain | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/chain/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-05-07T22:34:13-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed With Tests pt. 2]]></title>
    <link href="http://robdodson.me/blog/2012/05/07/object-oriented-scraper-backed-with-tests-pt-2/"/>
    <updated>2012-05-07T18:48:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/07/object-oriented-scraper-backed-with-tests-pt-2</id>
    <content type="html"><![CDATA[<p>I'm picking up from where I left off last night. If you look back at the <a href="/blog/2012/05/06/object-oriented-scraper-backed-with-tests/">previous post</a> we ended with a spec'd out <code>Runner</code> object. Now we need to build our <code>Crawler</code> which will slurp up all the content from our posts and return them as meaningful data.</p>

<p>Our Crawler will have 2 main responsibilities. First it will iterate over a post and return a Hash of words and their usage count. Second, it will iterate over a post and pull out any metadata and associate that with a Date. These are rather simple goals and if you remember from our original scraper we were actually hitting every post on the main page. I think I'd like to nail down these simple functions and then refactor the Crawler to accept a corpus page full of links—<a href="http://robdodson.me/blog/archives/">like our archives page</a>—which it will follow and parse. Right now I want to start small.</p>

<p>Here's a list of what I <em>think</em> would be good tests for our <code>Crawler</code>.</p>

<ul>
<li>It should return an instance in exchange for a valid URI. Since the URI comes from the Runner and that's already being tested we'll assume that the URI we're given is valid.</li>
<li>It should respond to a <code>get_word_counts</code> method.</li>
<li>The get_word_counts method should accept a selector <code>String</code> and return a <code>Hash</code> of words and their counts. Since the selector will be coming from the Runner we'll assume it's valid too but first we'll need to put another test in our <code>runner_spec.rb</code>.</li>
<li>It should respond to a <code>get_metadata</code> method.</li>
<li>The get_metadata method should also accept a selector <code>String</code> and return a <code>Hash</code> with a valid <code>Date</code> and each piece of metadata categorized. Let's see how far we can take this by converting strings related to time into <code>Time</code> objects and any categories with multiple entries into <code>Arrays</code>.</li>
</ul>


<p>I'm actually going to copy and paste the above list into my specs and start buliding from there.</p>

<p>....</p>

<p>Hmm... actually I'm not. Something about this doesn't feel right. <code>Runner</code> has accrued too much responsibility. It's supposed to validate 3 different strings parsed from a YAML file which it loads and then it also has to deal with creating and running the <code>Crawler</code>. I think it's time for another object. Which we'll call <code>Options</code>. Options will be in charge of loading our YAML and verifying that all the values are valid. <code>Runner</code> will create both an Options and a Crawler object and pass the values from Options to Crawler. This is actaully also in line with the Pickaxe book's Anagrams example, so we have a nice guide to follow in that.</p>

<p>OK so <code>Options</code>, eh? Well we'll need to spec out its responsibilities. I think we can just take the tests we wrote for Runner and move them over to Options.</p>

<p>After doing this for while I've ended up with a TON of tests...only to validate 3 variables.</p>

<p>```ruby tentacles/spec/options_spec.rb
require_relative '../lib/tentacles/options'
require 'yaml'
require 'uri'
require 'helpers'</p>

<p>describe Tentacles::Options do
  include Helpers</p>

<p>  before do</p>

<pre><code>@options = Tentacles::Options.new(relative_path + '/../lib/tentacles/config.yml')
</code></pre>

<p>  end</p>

<p>  subject { @options }</p>

<p>  it { should respond_to(:uri) }
  it { should respond_to(:post_selector) }
  it { should respond_to(:metadata_selector) }</p>

<p>  describe "when parsing the config file" do</p>

<pre><code>it "should raise an exception if the config file is missing" do
  expect { options = Tentacles::Options.new('') }.to raise_error(Errno::ENOENT)
  expect { options = Tentacles::Options.new(nil) }.to raise_error(TypeError)
end

it "should raise an exception if the config file is invalid" do
  expect { options = Tentacles::Options.new(relative_path + '/mocks/invalid_yaml.yml') }.to raise_error(Psych::SyntaxError)
end
</code></pre>

<p>  end</p>

<p>  describe "when parsing the URI" do</p>

<pre><code>it "should display the right URI" do
  uri = URI.parse('http://robdodson.me')
  @options.uri.should eq(uri)
end

it "should raise an exception if uri is empty" do
  expect { options = Tentacles::Options.new(relative_path + '/mocks/blank_uri.yml') }.to raise_error(Psych::SyntaxError)
end

it "should raise an exception if uri is invalid" do
  expect { options = Tentacles::Options.new(relative_path + '/mocks/invalid_uri.yml') }.to raise_error(Psych::SyntaxError)
end
</code></pre>

<p>  end</p>

<p>  describe "when parsing the post selector" do</p>

<pre><code>it "should have a post_selector" do
  @options.post_selector.should be('.entry-content')
end

it "should raise an exception if the post selector is empty" do
  expect { options = Tentacles::Options.new(relative_path + '/mocks/blank_uri.yml') }.to raise_error(Psych::SyntaxError)
end
</code></pre>

<p>  end</p>

<p>  describe "when parsing the metadata selector" do</p>

<pre><code>it "should have a metadata_selector" do
  @options.metadata_selector.should be('.personal-metadata')
end

it "should raise an exception if the metadata selector is empty" do
  expect { options = Tentacles::Options.new(relative_path + '/mocks/blank_uri.yml') }.to raise_error(Psych::SyntaxError)
end
</code></pre>

<p>  end
end
```</p>

<p>Here's my implementation of <code>options.rb</code>
```ruby tentacles/lib/tentacles/options.rb
require 'yaml'</p>

<p>module Tentacles
  class Options</p>

<pre><code>attr_reader :uri
attr_reader :post_selector
attr_reader :metadata_selector

def initialize(config)
  @config = YAML.load(File.open(config))

  @uri = URI.parse(@config[:uri])
  raise IOError, 'invalid uri!' if @uri.scheme.nil? || @uri.host.nil?

  @post_selector = @config[:post_selector]
  raise IOError, 'post_selector is not defined' if @post_selector.empty? 

  @metadata_selector = @config[:metadata_selector]
  raise IOError, 'metadata_selector is not defined' if @metadata_selector.empty? 
end
</code></pre>

<p>  end
end
```</p>

<p>Seems like now might be a good time to pause for a bit. When I look at those tests I see a lot of places where I'm testing Classes that have probably already been tested. I feel like you can safely assume that if you pass <code>YAML.load</code> a bunch of junk it's going to throw an error. Is there any value in testing something like that for my own implementation? I'm guessing not. However I do think it's important that I test the 3 exceptions that I wrote. I'll get all the tests to pass and then I'll go back and clean it up.</p>

<h3>Making the Tests Pass</h3>

<p>I like to comment out my spec file and go line by line making each test pass as I go. I'm pretty good at writing failing tests (heh) so this approach adheres well to the red, green, refactor mantra.</p>

<p>Starting out I have a problem in the first block which checks my <code>attr_readers</code>:</p>

<p><code>ruby
it { should respond_to(:uri) }
it { should respond_to(:post_selector) }
it { should respond_to(:metadata_selector) }
</code></p>

<p>Let's see if I can get just the first test to pass... I comment out everything inside of Options and notice that YAML does not use symbols for keys. It seems like loaded YAML uses Strings for keys. After changing my symbol keys to strings my first block of tests pass.</p>

<p>```ruby tentacles/lib/tentacles/options.rb
require 'yaml'</p>

<p>module Tentacles
  class Options</p>

<pre><code>attr_reader :uri
attr_reader :post_selector
attr_reader :metadata_selector

def initialize(config)
  @config = YAML.load(File.open(config))

  @uri = URI.parse(@config["uri"])
  raise IOError, 'invalid uri!' if @uri.scheme.nil? || @uri.host.nil?

  @post_selector = @config["post_selector"]
  raise IOError, 'post_selector is not defined' if @post_selector.empty? 

  @metadata_selector = @config["metadata_selector"]
  raise IOError, 'metadata_selector is not defined' if @metadata_selector.empty? 
end
</code></pre>

<p>  end
end
```</p>

<p>The next block passes quite easily because it's ported over from the <code>Runner</code> class</p>

<p>```ruby
describe "when parsing the config file" do</p>

<pre><code>it "should raise an exception if the config file is missing" do
  expect { options = Tentacles::Options.new('') }.to raise_error(Errno::ENOENT)
  expect { options = Tentacles::Options.new(nil) }.to raise_error(TypeError)
end

it "should raise an exception if the config file is invalid" do
  expect { options = Tentacles::Options.new(relative_path + '/mocks/invalid_yaml.yml') }.to raise_error(Psych::SyntaxError)
end
</code></pre>

<p>  end
```</p>

<p>After that we run into some issues because our next set of tested exceptions have the wrong class.</p>

<p>```ruby
  describe "when parsing the URI" do</p>

<pre><code>it "should display the right URI" do
  uri = URI.parse('http://robdodson.me')
  @options.uri.should eq(uri)
end

it "should raise an exception if uri is empty" do
  expect { options = Tentacles::Options.new(relative_path + '/mocks/blank_uri.yml') }.to raise_error(Psych::SyntaxError)
end

it "should raise an exception if uri is invalid" do
  expect { options = Tentacles::Options.new(relative_path + '/mocks/invalid_uri.yml') }.to raise_error(Psych::SyntaxError)
end
</code></pre>

<p>  end
<code>``
Changing the last two exceptions to expect</code>Errno::ENOENT<code>and</code>URI::InvalidURIError` in that order fixes things and we're all green again.</p>

<p>In the next block we have 2 failing tests because the first one is using improper syntax. Instead of <code>be</code> we should be using <code>eq</code>. Seems like in RSpec <code>be</code> is equivalent to === and not ==. Also we have another PSYCH::SyntaxError that needs to be replaced with <code>Errno::ENOENT</code>. Here's what we end up with after making those changes:</p>

<p>```ruby
describe "when parsing the post selector" do</p>

<pre><code>it "should have a post_selector" do
  @options.post_selector.should eq('.entry-content')
end

it "should raise an exception if the post selector is empty" do
  expect { options = Tentacles::Options.new(relative_path + '/mocks/blank_uri.yml') }.to raise_error(Errno::ENOENT)
end
</code></pre>

<p>  end
```
Ugh, hate to cut it short but looks like I'm going down a rabbit hole with validation. I'll pickup tomorrow to see if we can iron a lot of this out.</p>

<ul>
<li>Time: 7:11 pm</li>
<li>Mood: Calm, Hot, Tired</li>
<li>Sleep: 7</li>
<li>Hunger: 6.5</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests]]></title>
    <link href="http://robdodson.me/blog/2012/05/06/object-oriented-scraper-backed-with-tests/"/>
    <updated>2012-05-06T18:09:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/06/object-oriented-scraper-backed-with-tests</id>
    <content type="html"><![CDATA[<p><em>I just drank a ton of coffee and I'm blasting music in my headphones so this post my bit a bit more scatter-shot than most since I can't really focus :]</em></p>

<p>Yesterday I managed to build a pretty naive scraper using Nokogiri which would count how often each word was used in the first 10 posts of this blog. Basically scraping the home URL of the site and grabbing everything inside of the <code>div.entry-content</code> selector.</p>

<p>Today I want to convert it into a more OO library so it's a bit more modular and reusable. I also want to back everything with RSpec tests to get into the practice. While it won't be true TDD I'll try to write the tests for the library before putting the classes together.</p>

<h3>Design Decisions</h3>

<p>I'm calling the project <code>Tentacles</code> for now since it relates to my Octopress blog. I'm still trying to figure out exactly what the end product will be. So far I know that I want it to produce a page of statistics about my blog. I figure that for now it can be just one page with stats that cover the entire blog. In the future I might want to make it more granular so that each post can get special attention. For now it's easiest for me if I just think of the whole blog as a big data set and this page as the output.</p>

<p>I also know that since Octopress is heavily integrated with Rake that I'd probably like to trigger the process as part of a Rake task. IMO the logical place would be to amend Octopress' <code>rake generate</code> so that it not only builds our static pages but it also produces our statistics. Down the line I might want to change this but for now it seems OK to me.</p>

<p>Finally I figure I'll want to have some kind of configuration file so the parser knows what to look for.</p>

<p>For now I'm fine with the output being a plain text file with a few stats on it. We'll work on making the output more robust after we've figure out the basics of our module and integrated it with Rake.</p>

<p>Here's the folder structure I'm using:</p>

<ul>
<li>tentacles

<ul>
<li>bin      <em>&lt;--- contains our executable program</em>

<ul>
<li>tentacles</li>
</ul>
</li>
<li>lib      <em>&lt;--- contains our library of classes</em>

<ul>
<li>crawler.rb</li>
<li>config.yml</li>
<li>runner.rb</li>
</ul>
</li>
<li>spec      <em>&lt;--- contains our RSpec tests</em>

<ul>
<li>crawler_spec.rb</li>
<li>runner_spec.rb</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Playing with IRB</h3>

<p>One of the first issues I've run up against is figuring out how to play with my classes in IRB. Being new to Ruby I tend to build everything in one folder. Since this is my first time embarking on some actual modular structure I'm unsure how to require or include a module in IRB. What I've settled on for now is to <code>cd</code> into my lib folder and use the <code>-I</code> flag to set the <code>$LOAD_PATH</code>.</p>

<p>Here's the <code>grep</code> from the irb man page.</p>

<p><code>
-I path        Same as `ruby -I' .  Specifies $LOAD_PATH directory
</code></p>

<p>So we end up in <code>tentacles/lib</code> and call IRB like so:</p>

<p><code>
irb -I .
</code></p>

<p>And now we can require our classes</p>

<p><code>
irb -I .
1.9.3-p125 :001 &gt; require 'runner'
 =&gt; true # sweeet
</code></p>

<h3>Skeletons</h3>

<p>I'm going to create a basic <code>Runner</code> class so we can verify that the stuff in IRB is working properly.</p>

<p>Here's what I've thrown together:</p>

<p>```ruby
module Tentacles
  class Runner</p>

<pre><code>def initialize(config)
  # Load in our config file
end

def run
  puts 'run run run!'
end
</code></pre>

<p>  end
end
```</p>

<p>and here's how we test it in IRB.</p>

<p>```
irb -I .
require 'runner'</p>

<p>runner = Tentacles::Runner.new('foo')
 => #&lt;Tentacles::Runner:0x007faeb284ec30></p>

<p>runner.run
run run run!
 => nil
```</p>

<p>Looks good so far!</p>

<h3>Tests</h3>

<p>OK on to the tests then. I'm going to be using RSpec so if you don't have that setup already you should do a <code>gem install rspec</code>.</p>

<p>I'm a total noob when it comes to testing so let me take my best stab at this...</p>

<p>I'm going to write tests for <code>Runner</code> first since it's already stubbed out. I want to make sure of the following things:</p>

<ul>
<li>It should respond to the <code>run</code> method</li>
<li>When I pass it an invalid config file it should throw an error</li>
<li>When I pass it an empty string or nil in place of config it should throw an error</li>
</ul>


<p>For now that's the only public API this object has. Pretty simple but of course I'm immediately running into issues. Here's what my spec looks like:</p>

<p>```ruby tentacles/spec/runner_spec.rb
require_relative '../lib/tentacles/runner'</p>

<p>describe Tentacles::Runner do</p>

<p>  before do</p>

<pre><code>@runner = Tentacles::Runner.new('config.yml')
</code></pre>

<p>  end</p>

<p>  subject { @runner }</p>

<p>  it { should respond_to(:run) }</p>

<p>  describe "when passing the config file" do</p>

<pre><code>it "should raise an error if the config file is missing" do
  expect { runner = Tentacles::Runner.new('') }.to raise_error(Errno::ENOENT)
  expect { runner = Tentacles::Runner.new(nil) }.to raise_error(TypeError)
end
</code></pre>

<p>  end
end
```
and here's what runner.rb looks like:</p>

<p>```ruby tentacles/lib/tentacles/runner.rb
require 'yaml'</p>

<p>module Tentacles
  class Runner</p>

<pre><code>def initialize(config)
  @config = YAML.load(File.open(config))
end

def run      
  'Runner should be running'
end
</code></pre>

<p>  end
end
```
aaaaaand here's the error:</p>

<p>```bash
1) Tentacles::Runner</p>

<pre><code> Failure/Error: @runner = Tentacles::Runner.new('config.yml')
 Errno::ENOENT:
   No such file or directory - config.yml
 # ./lib/tentacles/runner.rb:10:in `initialize'
 # ./lib/tentacles/runner.rb:10:in `open'
 # ./lib/tentacles/runner.rb:10:in `initialize'
 # ./spec/runner_spec.rb:8:in `new'
 # ./spec/runner_spec.rb:8:in `block (2 levels) in &lt;top (required)&gt;'
</code></pre>

<p>```</p>

<p>It looks like the test is bailing out on my <code>before</code> block when I try to create an instance of runner and pass it the config file. Folks on IRC are kind enough to point out that <code>require</code> and methods run in RSpec don't necessarily have the same scope so trying <code>../lib/tentacles/config.yml</code> won't work either. The solution is to use <code>File.dirname(__FILE__) + '/../lib/tentacles/config.yml'</code>. Since I don't want my line lengths to get any longer I define a helper module and give it a <code>relative_path</code> method which should spit out <code>File.dirname(__FILE__)</code>.</p>

<p>```ruby tentacles/spec/helpers.rb
module Helpers
  def relative_path</p>

<pre><code>File.dirname(__FILE__)
</code></pre>

<p>  end
end
```
After I include it my tests look like this:</p>

<p>```ruby tentacles/spec/runner_spec.rb
require_relative '../lib/tentacles/runner'
require 'helpers'</p>

<p>describe Tentacles::Runner do
  include Helpers</p>

<p>  before do</p>

<pre><code>@runner = Tentacles::Runner.new(relative_path + '/../lib/tentacles/config.yml')
</code></pre>

<p>  end</p>

<p>  subject { @runner }</p>

<p>  it { should respond_to(:run) }</p>

<p>  describe "when passing the config file" do</p>

<pre><code>it "should raise an error if the config file is missing" do
  expect { runner = Tentacles::Runner.new('') }.to raise_error(Errno::ENOENT)
  expect { runner = Tentacles::Runner.new(nil) }.to raise_error(TypeError)
end

it "should raise an error if the config file is invalid" do
  expect { runner = Tentacles::Runner.new(relative_path + '/mocks/invalid_yaml.yml') }.to raise_error(Psych::SyntaxError)
end
</code></pre>

<p>  end</p>

<p>end
```
You'll also notice I added a test for an invalid yml file. Basically I created a mocks folder and tossed in a yaml file that's full of gibberish. Probably not the best way to mock stuff but whatever, i'm learning!</p>

<p>With that all of our tests for <code>Tentacles::Runner</code> are passing. Yay! But now it's 10:37pm and I gotta call it a night. We'll continue tomorrow by writing tests for <code>Tentacles::Crawler</code>. See ya!</p>

<ul>
<li>Time: 6:30 pm</li>
<li>Mood: Wired, Lazy</li>
<li>Sleep: 7.5</li>
<li>Hunger: 0</li>
<li>Coffee: 2</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Simple Scraper with Nokogiri in Ruby]]></title>
    <link href="http://robdodson.me/blog/2012/05/05/building-a-simple-scraper-with-nokogiri-in-ruby/"/>
    <updated>2012-05-05T21:08:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/05/building-a-simple-scraper-with-nokogiri-in-ruby</id>
    <content type="html"><![CDATA[<p>Since I've been talking so much about <a href="http://d3js.org/">D3.js</a> lately I thought it might be fun to start a little project which combines D3 and Ruby. The idea is to build a very simple page scraper that counts how often certain words are used in each post. I've also decided to start adding a little block of metadata at the end of each post so I can graph that over time as well.</p>

<p>So how do we get started? Well first we'll need to build a page scraper of some kind. This program will have to consume the contents of an HTML page, find the node that contains our blog post and count up how often each word reoccurs. For right now that should be more than enough to get us started. We'll look at grabbing the metadata and drawing graphs in future posts. I should point out that this idea was inspired by the wonderful site <a href="http://smarterware.org/5359/taking-on-the-750-words-march-challenge">750words.com</a> which creates <a href="http://smarterware.org/5359/taking-on-the-750-words-march-challenge">a beautiful exploration section</a> any time you write a new journal entry. Definitely check out that site, it's amazing.</p>

<h3>Hello Noko</h3>

<p>I decided early on that I wanted the scraper to use <a href="http://nokogiri.org/">Nokogiri</a> because I've heard so much about it. As the authors describe it:</p>

<blockquote><p>Nokogiri (鋸) is an HTML, XML, SAX, and Reader parser. Among Nokogiri’s many features is the ability to search documents via XPath or CSS3 selectors.</p></blockquote>

<p>Using CSS selectors means that working with Nokogiri is a lot like working with jQuery. Here's a quick demonstration:</p>

<p>```ruby
require 'open-uri'
require 'nokogiri'</p>

<p>doc = Nokogiri::HTML(open('https://www.google.com/search?q=unicorns'))</p>

<p>doc.css('h3.r a').each do |link|
  puts link.content
end
<code>``
Easy enough, right? Taking it a step further let's iterate over each element on the page and place them into a</code>Hash`.</p>

<p>```ruby
require 'open-uri'
require 'nokogiri'</p>

<p>@counts = Hash.new(0)</p>

<p>def words_from_string(string)
  string.downcase.scan(/[\w']+/)
end</p>

<p>def count_frequency(word_list)
  for word in word_list</p>

<pre><code>@counts[word] += 1
</code></pre>

<p>  end
  @counts
end</p>

<p>doc = Nokogiri::HTML(open('http://robdodson.me'))</p>

<h3>#</h3>

<h1>Search for nodes by css</h1>

<p>entries = doc.css('div.entry-content')
puts "Parsing #{entries.length} entries"
entries.each do |entry|
  words = words_from_string(entry.content)
  count_frequency(words)
end</p>

<p>sorted  = @counts.sort_by { |word, count| count }
puts sorted.map { |word, count| "#{word}: #{count}"}
```</p>

<p>The output from this script should look (kind of) like this:</p>

<p><code>text
...
ruby: 66
rvm: 66
our: 68
can: 71
3: 75
if: 77
for: 82
your: 88
2: 88
is: 91
this: 91
s: 94
we: 95
that: 106
i: 118
in: 119
it: 125
1: 128
and: 149
of: 170
a: 231
you: 233
to: 342
the: 382
</code>
It looks like our regex could use a bit of work so it doesn't grab singular letters like 's' or numbers, but it's definitely a good start. Tomorrow we'll put everything into a <code>Module</code> and back it with tests.</p>

<ul>
  <li>Time: 9:16 pm</li>
  <li>Mood: Relaxed, Tired</li>
  <li>Sleep: 6.5</li>
  <li>Hunger: 5</li>
  <li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[D3 Basics: The Linear Scale]]></title>
    <link href="http://robdodson.me/blog/2012/05/04/d3-basics-the-linear-scale/"/>
    <updated>2012-05-04T07:21:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/04/d3-basics-the-linear-scale</id>
    <content type="html"><![CDATA[<!-- CSS Styles: -->


<div>
  <style type="text/css">

    .chart {
      font-family: Arial, sans-serif;
      font-size: 10px;
    }

    .bar {
      fill: steelblue;
    }

    .axis path, .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .label {
      font-size: 12 px;
      fill: #FFF;
    }

    .point {
      stroke: #666;
      fill: red;
    }

  </style>
</div>


<p>In <a href="http://localhost:4000/blog/2012/05/03/d3-basics-an-introduction-to-scales/">the last post</a> we did a basic introduction to the concept of scales in <a href="http://d3js.org/">D3.js</a>. Today we'll look at our first scale and write some code to visualize it.</p>

<h3>Linear Scales</h3>

<p>The most basic scale in D3 is the <code>linear scale</code> which maps a continous <code>domain</code> to an output range. To define a linear domain we'll need to first come up with a data set. Fibonacci numbers work well, so let's declare a variable <code>data</code> like so:</p>

<p><code>js
var data = [1, 1, 2, 3, 5, 8];
</code></p>

<p>The data set will represent our scale's input domain. The next step is defining an output range. Since we're going to be graphing these numbers we want our range to represent screen coordinates. Let's go ahead and declare a <code>width</code> and a <code>height</code> variable and set them to 320 by 150.</p>

<p>```js
var width = 320,</p>

<pre><code>height = 150;
</code></pre>

<p>```</p>

<p>We now have everything we need to create our first scale.
```js
var x = d3.scale.linear()</p>

<pre><code>    .domain([0, d3.max(data)])
    .range([0, width]);
</code></pre>

<p>```</p>

<p>D3 methods often return a value of <code>self</code> meaning you can chain method calls onto one another. If you're used to jQuery this should be a common idiom for you. You'll notice that both the domain and the range functions accept arrays as parameters. Typically the domain only receives two values, the minimum and maximum of our data set. Likewise the range will be given the minimum and maximum of our output space. You could pass in multiple values to create a polylinear scale but that's outside the scope of our dicussion today.</p>

<p>In the domain function we're using a helper called <code>d3.max</code>. Similar to <code>Math.max</code>, it looks at our data set and figures out what is the largest value. While <code>Math.max</code> only works on two numbers, <code>d3.max</code> will iterate over an entire <code>Array</code> for us.</p>

<p>If you've been following along in your own file you should be able to open your console and type <code>x(8)</code> to get 300.</p>

<p>With just this information alone we have enough to build our first graph.</p>

<!-- D3.js Chart -->


<p><small>Fibonacci Sequence Chart 1.0</small></p>

<div id="linear-scale-chart-1"></div>


<script type='text/javascript'>
(function() {

  var data = [1, 1, 2, 3, 5, 8];
  var width = 320
      height = 150;

  var x = d3.scale.linear()
          .domain([0, d3.max(data)])
          .range([0, width]);

  var svg = d3.select('#linear-scale-chart-1').append('svg')
          .attr('width', width)
          .attr('height', height)
          .attr('class', 'chart');

  svg.selectAll('.chart')
          .data(data)
        .enter().append('rect')
          .attr('class', 'bar')
          //.attr('y', function(d, i) { return i * 20 })
          .attr('y', function(d, i) { return i * 20; })
          .attr('width', function(d) { return x(d); })
          .attr('height', 15);

})();
</script>


<p>```js JavaScript
var data = [1, 1, 2, 3, 5, 8];
var width = 320</p>

<pre><code>height = 150;
</code></pre>

<p>var x = d3.scale.linear()</p>

<pre><code>    .domain([0, d3.max(data)])  
    .range([0, width]);
</code></pre>

<p>var svg = d3.select('body').append('svg')</p>

<pre><code>    .attr('width', width)
    .attr('height', height)
    .attr('class', 'chart');
</code></pre>

<p>svg.selectAll('.chart')</p>

<pre><code>    .data(data)
  .enter().append('rect')
    .attr('class', 'bar')
    .attr('y', function(d, i) { return i * 20 })
    .attr('width', function(d) { return x(d); })
    .attr('height', 15);
</code></pre>

<p>```</p>

<p>```css CSS
.chart {
  font-family: Arial, sans-serif;
  font-size: 10px;
}</p>

<p>.bar {
  fill: steelblue;
}
```</p>

<h3>Break It Down</h3>

<p>Let's go through the JavaScript piece by piece to outline what happened.</p>

<p>```js
var data = [1, 1, 2, 3, 5, 8];
var width = 320</p>

<pre><code>height = 150;
</code></pre>

<p>var x = d3.scale.linear()</p>

<pre><code>    .domain([0, d3.max(data)])
    .range([0, width]);
</code></pre>

<p>```</p>

<p>The first block should be pretty familar at this point. We've declared our Fibonacci data, our explicit width and height and defined our scale. Nothing new here.</p>

<p>```js
var svg = d3.select('body').append('svg')</p>

<pre><code>    .attr('width', width)
    .attr('height', height)
    .attr('class', 'chart');
</code></pre>

<p>```</p>

<p>In the next section we're declaring our <code>SVG</code> element. We use a D3 selection to grab the <code>body</code> tag and we append an <code>svg</code> tag onto it. Since D3 uses method-chaining we can keep assigning attributes to our SVG element. We declare the width and the height to match the explicit values set earlier and finally we give it a class name of <code>chart</code>.</p>

<p>```js
svg.selectAll('.chart')</p>

<pre><code>    .data(data)
  .enter().append('rect')
    .attr('class', 'bar')
    .attr('y', function(d, i) { return i * 20 })
    .attr('width', function(d) { return x(d); })
    .attr('height', 15);
</code></pre>

<p>```</p>

<p>This last section is where it all ties together. Since we stored our SVG element in a variable called <code>svg</code> we're able to easily reference it again. We instruct D3 to create a <code>join</code> by calling the <code>data</code> method and passing in our <code>Array</code> of values. When D3 performs a join it steps through each element in the array and attempts to match it to a figure that already exists on the page. If nothing exists it will call the <code>enter</code> function. At this point it steps through the array again, passing the values to us so we can define new shapes. <a href="http://bost.ocks.org/mike/join/">For a much more in-depth explanation of joins refer back to this article.</a></p>

<p>In our case we're appending SVG <code>Rects</code> but it could just as easily be circles or other shapes. We give each rect a class of <code>bar</code> so we can style it with CSS. When we declare the <code>y</code> attribute instead of using an explicit value we create an <code>accessor</code>, a little helper function which takes a piece of data and an optional index as its arguments. In this case <code>d</code> will equal subsequent elements in our data array and <code>i</code> will equal their indices. For a much clearer picture of what's happening you can change it to read:
<code>js
.attr('y', function(d, i) { console.log('d = data[' + i + '] = ', d); return i * 20 })
</code>
which will give you the following output.
<code>js
d = data[0] = 1
d = data[1] = 1
d = data[2] = 2
d = data[3] = 3
d = data[4] = 5
d = data[5] = 8
</code></p>

<p>Since we're just trying to space out our bars along the y-axis we don't really care about the value of <code>d</code>. Instead we'll use the index, <code>i</code>, to offset each bar by a value of i * 20.</p>

<p>In the last two lines we're going to finally use our linear scale to define our bar's width. Here they are again as a refresher.
<code>js
.attr('width', function(d) { return x(d); })
.attr('height', 15);
</code>
As each element of the array is passed to our width accessor it's run through the scale and the output returned. Since 8 is our maximum value it should extend all the way to the end of our range.</p>

<p>The final call is just an explicit height for each bar. Depending on the scale this bit can be automated but for simplicity sake we'll just use a hard coded value so we can get something on screen.</p>

<h3>Conclusion</h3>

<p>Now that we've got one scale under our belt the others should be pretty easy to digest. Over the next couple of posts we'll focus on ordinal scales followed by time scales. Stay tuned and ping me if you have any questions. Thanks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[D3 Basics: An Introduction To Scales]]></title>
    <link href="http://robdodson.me/blog/2012/05/03/d3-basics-an-introduction-to-scales/"/>
    <updated>2012-05-03T10:04:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/03/d3-basics-an-introduction-to-scales</id>
    <content type="html"><![CDATA[<!-- CSS Styles: -->


<div>
  <style type="text/css">

    .chart {
      font-family: Arial, sans-serif;
      font-size: 10px;
    }

    .bar {
      fill: steelblue;
    }

    .axis path, .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

  </style>
</div>




<!-- Global Variables: -->


<script type="text/javascript">

  var data = [1, 1, 2, 3, 5, 8];

  var margin = {top: 40, right: 40, bottom: 40, left: 40},
      width = $('.entry-content').width(),
      height = 300;

  $(window).resize(function() {
    width = $('.entry-content').width();
  });

</script>


<p>After selections, scales are probably the most frequently used element in D3 because they faciliate such great control over data and screen space. I want to spend several posts documenting how scales work to help out anyone who is struggling with the concept. We'll start with a high level overview of what a scale is in D3 and then explore the individual objects to learn their nuances.</p>

<h3>What Are D3 Scales?</h3>

<p>Essentially a scale is a convenience function for mapping input data to an output range, typically x/y positions or width/height. Scales can also be used to link data to arbitrary values like categories or days of the week, or to quantize data into "buckets".</p>

<p>There are two universal properties for any scale: the <code>domain</code> and the <code>range</code>. The <code>domain</code> serves as the input for your graph while the <code>range</code> represents the output.</p>

<h4>Domain</h4>

<p>Since the <code>domain</code> corresponds to our graph's input it can be either <em>continuous</em> or <em>discrete</em>. You might think of a continous data set as any number from 1 to infinity while a discrete set would be every <code>Date</code> from January 1, 2012 to January 10, 2012. The takeaway is that continous data is essentially unbounded and discrete data is finite and easily quantified.</p>

<h4>Range</h4>

<p>The <code>range</code> defines the potential output that the scale can generate. Values from the domain are mapped to values in the range. Let's look at two examples to help clarify.</p>

<p>Say you have an <em>identity scale</em>, meaning whatever value you use for input will also be returned as the output. We'll call the scale <code>x</code>. If <code>x</code> has an input <code>domain</code> of 0 - 100 and an output <code>range</code> of 0 - 100, then your <code>scale of 1</code> will be 1. Your <code>scale of 50</code> will be 50. Here's another way to write it:</p>

<p><code>javascript
x(50) // returns 50
</code></p>

<p>Now let's change the scale a bit. Let's say that <code>x</code> still has an input <code>domain</code> of 0 - 100 but now it has an output <code>range</code> of <code>0 - 10</code>. What do you think our <code>scale of 50</code> will return? ... If you guessed 5 then you are the smart! Because we limited our potential output down to any number between 0 and 10 it narrowed the mapping from our <code>domain</code> to our <code>range</code>. Being able to expand or contract this mapping is the main value in using a D3 scale. If it's still not quite sinking in check out this great visual from <a href="http://www.jeromecukier.net/">Jerome Cukier</a> (<a href="https://twitter.com/#!/jcukier">@jcukier</a>).</p>

<p><img class="center" src="http://www.jeromecukier.net/wp-content/uploads/2011/08/d3scale1.png" title="'An example of how scales work'" ></p>

<p>Jerome has <a href="http://www.jeromecukier.net/blog/2011/08/11/d3-scales-and-color/">an excelent blog post</a> covering scales in D3 which inspired me to write my own post. Definitely read his as well! I feel like a great way to learn something is to not only read about it a bunch but to write about it. Hearing different views on the same topic often helps me solidify a concept.</p>

<h3>Class Work Time</h3>

<!-- D3.js -->


<script type='text/javascript'>

var x = d3.scale.linear()
    .domain([0, 100])
    .range([0, 10]);

</script>


<p>I've included <code>d3</code> on the page so you can play around with it. Go ahead, bust open your developer tools or firebug and type <code>d3</code> into the console. It should return an Object full of methods.</p>

<p>Let's do some experiments with our <code>x</code> scale from earlier. Type the following to see what you get.</p>

<p><code>javascript
x(0);
x(25);
x(99);
x(100);
</code></p>

<p>In D3 a scale is both a <code>Function</code> and an <code>Object</code>. You can invoke a scale by using parenthesis: <code>x(100)</code> or you can set a property to change its behavior: <code>x.range([0, 1000])</code>. Let's try that! In the console type:</p>

<p><code>javascript
x.range([0, 1000]);
</code></p>

<p>Our scale's range used to be 0 - 10. Now that we've changed it to 0 - 1000, what do you think <code>x(100)</code> will equal? Keep in mind that 100 is the highest value in our domain. If you're not sure try it in the console. Actually try it in the console regardless of how sure you are! The console is cool as shit!</p>

<h3>To Be Continued...</h3>

<p>Scales are a huge topic so we'll stop here for now. In the next post we'll talk about <code>linear</code>, <code>time</code> and <code>ordinal</code> scales; once you've mastered them everything else becomes a lot easier. Stay tuned :)</p>
]]></content>
  </entry>
  
</feed>
