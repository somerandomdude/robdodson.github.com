<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chain | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/chain/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-05-20T20:00:43-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Some More Backbone.js Basics]]></title>
    <link href="http://robdodson.me/blog/2012/05/20/some-more-backbone-dot-js-basics/"/>
    <updated>2012-05-20T08:19:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/20/some-more-backbone-dot-js-basics</id>
    <content type="html"><![CDATA[<p>Here are some quick Backbone snippets to help visualize concepts. I'll move around fairly quickly so if you're interested in going more in-depth then checkout the documentation.</p>

<h3>Events</h3>

<p>Backbone events are pretty straightforward. To create a pub/sub relationship you use the <code>on</code> and <code>off</code> methods of <code>Backbone.Events</code>:</p>

<p>In the above example you could make <code>dispatcher</code> into an AMD module and load the dependency with Require.js, something <a href="http://robdodson.me/blog/2012/05/18/backbone-boilerplate-playing-with-require-dot-js/">I've covered in a previous post.</a></p>

<p>``` js
var dispatcher = {};
_.extend(dispatcher, Backbone.Events);</p>

<p>var receiver = {</p>

<pre><code>initialize: function() {
    // Start listening for the 'hello' event from the dispatcher.
    // When we hear the 'hello' event we'll run a function
    dispatcher.on('hello', this.sayHello, this);
},
sayHello: function() {
    console.log('hello!');
    // Kill the listener so we only get called once
    dispatcher.off('hello', this.sayHello, this); 
}
</code></pre>

<p>};</p>

<p>receiver.initialize();
dispatcher.trigger('hello');
dispatcher.trigger('hello');
```</p>

<h3>Models</h3>

<p>Backbone models are interesting because they implement explicit <code>get</code> and <code>set</code> methods. When you change a property with the get and set methods it will fire off an event. Here's a fiddle showing how to model a <code>Book</code>. We'll change the author and the DOM will reflect this update.</p>

<iframe style="width: 100%; height: 400px" src="http://jsfiddle.net/robdodson/dC5GD/1/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>If your model implements an <code>initialize</code> function it will be called as soon as the object is created. In other words, its a constructor. If you pass a hash to the model's constructor it will set those attributes on itself. The hash and any additional arguments will also be passed to <code>initialize</code>.</p>

<p>``` js
// Define an initialize function for our book
// Initialize will be called anytime we say new Book()
var Book = Backbone.Model.extend({</p>

<pre><code>initialize: function(foo, bar) {
    console.log(foo);
    console.log(bar);
}
</code></pre>

<p>});</p>

<p>// You can pass in a hash to set initial values on the model
// The hash and any additional arguments will also be passed
// to the initialize function
book = new Book({</p>

<pre><code>author: 'Hunter S. Thompson',
title: 'Fear and Loating in Las Vegas'
</code></pre>

<p>}, 'hello world!');</p>

<p>console.log(book.get('author'));
```</p>

<h4>Poor man's data-binding</h4>

<p>Now that we have a basic understanding of models we can write our own simple binding setup. This example presumes we have an <code>#author</code> and a <code>#title</code> element somewhere on our page.</p>

<p>``` js
var Book = Backbone.Model.extend({});</p>

<p>book = new Book({</p>

<pre><code>author: 'Hunter S. Thompson',
title: 'Fear and Loating in Las Vegas'
</code></pre>

<p>});</p>

<p>// Listen for any change event coming from the model.
// When any attribute changes we'll tell our elements to
// automatically update.
book.on('change', function() {</p>

<pre><code>$('#author').html(book.get('author'));
$('#title').html(book.get('title'));
</code></pre>

<p>});</p>

<p>book.set('author', 'Mickey Mouse');
book.set('title', 'Everyone Poops');
```</p>

<h4>Backbone.sync</h4>

<p>To mess around with saving data we'll need to alter <code>Backbone.sync</code>.</p>

<blockquote><p>Backbone.sync is the function that Backbone calls every time it attempts to read or save a model to the server. By default, it uses (jQuery/Zepto).ajax to make a RESTful JSON request and returns a jqXHR. You can override it in order to use a different persistence strategy, such as WebSockets, XML transport, or Local Storage.</p></blockquote>

<p>Backbone will decide whether a save call should perform a create with <code>HTTP POST</code> or an update <code>HTTP PUT</code> based on whether or not our model has an id attribute already.</p>

<p>Here's an example from the Backbone docs which overrides the sync functionality and fakes a request to a server.</p>

<p>``` js
Backbone.sync = function(method, model) {
  console.log(method + ": " + JSON.stringify(model));
  model.id = 1; // This line is crucial!
};</p>

<p>var book = new Backbone.Model({
  title: "The Rough Riders",
  author: "Theodore Roosevelt"
});</p>

<p>book.save();
// create: {"title":"The Rough Riders","author":"Theodore Roosevelt"}</p>

<p>book.save({author: "Teddy"});
// update: {"title":"The Rough Riders","author":"Teddy"}
<code>``
​If we don't give our model an</code>id` on line 3 then Backbone has no way of knowing if the model has been previously saved or not. It will keep doing create/POST until it receives that id.</p>

<h3>Collections</h3>

<p>If you don't want to setup a server but you do want to play around with saving models and collections you can use <a href="https://github.com/jeromegn/Backbone.localStorage">the Backbone LocalStorage adapter written by Jerome Gravel-Niquet</a>. After you've included the js file in your code somewhere you can use it like so:</p>

<p>``` js
var Book = Backbone.Model.extend({});</p>

<p>var Books = Backbone.Collection.extend({</p>

<pre><code>model: Book,
localStorage: new Backbone.LocalStorage("Books")
</code></pre>

<p>});</p>

<p>var library = new Books();
library.on('sync', function() {</p>

<pre><code>console.log('sync succesful!');
</code></pre>

<p>});</p>

<p>var othello = library.create({
  title: "Othello",
  author: "William Shakespeare"
});
```</p>

<p>To <code>fetch</code> the models in the collection at a later point you can do the following:</p>

<p>``` js
var Book = Backbone.Model.extend({});</p>

<p>var Books = Backbone.Collection.extend({</p>

<pre><code>model: Book,
localStorage: new Backbone.LocalStorage("Books")
</code></pre>

<p>});</p>

<p>var library = new Books();
library.fetch();
console.log(library);
```</p>

<p>The docs mention that you shouldn't use this to initialize your collections. Instead you should <a href="http://documentcloud.github.com/backbone/#FAQ-bootstrap">bootstrap your app</a> at page load. Here's the passage:</p>

<blockquote><p>Note that fetch should not be used to populate collections on page load — all models needed at load time should already be bootstrapped in to place. fetch is intended for lazily-loading models for interfaces that are not needed immediately: for example, documents with collections of notes that may be toggled open and closed.</p></blockquote>

<h3>Routers</h3>

<p>Routers are used to map URLs to actions. If you're using the Backbone Boilerplate you should see this block of code in your main.js.</p>

<p>``` js
// Defining the application router, you can attach sub routers here.
var Router = Backbone.Router.extend({
  routes: {</p>

<pre><code>"": "index",
":hash": "index"
</code></pre>

<p>  },</p>

<p>  index: function(hash) {</p>

<pre><code>var route = this;
var tutorial = new Example.Views.Tutorial();

// Attach the tutorial to the DOM
tutorial.render(function(el) {
  $("#main").html(el);

  // Fix for hashes in pushState and hash fragment
  if (hash &amp;&amp; !route._alreadyTriggered) {
    // Reset to home, pushState support automatically converts hashes
    Backbone.history.navigate("", false);

    // Trigger the default browser behavior
    location.hash = hash;

    // Set an internal flag to stop recursive looping
    route._alreadyTriggered = true;
  }
});
</code></pre>

<p>  }
});
```</p>

<p>One gotcha is that the definition of <code>":hash": "index"</code> will send any route that follows the base domain to the index function. For instance if you did the following:</p>

<p>``` js
routes: {</p>

<pre><code>"": "index",
":hash": "index"
"search": "search"
</code></pre>

<p>  },</p>

<p>  ...</p>

<p>  search: function() {</p>

<pre><code>console.log('time to search!');
</code></pre>

<p>  }
<code>``
Instead of the search function running what will actually happen is mysite.com/search will be converted into mysite.com/#search and the word</code>search<code>will be sent to the index function to supply the</code>hash<code>argument. To fix this you'll need to remove the</code>":hash": "index"` route.</p>

<h3>Views</h3>

<p>Views can either work with existing DOM elements or create new ones. Here's a very basic fiddle in which a BodyView is created to wrap our <code>body</code> tag and BoxView is appended to it. We add a little jQuery animation to show the process in action.</p>

<iframe style="width: 100%; height: 400px" src="http://jsfiddle.net/robdodson/rJEkv/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>You'll often want to link a view's render method up to a model's change event so the two will stay in sync. Here's a quick and dirty example showing how to bind in this fashion.</p>

<p>``` js
var Book = Backbone.Model.extend({});</p>

<p>var BookView = Backbone.View.extend({</p>

<pre><code>className: 'book-view',
initialize: function() {
    this.model.on('change', this.render, this);
    this.render();        
},
render: function() {
    this.$el.html(this.model.get('title') + ' by ' + this.model.get('author'));
}
</code></pre>

<p>});</p>

<p>var outliers = new Book({</p>

<pre><code>author: 'Malcolm Gladwell',
title: 'Outliers'
</code></pre>

<p>});</p>

<p>var bookView = new BookView({model: outliers});</p>

<p>$('body').append(bookView.el);</p>

<p>outliers.set('author', 'Mickey Mouse');
```
Instead of throwing your HTML into the render method as a String it's advised that you use some kind of templating library. Underscore templates seem like a good place to start but Backbone is designed to be template agnostic so you could easily switch to Mustache/Handelbars or HAML if you want. Tomorrow I'll look into displaying some content using an Underscore template linked up to a model. Till then.. :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Chain]]></title>
    <link href="http://robdodson.me/blog/2012/05/19/my-first-chain/"/>
    <updated>2012-05-19T22:53:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/19/my-first-chain</id>
    <content type="html"><![CDATA[<p>Back in April I was reading hacker news when I came across a blog posted titled <a href="http://japhr.blogspot.com/2012/04/366-or-how-i-tricked-myself-into-being.html">'366 or How I Tricked Myself into Being Awesome'</a>. It was written by a fellow named Chris Strom. It was written on blogspot. It was mostly unstyled.</p>

<p>Chris wrote every single day for 366 days and in so doing self-published three books on programming languages that he knew nothing about. His post was to champion that milestone. At the time I read it and thought, "I can totally do this," meaning if I follow the steps that Chris has outlined I can potentially trick myself into becoming a blogger.</p>

<p>That probably seems rather silly to say but it's true. Every developer I know Googles for answers when they're stuck or trying to learn something new. <a href="http://css-tricks.com/">And it seems like</a>, <a href="http://www.alistapart.com/">over and</a> <a href="http://www.leebrimelow.com/">over again</a>, <a href="http://devblog.avdi.org/">we end up</a> <a href="http://yehudakatz.com/">in the same places.</a> And if you're a developer, or maybe if you're just me, you totally revere these people. They are guides in what is a truly unfamiliar world and they do it without asking anything in return.</p>

<p>So I set out to try to do my own chain. I have to write until I go to Europe on June 27th. At this moment I have 22 blog posts that I've written as a result of the chain. Prior to that I'd written 3 in an entire year. At first I found the whole process exhilarating, until it started to get in the way of my personal activities. Now I have to figure out how to write something of substance while still balancing my job and my home life. This is not easy. It requires setting boundaries and self-discipline. I try to write in the mornings, usually between the hours of 7 to 9. Frequently I don't finish and my posts have to be resumed in the evening. But working like this interferes with the time I can spend with my girlfriend and that breaks one of the unspoken rules I have which is that writing should not disturb my normal social life. Getting to the first 10 posts this was not a problem but now that I'm passing 20 it is. I've changed my writing style from full blown tutorials to more of a play-by-play as I code. I'm always striving to be more succinct in what I write but usually the challenge is disappearing down a rabbit hole while I research something new only to realize that I've blown half an hour of my writing time googling minutia. I'm going to try to associate googling minutia with some guy getting in between me and my girlfriend. As a result I will want to stab googling minutia.</p>

<p>Anyway, if you find this post and you are thinking about writing let me tell you that I <strong>highly</strong> recommend it. Here is some quick advice:</p>

<h3>Don't worry about what your blog looks like.</h3>

<p>I'm 100% serious on this point. If you spend any time designing your blog before you write your first 5 articles then you're doing it wrong. I have fallen into this trap innumerable times. Just accept this challenge: Make it to 10 blog posts, then you can redesign the thing.</p>

<p>I think we fall in love with the idea of having a beautiful blog and get lost in design and programming how everything will look. This is a mistake. Blogging is supposed to just be a journal of what you're currently working on and thinking. Assume no one will read it (this is probably true). After you have a few readers then work on the look and feel if you choose. Personally I've found that not worrying about the design at all has been incredibly freeing. Again, look at <a href="http://japhr.blogspot.com/2012/04/366-or-how-i-tricked-myself-into-being.html">Chris Strom's blog</a>. He has a ton of readers, is a published author, and is running the default blogspot theme.</p>

<h3>Try to write at the same time every day</h3>

<p>I find it easiest to focus in the morning especially when everyone else is asleep. I think Chris works late at night. Figure out what times suits you and do your best to stick to it. When I finish a post in the morning I feel free for the whole rest of the day. It's kind of cool to have that sense of accomplishment before arriving at work :D</p>

<h3>Use the best tools you can</h3>

<p>I tried writing in Wordpress on several different occasions. I've also tried Tumblr and Posterous. I find writing in shitty WYSIWYG editors drives me totally crazy. There are apps out there that let you write in more of a desktop setting but I'm not sure if they are still subject to Wordpress or Tumblr's weird formatting. Basically if you're writing a code blog it fucking sucks to use a WYSIWYG because they'll try to wrap all of your funky syntax in weird markup. I found <a href="http://octopress.org/">Octopress</a> and it's been the best tool I've ever used for writing. I also <a href="http://robdodson.me/blog/2012/04/30/custom-domain-with-octopress-and-github-pages/">wrote a little article</a> on it if you're trying to get it setup for your personal domain. Octopress is great because it uses <a href="http://daringfireball.net/projects/markdown/">Markdown</a>, the same language that's used to generate most of the pages on Github, there's no database and you can write in any text editor. I do all of my blogging in <a href="http://www.sublimetext.com/2">Sublime Text 2</a>, often times with my blog in one cell with my code in the other. Here's a screenshot of what this can look like.</p>

<p><img class="center" src="/images/side_by_side_blogging.png" title="'Awesome splits!'" ></p>

<h3>Don't worry when no one reads it</h3>

<p>Finally, don't get too hung up on who is (or isn't) reading your blog. I know that pretty much all of the visits I see in my google analytics are actually just me checking the site on my phone or laptop. Definitely <em>do</em> add analytics so you can see which parts are successful and which are not but don't expect to be <a href="http://daringfireball.net/">Daring Fireball</a> overnight. In fact, don't ever expect to be Daring Fireball. Keep in mind that what you're doing is a personal journal. It may not seem like blogs are framed in that context but that's what they're best at. I often times find this really interesting flow where I write down what I think I should build before I build it, then I write a test, then I write the implementation. Often times I work out what I'm doing in the blog post well before I've even written the test. This is like a whole other kind of BDD, Blog Driven Development :) Use it for what it's best at and you'll find it rewarding.</p>

<p>Ok that's it for now. Goodnight!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone Boilerplate: Playing with Require.js]]></title>
    <link href="http://robdodson.me/blog/2012/05/18/backbone-boilerplate-playing-with-require-dot-js/"/>
    <updated>2012-05-18T08:07:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/18/backbone-boilerplate-playing-with-require-dot-js</id>
    <content type="html"><![CDATA[<p>I want to keep playing with require.js and AMD modules today so I can really internalize the concepts around them. I'm going to go through the examples in <a href="http://requirejs.org/docs/api.html#jsfiles">the require documentation</a> starting with loading regular scripts and then defining modules and loading those. Here's our boilerplate HTML:</p>

<p>Here is our boilerplate HTML. It's a standard HTML5 file which just includes require.js at the bottom of the page.
``` html
&lt;!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1"></p>

<p>  <title>Require.js Sandbox</title></p>

<p>  <!-- Application styles -->
  <link rel="stylesheet" href="http://robdodson.me/assets/css/index.css">
</head></p>

<p><body>
  <!-- Main container -->
  <div role="main" id="main"></div></p>

<p>  <!-- Application source -->
  <script src="http://robdodson.me/assets/js/libs/require.js"></script>
</body>
</html>
```
I'm also going to define a file called foo.js which will just console log "Hello World!". To update our HTML we'll add the following script tag after the call to include require.js</p>

<p>``` html</p>

<script>
    require(["foo"]);
</script>


<p>```</p>

<p>And as expected the console outputs 'Hello World!'. Let's step it up a notch and define a module. Our first module will just return an object literal <a href="http://requirejs.org/docs/api.html#defsimple">like in this example.</a> It will be a <code>Person</code> module with our name and city. We'll place it in an <code>app</code> folder in the root of our project. So our stucture looks like this:</p>

<p>```
index.html
|
|<em> app/
  |
  |</em> person.js
|
|<em> assets/
  |
  |</em> js/</p>

<pre><code>|
|_ libs/
  |
  |_ require.js
</code></pre>

<p>```</p>

<p>The <code>Person</code> module just needs to implement a define function which takes an object as an argument. It looks like this:
``` js app/person.js
define({</p>

<pre><code>name: "Rob Dodson",
city: "San Francisco"
</code></pre>

<p>});
```
And in our updated index.html we're going to require that module.</p>

<p>``` html
&lt;!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1"></p>

<p>  <title>Require.js Sandbox</title></p>

<p>  <!-- Application styles -->
  <link rel="stylesheet" href="http://robdodson.me/assets/css/index.css">
</head></p>

<p><body>
  <!-- Main container -->
  <div role="main" id="main"></div></p>

<p>  <!-- Application source -->
  <script src="http://robdodson.me/assets/js/libs/require.js"></script>
  <script></p>

<pre><code>require(["app/person"], function(person) {
  console.log(person.name);
  console.log(person.city);
});
</code></pre>

<p>  </script>
</body>
</html>
```</p>

<p>Opening up that page in the browser should give us the proper output in the console.</p>

<h3>AMD modules for dummies</h3>

<p>Let's stop here for a moment to understand what's going on. In one file we implemented a <code>define</code> function and in another place we implemented a <code>require</code> function. In the most basic sense this is all we really need to do to start using AMD. I think the concept of javascript modules is really weird for most folks but if you're coming from a language like Java or Flash just think of define and require as two different interfaces that have to be implemented in order to recreate the <code>import</code> functionality that you're used to. Require.js is going to make sure everything loads properly so long as we stick to this convention.</p>

<p>If you're coming from more of a design background and you're used to having one big javascript file think of these modules as a way to break off pieces of code which you might otherwise put into separate script files. And I'm not talking one or two script files, I'm talking like 20 or 30. You could try to manage loading all of those dependencies yourself but that will be challenging. If you are building a blog then this probably isn't a big deal for you. In that case a few included js files is fine. But if you're trying to build a responsive web app for mobile then you're going to want to only load the bits of code you absolutely need. If a page doesn't require 90% of your JS then don't waste the time downloading it over a shitty AT&amp;T connection.</p>

<p>Ok let's write a module that's a bit more realistic. We'll use a function to return our object so it's kind of like a constructor.</p>

<p>``` js app/monster.js
"use strict";</p>

<p>define(function () {</p>

<pre><code>var estimated_age = 99 + 1;
var spookySaying = 'I vant to suck your blooood!';

return {
    name: 'Dracula',
    home: 'Florida',
    age: estimated_age,
    saySomethingSpooky: function() {
      console.log(spookySaying);
    }
};
</code></pre>

<p>});
<code>``
This is a simple monster object. Notice that we build a variable called</code>estimated_age<code>right before defining our object literal. We then return this variable. If we ask for the monster's age it will return this value. It's worth noting that this makes the</code>estimated_age<code>variable private since it only lives in the scope of the anonymous function returning our object literal. We've also got a method,</code>saySomethingSpooky<code>which will print out another private variable</code>spookySaying`. Wow it's <em>almost</em> the JavaScript classes I've always dreamed of! Before you go thinking that remember that modules are not instanceable, meaning, when you load in a module it works like a <a href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton</a> almost. You can't go monster.new() all over the place.. it just doesn't work that way. Don't get disouraged though, this is still pretty cool so let's continue...</p>

<p>Next up is a module with dependencies. We'll make the monster depend on his coffin.</p>

<p>``` js app/coffin.js
"use strict";</p>

<p>define(function () {
  var color = 'Blackest black';</p>

<p>  return {</p>

<pre><code>color: color,
open: function() {
  console.log('*creeeeeek*');
}
</code></pre>

<p>  };
});
```</p>

<p>``` js app/monster.js
"use strict";</p>

<p>define(['./coffin'], function (coffin) {
  var estimated_age = 99 + 1;
  var spookySaying = 'I vant to suck your blooood!';</p>

<p>  return {</p>

<pre><code>name: 'Dracula',
home: 'Florida',
age: estimated_age,
saySomethingSpooky: function() {
  console.log(spookySaying);
},
goToSleep: function() {
  console.log('Time for bed!');
  coffin.open();
}
</code></pre>

<p>  };
});
```</p>

<p>``` html index.html</p>

<script data-main="" src="http://robdodson.me/assets/js/libs/require.js"></script>


<script>
  require(['app/monster'], function(monster) {
    monster.saySomethingSpooky();
    monster.goToSleep();
  });
</script>


<p><code>``
You can see that we've created a dependency for our monster, it has to load the coffin module before it's ready to be loaded itself. Otherwise it won't be able to run</code>goToSleep()<code>properly. Require.js will sort all of this out so long as we declare our dependencies as the first argument to the</code>define` function.</p>

<p>We aren't limited to objects though, we can also return functions (which are objects in their own right). For instance if we wanted to define a helper module that greets people we could do something like this:
``` js app/greet.js
"use strict";</p>

<p>define(function () {
  return function(name) {</p>

<pre><code>return 'Why hello, ' + name;
</code></pre>

<p>  }
});
<code>``
then in our index we'll just use the</code>greet` function as if it were globally available.</p>

<p><code>js index.html
require(['app/greet'], function(greet) {
  console.log(greet('Rob'));
});
</code>  <br/>
bear in mind that each module requires an http request to load it so you don't want to go overboard defining helper function modules. Note the extra http request in the profiler which loads greet.js.
<img class="center" src="/images/module_costs.png" title="'Note the separate http request for greet.js'" ></p>

<p>Ok that's it for today. I'll try to continue on Saturday!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Familiar with Backbone Boilerplate]]></title>
    <link href="http://robdodson.me/blog/2012/05/17/getting-familiar-with-backbone-boilerplate/"/>
    <updated>2012-05-17T07:47:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/17/getting-familiar-with-backbone-boilerplate</id>
    <content type="html"><![CDATA[<p>I have an upcoming project which uses <a href="http://documentcloud.github.com/backbone/">Backbone</a> and <a href="http://nodejs.org/">Node.js</a> so I thought it would be good to blog about the topics (particularly Backbone) for a while to make sure I'm well up to speed.</p>

<p>We're using the <a href="https://github.com/tbranyen/backbone-boilerplate">Backbone Boilerplate</a> to get us started since it includes a bit of file structure and a build process. As they mention in the docs you have to install <a href="https://github.com/cowboy/grunt">Grunt</a> if you want to use the build process they've stubbed out. Grunt is a javascript build tool which uses Node (think Rake in JS).</p>

<p>As a refresher course I'm going to dig into the open-source <a href="http://addyosmani.github.com/backbone-fundamentals/">Backbone Fundamentals book</a> by <a href="http://addyosmani.github.com/backbone-fundamentals/">Addy Osmani</a>.</p>

<p>First thing's first though, after we have nodejs and grunt installed we need to also install the bbb (backbone boilerplate build, I guess?) tool. You can <a href="https://github.com/backbone-boilerplate/grunt-bbb">grab it here.</a></p>

<p>We'll create a new folder for our project and run <code>bbb init</code>. If all goes well it should stub out some project directories and files for us.</p>

<h3>The Backbone Boilerplate templates</h3>

<p>I'll start with the index.html file. It seems like your standard HTML5 doc with the noteable exception that it includes <a href="http://requirejs.org/">require.js</a> at the bottom of the page.</p>

<p>```html
&lt;!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1"></p>

<p>  <title>Backbone Boilerplate</title></p>

<p>  <!-- Application styles -->
  <link rel="stylesheet" href="http://robdodson.me/assets/css/index.css">
</head></p>

<p><body>
  <!-- Main container -->
  <div role="main" id="main"></div></p>

<p>  <!-- Application source -->
  <script data-main="app/config" src="http://robdodson.me/assets/js/libs/require.js"></script>
</body>
</html>
```
Require.js is a module and file loader which will help us manage our AMD modules. AMD (which stands for Asynchronous Module Definition) is a specification which details how to break JS down into modules that are loaded in, as needed, at runtime. <a href="http://addyosmani.com/writing-modular-js/">Again we turn to Addy Osmani for a good explanation.</a></p>

<p>If you notice this block:
```html</p>

<!-- Application source -->


<p>  <script data-main="app/config" src="http://robdodson.me/assets/js/libs/require.js"></script>
<code>``
the</code>data-main<code>attribute in the script tag is telling require.js what to load first. In this case it's the</code>app/config.js<code>file. If you omit the</code>js<code>require will add it for you. If you add the</code>.js` require will respect the path exactly as it was given. This distinction seems kind of trivial here but later on when you start configuring require with baseUrls and whatnot, it becomes more important.</p>

<p>Let's look at that confg file, shall we?</p>

<p>```javascript app/config.js
// Set the require.js configuration for your application.
require.config({
  // Initialize the application with the main application file
  deps: ["main"],</p>

<p>  paths: {</p>

<pre><code>// JavaScript folders
libs: "../assets/js/libs",
plugins: "../assets/js/plugins",

// Libraries
jquery: "../assets/js/libs/jquery",
underscore: "../assets/js/libs/underscore",
backbone: "../assets/js/libs/backbone",

// Shim Plugin
use: "../assets/js/plugins/use"
</code></pre>

<p>  },</p>

<p>  use: {</p>

<pre><code>backbone: {
  deps: ["use!underscore", "jquery"],
  attach: "Backbone"
},

underscore: {
  attach: "_"
}
</code></pre>

<p>  }
});
```</p>

<p>One of the first things you can do with Require is to pass it a configuration object. The config object <a href="http://requirejs.org/docs/api.html#config">can be used for a ton of bootstrap options</a> like setting paths, requiring other scripts, setting timeouts, etc. The first option we see here is <code>deps: ["main"]</code>. We can infer this is telling require to load our main.js file first. But how does it get the path to main.js? From the docs we see that since we haven't defined a <code>baseUrl</code> property require is using the path from our <code>data-main</code> attribute.</p>

<blockquote><p>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a data-main attribute is used, that path will become the baseUrl.</p></blockquote>

<p>So we know that our baseUrl is <code>app/</code> and anything we require will be relative to that.</p>

<p>Next up we have this block:</p>

<p>```js
paths: {</p>

<pre><code>// JavaScript folders
libs: "../assets/js/libs",
plugins: "../assets/js/plugins",

// Libraries
jquery: "../assets/js/libs/jquery",
underscore: "../assets/js/libs/underscore",
backbone: "../assets/js/libs/backbone",

// Shim Plugin
use: "../assets/js/plugins/use"
</code></pre>

<p>  },
```</p>

<p>The paths property defines paths relative to <code>baseUrl</code>. If we say
<code>js
require(["libs/module"])
</code>
require.js will look for this <code>libs</code> path and find it in our config file. Most of these make sense till we hit the last line which creates a path for the <code>use</code> plugin.</p>

<p><a href="http://tbranyen.com/post/amdrequirejs-shim-plugin-for-loading-incompatible-javascript">It seems like <code>use</code> was created by Tim Branyen, the author of the Backbone Boilerplate, to help with loading libraries that are non-AMD compliant.</a> Most of the big libraries are currently not AMD compliant (underscore and backbone itself) so this makes sense. So instead of creating a shim for each of those libraries the <code>use</code> plugin <em>should</em> take care of things for us. We can see how it's used further in the config file:</p>

<p>```js
use: {</p>

<pre><code>backbone: {
  deps: ["use!underscore", "jquery"],
  attach: "Backbone"
},

underscore: {
  attach: "_"
}
</code></pre>

<p>  }
```</p>

<p>Let's start at the bottom so we can see that underscore is defined and mapped to "_". <code>attach</code> is going to take whatever library we're defining and attach it to <code>window</code>. So underscore will be attached as <code>window._</code>. Next we see that backbone is defined and depends on our version of underscore and jquery. Since jquery is AMD compliant we don't need the call to <code>use!</code> but we will need it for underscore. Finally backbone is attached to the window as <code>window.Backbone</code>.</p>

<p>That covers the configuration file. I'll move on to main.js in the next post.</p>

<ul>
<li>Time: 7:49 am</li>
<li>Mood: Awake, Tired, Lazy</li>
<li>Sleep: 7</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 8]]></title>
    <link href="http://robdodson.me/blog/2012/05/16/object-oriented-scraper-backed-with-tests-pt-8/"/>
    <updated>2012-05-16T07:42:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/16/object-oriented-scraper-backed-with-tests-pt-8</id>
    <content type="html"><![CDATA[<p>Yesterday's I refactored my specs and crawler to support ignoring selections. While I started parsing the metadata I quickly realized that certain bits were rather specific and needed to have custom parsing methods. Today I'm going to write some format objects to help with all that.</p>

<p>Our metadata on the page looks like this:</p>

<p><code>
Time: 7:42 am
Mood: Awake, Alert, Focused
Sleep: 6
Hunger: 0
Coffee: 0
</code></p>

<p>Sleep, hunger and coffee are all floats, so one object could be just <code>FloatFormat</code>. Mood should produce an <code>Array</code> of objects so we could have a <code>CollectionFormat</code>. Finally time is going to combine the time listed in the metadata and the post date. We'll make a <code>DateTimeFormat</code> for that. These could all be methods of one big Format object as well but experience tells me that you need to be careful of monolithic actors that consume tons of different data types and spit out results. Those classes have a tendency to bloat very easily as project requirements change. I think it's better to produce classes which can be extended or abstracted as needs arise.</p>

<p>So we know <em>who</em> is going to format but we still don't know <em>how</em>. I think I'd like to build a manifest which matches the metadata category to a format. Maybe something like this?</p>

<p><code>ruby
{
  'Time'    =&gt; DateTimeFormat,
  'Mood'    =&gt; CollectionFormat,
  'Sleep'   =&gt; FloatFormat,
  'Hunger'  =&gt; FloatFormat,
  'Coffee'  =&gt; FloatFormat
}
</code></p>

<p>I could probably look at each item and "detect" what kind of format it needs but I'd rather be explicit. If, for instance, I want to add another format, it's a lot easier to just change my manifest file vs. hacking on some detection scheme. I think we can just produce this manifest file in YAML and load it in at runtime. One thing I don't like about this approach is that it specifically names our format classes. You could generalize it so that it just matches a category to the desired output data, for instance <code>'Coffee' =&gt; Float</code> but then you run into problems with flexibility. What if Coffee still needed to output a float but had to go through a different Format than Hunger or Sleep? With that in mind we'll stick to the plan already laid out.</p>

<p><code>yaml tentacles/lib/tentacles/formats.yml
time:     DateTimeFormat
mood:     CollectionFormat
sleep:    FloatFormat
hunger:   FloatFormat
coffee:   FloatFormat
</code></p>

<h3>The Format object</h3>

<p>I would love it if I could use the Format object as a module and just call a method on it from Crawler. It might look like this:</p>

<p>```ruby
def metadata_by_selector(selector)
  node = nodes_by_selector(selector).first
  metadata = {}
  node.children.each do |child|</p>

<pre><code>Tentacles::Format.insert(child, metadata)         
</code></pre>

<p>  end    <br/>
end
<code>``
The only problem is</code>Format` needs to load in and parse its formats.yml file before it's any good to us. There's some interesting talk of the <a href="http://www.subelsky.com/2008/05/using-rubys-autoload-method-to.html">Module#autoload method</a> but that's not quite what I need...</p>

<p>Seems like I can't find any good documentation on this so instead we'll make it an instance of the class. Also I'm lazy so I'm going to have that instance load its own formats.yml file. Normally I like to only have one entry point for configuration files but...whatever.</p>

<h3>How do I convert a string into a class name in Ruby?</h3>

<p>Well we know we can load our YAML file but all of our format classes are going to come in as strings. I did some digging to figure out how to convert the string into an actual class that can then be instantiated. If you just want to convert a String into a class you can use <code>Object.const_get('Foobar').new</code> but that's not going to work for us since our code is wrapped in a module. To convert a string into a module class we'll need to use the name of our module: <code>Tentacles.const_get('DateTimeFormat').new</code>.</p>

<p>With that in mind I want to spec out a simple test that passes in string of metadata and receives a printed notification that the right formatter has been created. We'll then refactor it to actually use the formatter on the string.</p>

<p>```ruby tentacles/spec/format_spec.rb
require_relative '../lib/tentacles/format'
require_relative '../lib/tentacles/date_time_format'</p>

<p>describe Tentacles::Format do
  describe "when asked to parse some metadata" do</p>

<pre><code>it "should create the right formatter" do
  @format = Tentacles::Format.new
  @format.parse('Time: 8:03 am').should be_an_instance_of(Tentacles::DateTimeFormat)
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby tentacles/lib/format.rb
require 'yaml'
require_relative 'date_time_format'</p>

<p>module Tentacles
  class Format</p>

<pre><code>def initialize
  @categories = YAML.load(File.open(File.dirname(__FILE__) + '/formats.yml'))
end

def parse(data)
  category = data.split(':')[0]
  category.downcase!
  Tentacles.const_get(@categories[category]).new
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby tentacles/lib/date_time_format.rb
module Tentacles
  class DateTimeFormat</p>

<pre><code>def initialize
  puts 'DateTimeFormat created!'
end
</code></pre>

<p>  end
end
```</p>

<p>Now let's take it a step further so we can convert an actual time into a DateTime object. Here's our updated spec:</p>

<p>```ruby
require_relative '../lib/tentacles/format'
require 'date'</p>

<p>describe Tentacles::Format do
  describe "when asked to parse some metadata" do</p>

<pre><code>it "should create the right formatter" do
  @format = Tentacles::Format.new
  @format.parse('Time: 8:03 am').should be_an_instance_of(Date)
end
</code></pre>

<p>  end
end
```</p>

<p>To pull this off we'll need the help of at least 2 new gems: <a href="http://rubygems.org/gems/chronic">Chronic</a> and <a href="http://rubygems.org/gems/activesupport">ActiveSupport</a>. Chronic is a natural language parser which can convert strings into useable timestamps. ActiveSupport is a library of extensions originally created for Rails which have been abstracted into a general purpose toolset. We're going to combine these two gems to turn the phrase "8:03 am" into a Ruby DateTime.</p>

<p>Gotta first update the Gemfile with our new dependencies and run <code>bundle install</code>.</p>

<p>```ruby
source 'https://rubygems.org'</p>

<p>gem 'rspec', '2.9.0'
gem 'nokogiri', '~>1.5.2'
gem 'awesome_print', '~>1.0.2'
gem 'fakeweb', '~>1.3.0'
gem 'chronic', '~> 0.6.7'
gem 'activesupport', '~> 3.2.3'
```</p>

<p>Next we bang out a quick parse method inside of DateTimeFormat. Our Tentacles::Format is going to delegate its parse call to whichever subordinate formatter it creates. Code speaks louder than words:</p>

<p>```ruby tentacles/lib/tentacles/format.rb
require 'yaml'
require_relative 'date_time_format'</p>

<p>module Tentacles
  class Format</p>

<pre><code>def initialize
  @categories = YAML.load(File.open(File.dirname(__FILE__) + '/formats.yml'))
end

# Create a formatter based on the content of the passed
# in data. Delegate the parse call to this new formatter
def parse(data)
  category, *content = data.split(':')
  category.downcase!
  formatter = Tentacles.const_get(@categories[category]).new
  formatter.parse(content)
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby tentacles/lib/tentacles/date_time_format.rb
require 'chronic'
require 'active_support/core_ext/string/conversions.rb'</p>

<p>module Tentacles
  class DateTimeFormat</p>

<pre><code>def initialize
  puts 'DateTimeFormat created!'
end

def parse(content)
  Chronic.parse(content.join(':')).to_datetime
end
</code></pre>

<p>  end
end
```</p>

<p>With all that in place our test should pass. Nice!!!!!! We're well on our way to processing the remaining metadata. Tomorrow I'll whip up our other formats and figure out how to pull the date out of a blog post so we can combine that with the time to get a proper DateTime.</p>

<ul>
<li>Time: 7:42 am</li>
<li>Mood: Awake, Alert, Focused</li>
<li>Sleep: 6</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
</feed>
