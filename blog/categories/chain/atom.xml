<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chain | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/chain/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-05-17T09:17:55-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Getting Familiar with Backbone Boilerplate]]></title>
    <link href="http://robdodson.me/blog/2012/05/17/getting-familiar-with-backbone-boilerplate/"/>
    <updated>2012-05-17T07:47:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/17/getting-familiar-with-backbone-boilerplate</id>
    <content type="html"><![CDATA[<p>I have an upcoming project which uses <a href="http://documentcloud.github.com/backbone/">Backbone</a> and <a href="http://nodejs.org/">Node.js</a> so I thought it would be good to blog about the topics (particularly Backbone) for a while to make sure I'm well up to speed.</p>

<p>We're using the <a href="https://github.com/tbranyen/backbone-boilerplate">Backbone Boilerplate</a> to get us started since it includes a bit of file structure and a build process. As they mention in the docs you have to install <a href="https://github.com/cowboy/grunt">Grunt</a> if you want to use the build process they've stubbed out. Grunt is a javascript build tool which uses Node (think Rake in JS).</p>

<p>As a refresher course I'm going to dig into the open-source <a href="http://addyosmani.github.com/backbone-fundamentals/">Backbone Fundamentals book</a> by <a href="http://addyosmani.github.com/backbone-fundamentals/">Addy Osmani</a>.</p>

<p>First thing's first though, after we have nodejs and grunt installed we need to also install the bbb (backbone boilerplate build, I guess?) tool. You can <a href="https://github.com/backbone-boilerplate/grunt-bbb">grab it here.</a></p>

<p>We'll create a new folder for our project and run <code>bbb init</code>. If all goes well it should stub out some project directories and files for us.</p>

<h3>The Backbone Boilerplate templates</h3>

<p>I'll start with the index.html file. It seems like your standard HTML5 doc with the noteable exception that it includes <a href="http://requirejs.org/">require.js</a> at the bottom of the page.</p>

<p>```html
&lt;!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1"></p>

<p>  <title>Backbone Boilerplate</title></p>

<p>  <!-- Application styles -->
  <link rel="stylesheet" href="http://robdodson.me/assets/css/index.css">
</head></p>

<p><body>
  <!-- Main container -->
  <div role="main" id="main"></div></p>

<p>  <!-- Application source -->
  <script data-main="app/config" src="http://robdodson.me/assets/js/libs/require.js"></script>
</body>
</html>
```
Require.js is a module and file loader which will help us manage our AMD modules. AMD (which stands for Asynchronous Module Definition) is a specification which details how to break JS down into modules that are loaded in, as needed, at runtime. <a href="http://addyosmani.com/writing-modular-js/">Again we turn to Addy Osmani for a good explanation.</a></p>

<p>If you notice this block:
```html</p>

<!-- Application source -->


<p>  <script data-main="app/config" src="http://robdodson.me/assets/js/libs/require.js"></script>
<code>``
the</code>data-main<code>attribute in the script tag is telling require.js what to load first. In this case it's the</code>app/config.js<code>file. If you omit the</code>js<code>require will add it for you. If you add the</code>.js` require will respect the path exactly as it was given. This distinction seems kind of trivial here but later on when you start configuring require with baseUrls and whatnot, it becomes more important.</p>

<p>Let's look at that confg file, shall we?</p>

<p>```javascript app/config.js
// Set the require.js configuration for your application.
require.config({
  // Initialize the application with the main application file
  deps: ["main"],</p>

<p>  paths: {</p>

<pre><code>// JavaScript folders
libs: "../assets/js/libs",
plugins: "../assets/js/plugins",

// Libraries
jquery: "../assets/js/libs/jquery",
underscore: "../assets/js/libs/underscore",
backbone: "../assets/js/libs/backbone",

// Shim Plugin
use: "../assets/js/plugins/use"
</code></pre>

<p>  },</p>

<p>  use: {</p>

<pre><code>backbone: {
  deps: ["use!underscore", "jquery"],
  attach: "Backbone"
},

underscore: {
  attach: "_"
}
</code></pre>

<p>  }
});
```</p>

<p>One of the first things you can do with Require is to pass it a configuration object. The config object <a href="http://requirejs.org/docs/api.html#config">can be used for a ton of bootstrap options</a> like setting paths, requiring other scripts, setting timeouts, etc. The first option we see here is <code>deps: ["main"]</code>. We can infer this is telling require to load our main.js file first. But how does it get the path to main.js? From the docs we see that since we haven't defined a <code>baseUrl</code> property require is using the path from our <code>data-main</code> attribute.</p>

<blockquote><p>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a data-main attribute is used, that path will become the baseUrl.</p></blockquote>

<p>So we know that our baseUrl is <code>app/</code> and anything we require will be relative to that.</p>

<p>Next up we have this block:</p>

<p>```js
paths: {</p>

<pre><code>// JavaScript folders
libs: "../assets/js/libs",
plugins: "../assets/js/plugins",

// Libraries
jquery: "../assets/js/libs/jquery",
underscore: "../assets/js/libs/underscore",
backbone: "../assets/js/libs/backbone",

// Shim Plugin
use: "../assets/js/plugins/use"
</code></pre>

<p>  },
```</p>

<p>The paths property defines paths relative to <code>baseUrl</code>. If we say
<code>js
require(["libs/module"])
</code>
require.js will look for this <code>libs</code> path and find it in our config file. Most of these make sense till we hit the last line which creates a path for the <code>use</code> plugin.</p>

<p><a href="http://tbranyen.com/post/amdrequirejs-shim-plugin-for-loading-incompatible-javascript">It seems like <code>use</code> was created by Tim Branyen, the author of the Backbone Boilerplate, to help with loading libraries that are non-AMD compliant.</a> Most of the big libraries are currently not AMD compliant (underscore and backbone itself) so this makes sense. So instead of creating a shim for each of those libraries the <code>use</code> plugin <em>should</em> take care of things for us. We can see how it's used further in the config file:</p>

<p>```js
use: {</p>

<pre><code>backbone: {
  deps: ["use!underscore", "jquery"],
  attach: "Backbone"
},

underscore: {
  attach: "_"
}
</code></pre>

<p>  }
```</p>

<p>Let's start at the bottom so we can see that underscore is defined and mapped to "_". <code>attach</code> is going to take whatever library we're defining and attach it to <code>window</code>. So underscore will be attached as <code>window._</code>. Next we see that backbone is defined and depends on our version of underscore and jquery. Since jquery is AMD compliant we don't need the call to <code>use!</code> but we will need it for underscore. Finally backbone is attached to the window as <code>window.Backbone</code>.</p>

<p>That covers the configuration file. I'll move on to main.js in the next post.</p>

<ul>
<li>Time: 7:49 am</li>
<li>Mood: Awake, Tired, Lazy</li>
<li>Sleep: 7</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 8]]></title>
    <link href="http://robdodson.me/blog/2012/05/16/object-oriented-scraper-backed-with-tests-pt-8/"/>
    <updated>2012-05-16T07:42:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/16/object-oriented-scraper-backed-with-tests-pt-8</id>
    <content type="html"><![CDATA[<p>Yesterday's I refactored my specs and crawler to support ignoring selections. While I started parsing the metadata I quickly realized that certain bits were rather specific and needed to have custom parsing methods. Today I'm going to write some format objects to help with all that.</p>

<p>Our metadata on the page looks like this:</p>

<p><code>
Time: 7:42 am
Mood: Awake, Alert, Focused
Sleep: 6
Hunger: 0
Coffee: 0
</code></p>

<p>Sleep, hunger and coffee are all floats, so one object could be just <code>FloatFormat</code>. Mood should produce an <code>Array</code> of objects so we could have a <code>CollectionFormat</code>. Finally time is going to combine the time listed in the metadata and the post date. We'll make a <code>DateTimeFormat</code> for that. These could all be methods of one big Format object as well but experience tells me that you need to be careful of monolithic actors that consume tons of different data types and spit out results. Those classes have a tendency to bloat very easily as project requirements change. I think it's better to produce classes which can be extended or abstracted as needs arise.</p>

<p>So we know <em>who</em> is going to format but we still don't know <em>how</em>. I think I'd like to build a manifest which matches the metadata category to a format. Maybe something like this?</p>

<p><code>ruby
{
  'Time'    =&gt; DateTimeFormat,
  'Mood'    =&gt; CollectionFormat,
  'Sleep'   =&gt; FloatFormat,
  'Hunger'  =&gt; FloatFormat,
  'Coffee'  =&gt; FloatFormat
}
</code></p>

<p>I could probably look at each item and "detect" what kind of format it needs but I'd rather be explicit. If, for instance, I want to add another format, it's a lot easier to just change my manifest file vs. hacking on some detection scheme. I think we can just produce this manifest file in YAML and load it in at runtime. One thing I don't like about this approach is that it specifically names our format classes. You could generalize it so that it just matches a category to the desired output data, for instance <code>'Coffee' =&gt; Float</code> but then you run into problems with flexibility. What if Coffee still needed to output a float but had to go through a different Format than Hunger or Sleep? With that in mind we'll stick to the plan already laid out.</p>

<p><code>yaml tentacles/lib/tentacles/formats.yml
time:     DateTimeFormat
mood:     CollectionFormat
sleep:    FloatFormat
hunger:   FloatFormat
coffee:   FloatFormat
</code></p>

<h3>The Format object</h3>

<p>I would love it if I could use the Format object as a module and just call a method on it from Crawler. It might look like this:</p>

<p>```ruby
def metadata_by_selector(selector)
  node = nodes_by_selector(selector).first
  metadata = {}
  node.children.each do |child|</p>

<pre><code>Tentacles::Format.insert(child, metadata)         
</code></pre>

<p>  end    <br/>
end
<code>``
The only problem is</code>Format` needs to load in and parse its formats.yml file before it's any good to us. There's some interesting talk of the <a href="http://www.subelsky.com/2008/05/using-rubys-autoload-method-to.html">Module#autoload method</a> but that's not quite what I need...</p>

<p>Seems like I can't find any good documentation on this so instead we'll make it an instance of the class. Also I'm lazy so I'm going to have that instance load its own formats.yml file. Normally I like to only have one entry point for configuration files but...whatever.</p>

<h3>How do I convert a string into a class name in Ruby?</h3>

<p>Well we know we can load our YAML file but all of our format classes are going to come in as strings. I did some digging to figure out how to convert the string into an actual class that can then be instantiated. If you just want to convert a String into a class you can use <code>Object.const_get('Foobar').new</code> but that's not going to work for us since our code is wrapped in a module. To convert a string into a module class we'll need to use the name of our module: <code>Tentacles.const_get('DateTimeFormat').new</code>.</p>

<p>With that in mind I want to spec out a simple test that passes in string of metadata and receives a printed notification that the right formatter has been created. We'll then refactor it to actually use the formatter on the string.</p>

<p>```ruby tentacles/spec/format_spec.rb
require_relative '../lib/tentacles/format'
require_relative '../lib/tentacles/date_time_format'</p>

<p>describe Tentacles::Format do
  describe "when asked to parse some metadata" do</p>

<pre><code>it "should create the right formatter" do
  @format = Tentacles::Format.new
  @format.parse('Time: 8:03 am').should be_an_instance_of(Tentacles::DateTimeFormat)
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby tentacles/lib/format.rb
require 'yaml'
require_relative 'date_time_format'</p>

<p>module Tentacles
  class Format</p>

<pre><code>def initialize
  @categories = YAML.load(File.open(File.dirname(__FILE__) + '/formats.yml'))
end

def parse(data)
  category = data.split(':')[0]
  category.downcase!
  Tentacles.const_get(@categories[category]).new
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby tentacles/lib/date_time_format.rb
module Tentacles
  class DateTimeFormat</p>

<pre><code>def initialize
  puts 'DateTimeFormat created!'
end
</code></pre>

<p>  end
end
```</p>

<p>Now let's take it a step further so we can convert an actual time into a DateTime object. Here's our updated spec:</p>

<p>```ruby
require_relative '../lib/tentacles/format'
require 'date'</p>

<p>describe Tentacles::Format do
  describe "when asked to parse some metadata" do</p>

<pre><code>it "should create the right formatter" do
  @format = Tentacles::Format.new
  @format.parse('Time: 8:03 am').should be_an_instance_of(Date)
end
</code></pre>

<p>  end
end
```</p>

<p>To pull this off we'll need the help of at least 2 new gems: <a href="http://rubygems.org/gems/chronic">Chronic</a> and <a href="http://rubygems.org/gems/activesupport">ActiveSupport</a>. Chronic is a natural language parser which can convert strings into useable timestamps. ActiveSupport is a library of extensions originally created for Rails which have been abstracted into a general purpose toolset. We're going to combine these two gems to turn the phrase "8:03 am" into a Ruby DateTime.</p>

<p>Gotta first update the Gemfile with our new dependencies and run <code>bundle install</code>.</p>

<p>```ruby
source 'https://rubygems.org'</p>

<p>gem 'rspec', '2.9.0'
gem 'nokogiri', '~>1.5.2'
gem 'awesome_print', '~>1.0.2'
gem 'fakeweb', '~>1.3.0'
gem 'chronic', '~> 0.6.7'
gem 'activesupport', '~> 3.2.3'
```</p>

<p>Next we bang out a quick parse method inside of DateTimeFormat. Our Tentacles::Format is going to delegate its parse call to whichever subordinate formatter it creates. Code speaks louder than words:</p>

<p>```ruby tentacles/lib/tentacles/format.rb
require 'yaml'
require_relative 'date_time_format'</p>

<p>module Tentacles
  class Format</p>

<pre><code>def initialize
  @categories = YAML.load(File.open(File.dirname(__FILE__) + '/formats.yml'))
end

# Create a formatter based on the content of the passed
# in data. Delegate the parse call to this new formatter
def parse(data)
  category, *content = data.split(':')
  category.downcase!
  formatter = Tentacles.const_get(@categories[category]).new
  formatter.parse(content)
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby tentacles/lib/tentacles/date_time_format.rb
require 'chronic'
require 'active_support/core_ext/string/conversions.rb'</p>

<p>module Tentacles
  class DateTimeFormat</p>

<pre><code>def initialize
  puts 'DateTimeFormat created!'
end

def parse(content)
  Chronic.parse(content.join(':')).to_datetime
end
</code></pre>

<p>  end
end
```</p>

<p>With all that in place our test should pass. Nice!!!!!! We're well on our way to processing the remaining metadata. Tomorrow I'll whip up our other formats and figure out how to pull the date out of a blog post so we can combine that with the time to get a proper DateTime.</p>

<ul>
<li>Time: 7:42 am</li>
<li>Mood: Awake, Alert, Focused</li>
<li>Sleep: 6</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 7]]></title>
    <link href="http://robdodson.me/blog/2012/05/15/object-oriented-scraper-backed-with-tests-pt-7/"/>
    <updated>2012-05-15T21:33:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/15/object-oriented-scraper-backed-with-tests-pt-7</id>
    <content type="html"><![CDATA[<p>During my last post I realized that including my metadata in the blog post as only a ul meant that all the words were being scraped as part of the keyword frequency search. After thinking about it for a while I think I'm going to give the keyword search method an optional value which it can use to ignore or delete certain nodes.</p>

<p>Thankfully I have my tests in place to validate what our final output should look like. Which means I'm basically hacking away at Nokogiri to get things to pass. Here's what I finally settle on:</p>

<p>```ruby
def words_by_selector(selector, ignored_selector = nil)
  node = nodes_by_selector(selector).first
  if ignored_selector</p>

<pre><code>ignored = node.css(ignored_selector)
ignored.remove()
</code></pre>

<p>  end
  words = words_from_string(node.content)
  count_frequency(words)</p>

<p>  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map { |word, count| "#{word}: #{count}"}
end
```</p>

<p>I think the code is pretty self explanatory. Moving on to the metadata we expect a Hash that looks like this:</p>

<p><code>
{
  datetime: 2012-05-13T08:03:00-07:00,
  mood: ['Happy', 'Drowsy', 'Peaceful'],
  sleep: 5.5,
  hunger: 3.0,
  coffee: 0.0
}
</code></p>

<p>As I'm playing back and forth with the metadata selector methods I'm realizing that writing non-brittle tests is extremely difficult!</p>

<p>I'm noticing that some of the metadata, when broken into Strings, don't parse very well. For instance:</p>

<p><code>Time: 8:03</code> splits up into <code>["Time", " 8", "03"]</code></p>

<p>We can use a splat operator to clean that up a bit for us:</p>

<p>```ruby
def metadata_by_selector(selector)
  node = nodes_by_selector(selector).first
  metadata = {}
  node.children.each do |child|</p>

<pre><code>key, *value = child.content.split(':')
puts "#{key}: #{value}"
</code></pre>

<p>  end    <br/>
end
```</p>

<p>The above should produce something like:</p>

<p><code>
Time: [" 8", "03 am"]
Mood: [" Happy, Drowsy, Peaceful"]
Sleep: [" 5.5"]
Hunger: [" 3"]
Coffee: [" 0"]
</code></p>

<p>Close... but still not perfect. I think the best thing to do would be to write some formatter objects or functions to handle the different kinds of metadata. We'll tackle that tomorrow.</p>

<ul>
<li>Time: 9:34pm</li>
<li>Mood: Fat, Tired, Drunk</li>
<li>Sleep: 6</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hacking the PATH variable in Sublime Text]]></title>
    <link href="http://robdodson.me/blog/2012/05/14/hacking-the-path-variable-in-sublime-text/"/>
    <updated>2012-05-14T20:26:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/14/hacking-the-path-variable-in-sublime-text</id>
    <content type="html"><![CDATA[<p>This is going to be a bit of a lightning post but I wanted to quickly show off how to edit the PATH variable that Sublime text uses. I should warn you that that I am neither an expert in Python nor am I a very seasoned Sublime user. So having said that take all of this with a grain of salt and use at your own risk.</p>

<h3>Our first (crappy) plugin!</h3>

<p>Sublime has a great plugin architecture that makes it extremely easy to add to the platform. If you create a <code>.py</code> file in the <code>~/Library/Application Support/Sublime Text 2/Packages/User/</code> folder it will be loaded as soon as Sublime starts. Writing plugins seems to be actually quite easy based on their <a href="http://www.sublimetext.com/docs/plugin-basics">documentation and examples.</a> We won't be following the typical plugin architecture since we're just trying to hack a system variable and that doesn't seem to necessitate the use of their built in modules.</p>

<p>Here's a script I'm calling <code>Pathway</code> at the moment.</p>

<p>```python
import os</p>

<p>LOCAL = '/usr/local/bin:/usr/local/sbin:'
HOME = '/Users/Rob'  ### !!! REPLACE WITH YOUR HOME PATH !!! ###
RVM = HOME + '/.rvm/bin:'</p>

<h1>Sublime's default path is</h1>

<h1>/usr/bin:/bin:/usr/sbin:/sbin</h1>

<p>os.environ['PATH'] += ':'
os.environ['PATH'] += LOCAL
os.environ['PATH'] += RVM</p>

<p>print 'PATH = ' + os.environ['PATH']
<code>``
If you add this file to the Sublime user's directory outlined above you should be able to hit cmd + \</code> to fire up the Sublime console which will print out our new PATH variable.</p>

<p>I would also recommend adding a shell plugin to Sublime. At the moment I use <a href="https://github.com/misfo/Shell-Turtlestein">Shell Turtlestein.</a>.</p>

<p>Now that I have my hacked path variable and my shell plugin I can check to see if RVM works. Using Shell Turtlestein you can hit <code>cmd-shift-c</code> to open a little console prompt. Typing <code>rvm current</code> returns our ruby version number and gemset. Nice! What's even nicer is this means I can now run Rake tasks from inside of Sublime!</p>

<p>I should point out if all you want to do is run Rake or Ant then there are already plugins for that sort of thing. My main effort in doing all this is to try to integrate the command line with Sublime a bit better. If <em>anyone</em> knows how to simply tell Sublime to use the path in my .bash_profile or .bashrc then I would gladly use that approach instead. But after crawling the forums for a while it looks like this is still a common problem with no good solution.</p>

<ul>
<li>Time: 8:26 pm</li>
<li>Mood: Happy, Peaceful, Hurried</li>
<li>Sleep: 7</li>
<li>Hunger: 6</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 6]]></title>
    <link href="http://robdodson.me/blog/2012/05/13/object-oriented-scraper-backed-with-tests-pt-6/"/>
    <updated>2012-05-13T07:52:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/13/object-oriented-scraper-backed-with-tests-pt-6</id>
    <content type="html"><![CDATA[<p>Yesterday we verified that our <code>Crawler</code> was able to hit a document and, given the right selector, pull down a list of words and their frequency on the page. We also created a custom exception to be used whenever the selector fails to pull down the right content. I'm going to repeat this process today with the <code>get_metadata_by_selector</code>. If there's time we'll try to output another file with our data, otherwise that'll be tomorrow's homeworkd :D</p>

<p>Let's take a moment to look at today's metadata to figure out what we'd like our output to reflect.</p>

<p><code>
- Time: 8:03 am
- Mood: Happy, Drowsy, Peaceful
- Sleep: 5.5
- Hunger: 3
- Coffee: 0
</code></p>

<p>That's the actual markdown that goes into the editor but it gets converted into a <code>ul</code>. I don't <em>think</em> you can pass a CSS class to markdown syntax otherwise I'd use one here. We could go back and wrap everything in regular HTML tags but since we know that our metadata is going to be the last ul per entry we'll just use that knowledge to build our selector. Obviously a more robust solution would use a CSS class so that might be a good refactoring for the future.</p>

<p>I figure for now we'll just parse the metadata into a Hash that'll look something like this:</p>

<p><code>
{
  datetime: 2012-05-13T08:03:00-07:00,
  mood: ['Happy', 'Drowsy', 'Peaceful'],
  sleep: 5.5,
  hunger: 3.0,
  coffee: 0.0
}
</code>
In the final iteration we'll toss all of our Metadata Hashes into an ordered Array so we can visualize them over time.</p>

<h3>Red, Green, Refactor</h3>

<p>Ok, time for a failing test. Let's make sure that our selector pulls something down and if it doesn't we should raise the custom <code>SelectionError</code> we defined yesterday. I'm already seeing some repetitive code in our Crawler so I'm refactoring it. Where we need to get a group of XML nodes from the document via selector I've created a private helper called <code>nodes_by_selector</code>. This is also where we'll raise our exception if nothing came back. I'm also cleaning up some of the word cruff from our public API so instead of <code>get_words_by_selector</code> it's not just <code>words_by_selector</code>. The same goes for our metadata method.</p>

<p>```ruby tentacles/lib/tentacles/crawler_rb
require 'open-uri'
require 'nokogiri'
require_relative 'selection_error'</p>

<p>module Tentacles
  class Crawler</p>

<pre><code>attr_reader :doc

def self.from_uri(uri)
  new(uri)
end

def initialize(uri)
  @uri = uri
  @doc = Nokogiri::HTML(open(@uri))
  @counts = Hash.new(0)
end

def words_by_selector(selector)
  nodes = nodes_by_selector(selector)
  nodes.each do |node|
    words = words_from_string(node.content)
    count_frequency(words)
  end

  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map { |word, count| "#{word}: #{count}"}
end

def metadata_by_selector(selector)
  nodes = nodes_by_selector(selector)
end
</code></pre>

<p>  private</p>

<pre><code>def nodes_by_selector(selector)
  nodes = doc.css(selector)
  raise Tentacles::SelectionError, 
    'The selector did not return an results!' if nodes.empty?
  nodes
end 

def words_from_string(string)
  string.downcase.scan(/[\w']+/)
end

def count_frequency(word_list)
  for word in word_list
    @counts[word] += 1
  end
  @counts
end
</code></pre>

<p>  end
end
<code>
Going back to the tests we need to refactor a bit for any place that's been broken. Immediately I saw that my `nodes_by_selector` method was not initially returning the nodes so I added that back in. The tests brought that to my attention before I had to do any potentially painful debugging. Beyond that we just need to fix up our method names:
</code>ruby tentacles/spec/crawler_spec.rb
require_relative '../lib/tentacles/crawler'
require 'fakeweb'</p>

<p>describe Tentacles::Crawler do</p>

<p>  before do</p>

<pre><code># Create a mock options object
@options = {
  uri: 'http://robdodson.me', 
  post_selector: '.entry-content',
  metadata_selector: '.personal-metadata'
}

# Create a mock web request
FakeWeb.register_uri(:get, @options[:uri],
                     :body =&gt; '&lt;div class="' + @options[:post_selector].delete(".") + 
                     '"&gt;Hello Hello Hello World World Foobar!&lt;/div&gt;')
</code></pre>

<p>  end</p>

<p>  describe "constructors" do</p>

<pre><code>describe "#from_uri" do
  it "should respond" do
    Tentacles::Crawler.should respond_to(:from_uri)
  end

  it "should return an instance" do
    crawler = Tentacles::Crawler.from_uri(@options[:uri])
    crawler.should be_an_instance_of(Tentacles::Crawler)
  end
end
</code></pre>

<p>  end</p>

<p>  describe "instances" do</p>

<pre><code>before do
  @crawler = Tentacles::Crawler.from_uri(@options[:uri])
end

subject { @crawler }

it { should respond_to(:words_by_selector) }
it { should respond_to(:metadata_by_selector) }

context "post-construct" do
  it "should have the right document" do
    @crawler.doc.content.should =~ /Hello Hello Hello World World Foobar!/
  end
end

describe "#words_by_selector" do
  it "should produce an Array of keywords" do
    expected_array = ['hello: 3', 'world: 2', 'foobar: 1']
    actual_array = @crawler.words_by_selector(@options[:post_selector])
    actual_array.should eq(expected_array)
  end

  it "should raise an exception if nothing was returned" do
    expect { @crawler.words_by_selector('some-gibberish-selector') }.to raise_error(Tentacles::SelectionError, 'The selector did not return an results!')  
  end
end

describe "#metadata_by_selector" do
  it "should raise an exception if nothing was returned" do
    expect { @crawler.metadata_by_selector('some-gibberish-selector') }.to raise_error(Tentacles::SelectionError, 'The selector did not return an results!')  
  end
end
</code></pre>

<p>  end
end
```</p>

<p>We've got a duplicate test in there where both <code>#words_by_selector</code> and <code>#metadata_by_selector</code> are checking that they both raise an exception if nothing comes down. Let's see if we can refactor those into an RSpec shared example. I'm not sure if this is a best practice or not but here's my implementation:</p>

<p>```ruby tentacles/spec/crawler_spec.rb
shared_examples_for "all selector methods" do
  describe "when selection has no nodes" do</p>

<pre><code>it "should raise an exception" do
  expect { @crawler.send(selector_method, 'some-gibberish-selector') }.to raise_error(Tentacles::SelectionError, 'The selector did not return an results!')  
end
</code></pre>

<p>  end
end</p>

<h3>...</h3>

<p>describe "#words_by_selector" do
  it_behaves_like "all selector methods" do</p>

<pre><code>let(:selector_method) { :words_by_selector }
</code></pre>

<p>  end</p>

<h1>...</h1>

<p>end</p>

<p>describe "#metadata_by_selector" do
  it_behaves_like "all selector methods" do</p>

<pre><code>let(:selector_method) { :metadata_by_selector }
</code></pre>

<p>  end
end
```</p>

<p>Basically we're putting our method name as a symbol into a variable using <code>let</code> and then calling that method in the shared_examples_for block. Notice how we're using <code>@crawler.send(selector_method, ...)</code>? In this case <code>selector_method</code> refers to our method name symbol.</p>

<p>If you run this in RSpec's nested mode it looks pretty cool:</p>

<p>```ruby
Tentacles::Crawler
  constructors</p>

<pre><code>#from_uri
  should respond
  should return an instance
</code></pre>

<p>  instances</p>

<pre><code>should respond to #words_by_selector
should respond to #metadata_by_selector
post-construct
  should have the right document
#words_by_selector
  should produce an Array of keywords
  behaves like all selector methods
    when selection has no nodes
      should raise an exception
#metadata_by_selector
  behaves like all selector methods
    when selection has no nodes
      should raise an exception
</code></pre>

<p>```</p>

<p>Ok, so we know that all of our selector methods raise the proper exception if they are called with a bunk selector. Now let's make sure we can get our metadata downloaded and structured.</p>

<p>Unfortunately I'm realizing that if the <code>ul</code> for our metadata is part of the post then those words get counted along with everything else, which is not what I want. I need to figure out how to exclude that content...</p>

<p>I could either tell my crawler to explicitly ignore that content or wrap my blog entry in an even more specific class and just select that. I guess that'll be an exercise for tomorrow :\</p>

<ul>
<li>Time: 8:03 am</li>
<li>Mood: Happy, Drowsy, Peaceful</li>
<li>Sleep: 5.5</li>
<li>Hunger: 3</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
</feed>
