<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chain | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/chain/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-06-05T00:06:09-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deploying Your First Node.js and Socket.io App to Heroku]]></title>
    <link href="http://robdodson.me/blog/2012/06/04/deploying-your-first-node-dot-js-and-socket-dot-io-app-to-heroku/"/>
    <updated>2012-06-04T22:01:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/04/deploying-your-first-node-dot-js-and-socket-dot-io-app-to-heroku</id>
    <content type="html"><![CDATA[<p>At my office we like to shoot each other from across the room with Nerf guns. In an effort to actually remain productive we've implemented a rule that whenever you get shot you're dead for 1 hour. But that hour can be a little tricky to keep track of between players. Who's dead and who isn't? Am I about to be shot right now??</p>

<p>In an effort to keep track of things (and also because I need to write a blog post) I decided to start working on a little <a href="http://nodejs.org/">Node.js</a> and <a href="http://socket.io/">Socket.io</a> app. In this first post I'm just going to get things setup and deploy them to Heroku. Hopefully tomorrow we can work on implementing the actual timers. If you've never worked with Heroku before <a href="https://devcenter.heroku.com/articles/quickstart">you'll need to follow their getting started guide</a> to make sure you have all the proper command line tools. Don't worry, it's really easy and their documentation is <strong>awesome</strong>.</p>

<h3>Express it!</h3>

<p>To start us off we'll use <a href="http://expressjs.com/">Express</a> since it provides a nice, <a href="http://www.sinatrarb.com/">Sinatra</a> like layer on top of Node. If you haven't installed Node yet you can do it from the <a href="http://nodejs.org/">Node.js</a> site. The installer will also include <code>npm</code> which is Node's package manager. Following the instructions on the <a href="http://expressjs.com/">Express</a> site you should be able to just type:</p>

<p><code>
npm install -g express
</code></p>

<p>Now that you have Express installed you can use it to create a new project.</p>

<p><code>
express defcon
</code>
I'm calling my project <code>defcon</code> because I luvz <a href="http://en.wikipedia.org/wiki/WarGames">WarGames</a>. You can call yours whatever you'd like :)</p>

<p>Next we need to <code>cd</code> into the defcon folder so we can install Socket.io and our other dependencies. There's a version of Socket.io designed to work with Express so we'll install that one.</p>

<p><code>
npm install -d  # install Express dependencies
npm install socket.io express
</code></p>

<p>We'll also need to add socket.io to our <code>package.json</code> which is similar to a <code>Gemfile</code> if you're coming from Ruby, or just a big list of file dependencies if you're coming from something else :D When you distribute your app other developers can just run 'npm install -d' and it will add all of the modules listed to their project. Heroku will also use our <code>package.json</code> when we push our app to their servers. I'm also going to replace the <a href="http://jade-lang.com/">Jade</a> rendering engine with <a href="http://embeddedjs.com/">EJS</a> since it's easier for me to work with.</p>

<p>``` js package.json
{</p>

<pre><code>"name": "defcon",
"version": "0.0.1",
"private": true,
"dependencies": {
  "express": "~2.5.8",
  "ejs": "~0.7.1",
  "socket.io": "~0.9.6"
</code></pre>

<p>  },
  "engines": {</p>

<pre><code>"node": "0.6.x"
</code></pre>

<p>  }
}
```</p>

<p>The tilde <code>~</code> character tells NPM that it's ok to install this version of our module, or anything less than the next highest version number. So the following are equivalent: <code>"~1.2" = "&gt;=1.2.0 &lt;2.0.0"</code>. This is typically a good practice with modules because you'd like to receive bug fixes and patches but you don't want to let your app potentially download a v2 of some library which breaks the API.</p>

<p>Run <code>npm install -d</code> again to make sure that <code>ejs</code> and anything else you've added are properly installed. Open up your app.js file that Express provided for you. We'll need to change a lot of stuff so it's probably easiest for you to just copy and paste this one that I've already prepared. Paste it into a new file if you'd like so you can compare all the differences.</p>

<p>``` js app.js
var express = require('express'),</p>

<pre><code>app = express.createServer(express.logger()),
io = require('socket.io').listen(app),
routes = require('./routes');
</code></pre>

<p>// Configuration</p>

<p>app.configure(function() {
  app.set('views', <strong>dirname + '/views');
  app.set('view engine', 'ejs');
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(app.router);
  app.use(express.static(</strong>dirname + '/public'));
});</p>

<p>app.configure('development', function() {
  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));
});</p>

<p>app.configure('production', function() {
  app.use(express.errorHandler());
});</p>

<p>// Heroku won't actually allow us to use WebSockets
// so we have to setup polling instead.
// https://devcenter.heroku.com/articles/using-socket-io-with-node-js-on-heroku
// io.configure(function () {
//   io.set("transports", ["xhr-polling"]);
//   io.set("polling duration", 10);
// });</p>

<p>// Routes</p>

<p>var port = process.env.PORT || 5000; // Use the port that Heroku provides or default to 5000
app.listen(port, function() {
  console.log("Express server listening on port %d in %s mode", app.address().port, app.settings.env);
});</p>

<p>app.get('/', routes.index);</p>

<p>var status = "All is well.";</p>

<p>io.sockets.on('connection', function (socket) {
  io.sockets.emit('status', { status: status }); // note the use of io.sockets to emit but socket.on to listen
  socket.on('reset', function (data) {</p>

<pre><code>status = "War is imminent!";
io.sockets.emit('status', { status: status });
</code></pre>

<p>  });
});
```</p>

<p>In my views folder I've created a <code>layout.ejs</code>...</p>

<p>``` html views/layout.ejs
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;

&lt;!-- HTML5 shim, for IE6-8 support of HTML elements --&gt;
&lt;!--[if lt IE 9]&gt;
  &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;

&lt;!-- styles --&gt;
&lt;link href="http://robdodson.me/css/main.css" rel="stylesheet"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;%- body %&gt;
&lt;script src="http://robdodson.me/socket.io/socket.io.js"&gt;&lt;/script&gt;
&lt;script src="http://robdodson.me/js/libs/jquery.js"&gt;&lt;/script&gt;
&lt;script src="http://robdodson.me/js/main.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>and an <code>index.ejs</code>.</p>

<p>``` html views/index.ejs</p>

<div id="status"></div>


<p><button id="reset">Reset!</button>
```</p>

<p>If you'd like you can open up <code>routes/index.js' and look around but you don't need to. It should render</code>layout.ejs<code>and</code>index.ejs` by default.</p>

<p>A few more items to go...We need to add a copy of <a href="http://jquery.com/">jQuery</a> to our <code>public</code> folder and also a <code>main.js</code> file. I've renamed the structure to look like this:</p>

<p>```
public
|
|<em> css
|</em> img
|_ js</p>

<pre><code>|_ libs
    |_ jquery.js
|_ plugins
|_ main.js
</code></pre>

<p>```</p>

<p>I guess that's just a habit of using Backbone Boilerplate all the time :) Here's what <code>main.js</code> should look like:</p>

<p>``` js public/js/main.js
var socket = io.connect(window.location.hostname);</p>

<p>socket.on('status', function (data) {</p>

<pre><code>$('#status').html(data.status);
</code></pre>

<p>});</p>

<p>$('#reset').click(function() {</p>

<pre><code>socket.emit('reset');
</code></pre>

<p>});
```</p>

<p>It's important to note the line that says <code>var socket = io.connect(window.location.hostname);</code>. In the socket.io docs they usually tell you to connect to <code>localhost</code> but since we're on heroku we'll need to instead connect to whatever our custom domain is.</p>

<h3>Cross your fingers</h3>

<p>At this point we should be ready to test everything. From the root of your project run <code>node app.js</code>. If all goes well you should see something like this:</p>

<p><code>
   info  - socket.io started
Express server listening on port 5000 in development mode
</code></p>

<p>If not leave me a comment and I'll see if I can help you debug it. However let's assume that everything DID go well for you and now you're ready to connect to the local version of your app. Point your browser to http://localhost:5000 and you should see something like this:</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/all_is_well_with_sockets.png" title="'All is well with Socket.io'" ></p>

<p>Now open another browser window and also point it at localhost:5000. In one of the windows click the button that says <code>Reset</code> which should change the copy in <em>both</em> windows to 'War is imminent!'</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/war_is_imminent_sockets.png" title="'War is Immentin with Socket.io'" ></p>

<h3>Git'er done!</h3>

<p>Alright we should have a functioning app at this point so let's put this baby into Git.</p>

<p><code>
git init
echo 'node_modules' &gt;&gt; .gitignore
</code></p>

<p>We'll ignore the node_modules directory so Heroku can create its own version. Heroku requires that we deploy our app from Git which is kind of an awesome practice. We'll also need to define a <code>Procfile</code> which will list the processes that our app can run.</p>

<p><code>
touch Procfile
echo 'web: node app.js' &gt;&gt; Procfile
</code>
To verify that our <code>Procfile</code> is working we can use Heroku's built in utility called <code>foreman</code>.</p>

<p>```
$ foreman start</p>

<p>23:47:32 web.1     | started with pid 53197
23:47:32 web.1     | info: socket.io started
23:47:32 web.1     | Express server listening on port 5000 in development mode
```</p>

<p>Point your browser to <code>localhost:5000</code> to verify that things are still working. If everything looks good we're ready to commit to git.</p>

<p><code>
git add .
git commit -m 'initial commit'
</code></p>

<h3>Deploy to Heroku</h3>

<p>Now that our app is safely tucked away in git it's time to fire up a new Heroku instance.</p>

<p><code>
$ heroku create --stack cedar
</code></p>

<p>Heroku will do the work of setting up a new <code>git remote</code> for us to push our app to.</p>

<p><code>
$ git push heroku master
</code></p>

<p>We'll need to scale our web process before we can use the app.</p>

<p><code>
$ heroku ps:scale web=1
</code></p>

<p>To see which processes are running on Heroku you can use the <code>heroku ps</code> command.</p>

<p>```
$ heroku ps
Process       State               Command</p>

<hr />

<p>web.1         up for 10s          node app.js
```</p>

<p>With everything setup we should be able to run <code>heroku open</code> which will fire up our browser and direct it to an instance of our app. There seems to be a fair bit of latency so it can take several seconds for the initial status of 'All is well' to show up. If you see the Reset button with nothing above it give it around 10 seconds to see if it eventually updates. Open another browser window and point it at the Heroku domain in the address bar. If you press the Reset button in one window it should immediately update in the next one.</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/heroku_war_is_imminent.png" title="'Heroku: War is Imminent'" ></p>

<h3>Wrapping up</h3>

<p>Well I hope you enjoyed this brief tour of Socket.io and Heroku. Before we sign off let's make sure to turn off the running process on our Heroku instance:</p>

<p><code>
$ heroku ps:scale web=0
</code></p>

<p>If all went well you should have a decent starting point to build your own Socket.io app. If you're still having trouble checkout some of the great documentation from Heroku and/or leave a comment:</p>

<p><a href="https://devcenter.heroku.com/articles/nodejs">https://devcenter.heroku.com/articles/nodejs</a></p>

<p><a href="https://devcenter.heroku.com/articles/using-socket-io-with-node-js-on-heroku">https://devcenter.heroku.com/articles/using-socket-io-with-node-js-on-heroku</a></p>

<p>Good Luck! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 10:02 pm</li>
<li>Mood: Tired, Antsy</li>
<li>Sleep: 5</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make Your Own jQuery Deferreds and Promises]]></title>
    <link href="http://robdodson.me/blog/2012/06/03/make-your-own-jquery-deferreds-and-promises/"/>
    <updated>2012-06-03T20:33:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/03/make-your-own-jquery-deferreds-and-promises</id>
    <content type="html"><![CDATA[<p>Last week <a href="http://robdodson.me/blog/2012/05/30/using-jquery-deferred-to-load-an-underscore-template/">I did a post on how to load an Underscore template using jQuery's Deferred method</a>. I got some great feedback from folks and decided I should do a follow up showing how to create your own Deferreds.</p>

<h3>What's a Deferred again...?</h3>

<p>So, quick summary time. jQuery has a neat little Object called a <code>Deferred</code> which is basically a wrapper around a function or a group of functions. Let's say that you want to load 3 different json files via ajax and when all that's done you want to let the rest of the world know. Using jQuery's <code>Deferred</code> Object we can actually put a wrapper around those 3 ajax functions and fire off a callback when they've all finished. <a href="http://robdodson.me/blog/2012/05/30/using-jquery-deferred-to-load-an-underscore-template/">Refer back to my previous post (toward the bottom) where I explain some of these callbacks.</a></p>

<p><code>Deferred</code> isn't limited to ajax calls, it can work in just about any environment. Let's do an example using jQuery's animate function. We'll fade an item and when it's finished animating we'll resolve our <code>Deferred</code> object.</p>

<h3>Our First Deferred</h3>

<p>Here's the code we'll be using in our index.html file:</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Deferred Sandbox&lt;/title&gt;
&lt;style type="text/css"&gt;
  #container {
    width: 100px;
    height: 100px;
    background: #CCC;
  }
&lt;/style&gt;

&lt;script src="jquery.js"&gt;&lt;/script&gt;
&lt;script src="main.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;div id="main"&gt;
  &lt;div id="container"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Take note of the fact that I've included jquery.js and main.js in the same folder as index.html. If you run the above you should get a simple little grey square in the top left of your screen. Now let's dive into the JavaScript.</p>

<p>``` js main.js
var container = {</p>

<pre><code>initialize: function($el) {
    // Store a reference to our element
    // on the page
    this.$el = $el;
},
fadeOut: function() {
    // Create a new Deferred.
    var dfd = new $.Deferred();

    this.$el.animate({
        opacity: 0
    }, 2000, function() {
        // When we're done animating
        // we'll resolve our Deferred.
        // This will call any done() callbacks
        // attached to either our Deferred or
        // one of its promises.
        dfd.resolve("Finished fading out!");
    });

    // Return an immutable promise object.
    // Clients can listen for its done or fail
    // callbacks but they can't resolve it themselves
    return dfd.promise();
}
</code></pre>

<p>};</p>

<p>$(function() {</p>

<pre><code>// Hook the container object up to the #container div
container.initialize($('#container'));

// Instruct the container to fade out. When we call
// fadeOut we should get a promise back as a return value
var promise = container.fadeOut();

// Now that we have a promise we can hook a done callback
// onto it. The done() method will fire once the promise
// is resolved.
promise.done(function(message) {
    console.log(message);
});
</code></pre>

<p>});
```</p>

<p>That's a fair bit of code so let's walk through it bit by bit. We start off by creating an object called <code>container</code> which is going to wrap the <code>#container</code> div already on the page. The real guts of container happens in the <code>fadeOut</code> method:</p>

<p>``` js
fadeOut: function() {</p>

<pre><code>// Create a new Deferred.
var dfd = new $.Deferred();

this.$el.animate({
    opacity: 0
}, 2000, function() {
    // When we're done animating
    // we'll resolve our Deferred.
    // This will call any done() callbacks
    // attached to either our Deferred or
    // one of its promises.
    dfd.resolve("Finished fading out!");
});

// Return an immutable promise object.
// Clients can listen for its done or fail
// callbacks but they can't resolve it themselves
return dfd.promise();
</code></pre>

<p>}
<code>``
The first thing we do is to create a new</code>Deferred<code>using jQuery's Deferred constructor. Ignore the animation function for a moment and look at the bottom of this method. See how we're returning</code>dfd.promise()<code>? A promise is a dynamically generated object which lets clients hook onto our</code>done<code>and</code>fail<code>callbacks but it doesn't let them do anything to change our original</code>Deferred<code>object. A promise is an</code>immutable<code>object, meaning clients can listen to it but they can't really do anything to change it. We want this functionality because we don't want someone else to come along and accidentally resolve our</code>Deferred<code>. So instead of returning the</code>Deferred<code>we just created, we only return its</code>promise`.</p>

<p>OK back to the animation function:</p>

<p>``` js
this.$el.animate({</p>

<pre><code>opacity: 0
</code></pre>

<p>}, 2000, function() {</p>

<pre><code>// When we're done animating
// we'll resolve our Deferred.
// This will call any done() callbacks
// attached to either our Deferred or
// one of its promises.
dfd.resolve("Finished fading out!");
</code></pre>

<p>});
<code>``
If you've used</code>jQuery.animate<code>before this should look pretty straightforward to you. At the end of our animation we pass in an anonymouse function which will be run when the animation completes. In this function we tell our</code>Deferred<code>to resolve. Resolving the</code>Deferred<code>causes any</code>done<code>callbacks to fire. In this case we're also passing along a little snippet of text. When you resolve a</code>Deferred<code>you can give it an optional payload object which will be passed to all the</code>done` callbacks. This is extremely useful if you're using ajax to pass along the final data value. In this case we're just going to log the message into the console:</p>

<p>``` js
promise.done(function(message) {</p>

<pre><code>console.log(message);
</code></pre>

<p>});
<code>``
There are more cool things you can do with</code>Deferreds<code>I highly recommend you [spend some time with the documentation](http://api.jquery.com/category/deferred-object/) and trying out some of the other methods like</code>pipe<code>or</code>resolveWith`. Let me know if this is helpful or if you have any questions. Till tomorrow! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 8:35 pm</li>
<li>Mood: Silly, Lazy</li>
<li>Sleep: 7</li>
<li>Hunger: 5</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Your Backbone Views with the State Pattern]]></title>
    <link href="http://robdodson.me/blog/2012/06/02/managing-your-backbone-views-with-the-state-pattern/"/>
    <updated>2012-06-02T18:22:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/02/managing-your-backbone-views-with-the-state-pattern</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten/">Yesterday I wrote a post to illustrate the concepts behind the State pattern</a> (one of my all time favorite tools). If you're new to this pattern and haven't read my previous post I suggest you start there and read this one after you've had a chance to play around with the ideas.</p>

<p>I wanted to write about this pattern in the context of a Backbone app because I think there's a lot of value in exploring different ways to manage our Views and Models. Here's an example Video Player in which several State objects inherit from a common ancestor, <code>BaseState</code>. I chose to make <code>BaseState</code> extend <code>Backbone.Model</code> because it seemed like the best fit for this kind of thing, although typically when I implement this pattern in other languages I just use generic Objects. I would have done that here but Backbone's <code>extend</code> functionality makes the code so much cleaner.</p>

<p>``` js
var BaseState = Backbone.Model.extend({
  initialize: function(owner) {</p>

<pre><code>this.owner = owner;
</code></pre>

<p>  },
  enter: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  },
  execute: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>console.log('changing to the playing state...');
this.owner.changeState(this.owner.states.playing);
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>console.log('changing to the stopping state...')
this.owner.changeState(this.owner.states.stopping);
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>console.log('changing to the pausing state...')
this.owner.changeState(this.owner.states.pausing);
</code></pre>

<p>  },
  exit: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  }
});</p>

<p>var PlayingState = BaseState.extend({
  execute: function() {</p>

<pre><code>console.log('playing the video!');
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>console.log('already playing!');
</code></pre>

<p>  }
});</p>

<p>var StoppingState = BaseState.extend({
  enter: function() {</p>

<pre><code>console.log('we have entered the stopping state...');
</code></pre>

<p>  },
  execute: function() {</p>

<pre><code>console.log('stopping the video...');
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>console.log('already stopped!');
</code></pre>

<p>  }
});</p>

<p>var PausingState = BaseState.extend({
  execute: function() {</p>

<pre><code>console.log('pausing the video.');
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>console.log('already paused!');
</code></pre>

<p>  }
});
```</p>

<p>Every state inherits from <code>BaseState</code> which means they all create a reference to an <code>owner</code> object in their <code>initialize</code> methods. The <code>owner</code> is going to be our actual <code>VideoPlayer</code> object. Rather than having <code>videoPlayer.play</code> lead to some big weird conditional:</p>

<p>``` js
play: function() {
  if (this.status == 'playing') {</p>

<pre><code>  return;
</code></pre>

<p>  } else if (this.status == 'stopped') {</p>

<pre><code>  // play the video
</code></pre>

<p>  } else if (this.status == 'paused') {</p>

<pre><code>  // unpause and play
</code></pre>

<p>  }
  else if ...
}
```</p>

<p>we're instead going to delegate the work to our State objects. They'll handle switching from one State to the next and so long as we provide the exact same public API methods in each, they should be interchangeable. Inheriting from the same BaseState ensures that all of the States have the same public methods and each State can choose how or if it wants to override them. In our example the <code>StoppingState</code> overrides the <code>enter</code> method to display some text as we're transitioning into this state. Again, you can override some or all of the methods, <code>enter</code> and <code>exit</code> are great for building up/tearing down anything that our state might need and <code>execute</code> is where the main work of our state should happen.</p>

<p>Let's take a look at the <code>VideoPlayer</code> which is a <code>Backbone.View</code> that will leverage our State objects:</p>

<p>``` js
var VideoPlayer = Backbone.View.extend({
  initialize: function() {</p>

<pre><code>this.states = {};
this.states.playing = new PlayingState(this);
this.states.stopping = new StoppingState(this);
this.states.pausing = new PausingState(this);
this.changeState(this.states.pausing);
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>this.state.play();
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>this.state.stop();
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>this.state.pause();
</code></pre>

<p>  },
  changeState: function(state) {</p>

<pre><code>// Make sure the current state wasn't passed in
if (this.state !== state) {
  // Make sure the current state exists before
  // calling exit() on it
  if (this.state) {
    this.state.exit();
  }
  this.state = state;
  this.state.enter();
  this.state.execute();
}
</code></pre>

<p>  }
});
<code>``
You'll notice that</code>VideoPlayer<code>instantiates its own State objects when it is first created. Then whenever we call one of its public methods the call is delegated to whichever state object is currently residing in</code>this.state`.</p>

<p>Let's instantiate a new VideoPlayer to see it in action:</p>

<p>``` js
var videoPlayer = new VideoPlayer();</p>

<p>=> 'pausing the video.'</p>

<p>videoPlayer.play();</p>

<p>=> 'changing to the playing state...'
=> 'playing the video!'</p>

<p>videoPlayer.play();</p>

<p>=> 'already playing!'</p>

<p>videoPlayer.stop();</p>

<p>=> 'changing to the stopping state...'
=> 'we have entered the stopping state...'
=> 'stopping the video...'
```</p>

<p>Hopefully this gives you some food for thought the next time you're trying to wrangle some unwieldy component. I cannot count how many times I've used this pattern in other languages to tidy up and organize my code. I'm looking forward to working with it again in Backbone and I'd love to hear anyone's take on how this can be tweaked or improved. Till tomorrow! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 9:48 pm</li>
<li>Mood: Focused, Hurried</li>
<li>Sleep: 5</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Take Control of your App with the JavaScript State Pattern]]></title>
    <link href="http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten/"/>
    <updated>2012-06-02T00:09:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten</id>
    <content type="html"><![CDATA[<p>Last week I wrote a post about <a href="http://robdodson.me/blog/2012/05/25/backbone-events-framework-communication/">communicating between views in Backbone.js</a> and since then it has easily become my most popular article. The comments have forced me to think about the ways in which I typically manage state in very large Flash applications and how that might translate to JavaScript and Backbone. Today I want to present my all time favorite design pattern, the State pattern, and illustrate how it can help you maintain control of your application. I want to warn you that I'm going to show a rather large block of what looks like repetitive code because I want the pattern to be obvious. In tomorrow's post we'll clean it up and try it out with a Backbone Model and View.</p>

<h3>The State pattern?</h3>

<p>Ok let's get started. I want to write a video player so I'm going to need an object that can handle <code>play</code>, <code>stop</code> and <code>pause</code> states. I would say that there are probably a ton of video players out there that have <code>play</code>, <code>stop</code> and <code>pause</code> methods on them, and I bet many look kind of like this:</p>

<p>``` js
play: function() {</p>

<pre><code>if (this.status == 'playing') {
    return;
} else if (this.status == 'stopped') {
    // play the video
} else if (this.status == 'paused') {
    // unpause and play
}
else if ...
</code></pre>

<p>}
```</p>

<p>Or maybe instead of a long conditional there's a switch statement or something. But <em>essentially</em> you're querying some variable somewhere to check what state the object is in and you're branching your logic as a result. Now, I would argue that this is a really brittle process and probably error prone. You could imagine that in each of those conditional blocks there might be several lines of code: preparing to play, stopping the video, tearing down this or that... Or perhaps if you're moving from one state to another you want to animate something on screen, maybe do some ajax, who knows!? Really no matter what you're doing if you're tossing it into these big conditionals it's going to become a nightmare to manage.</p>

<p>Alternatives? Ok, let's think of our video player in terms of the actions that it performs. Our player can play, it can stop and it can pause. What if instead of play, pause and stop acting as methods on our object, we make each of those states into its <em>own</em> object? So when the play state object is told to play it says 'Hey! I'm already playing. No need to change' and when it's told to stop it says 'Ah stopping, eh? Let me defer to my friend the Stop state object'.</p>

<p>To illustrate this I've written a very simple player which just logs what it's doing as you ask it to change state. I want to point out that this code is neither DRY nor very useful in a real world situation but it's intended to illustrate a point. Hopefully when you see the repetition you'll quickly say to yourself 'Hey! Those state objects could be made into a more general/abstract parent object.' That would be the correct mindset but I thought that if I skipped this part the pattern might not be obvious for those new to it.</p>

<p>``` js
var player = {</p>

<pre><code>state: undefined,
states: {
    playing: {
        initialize: function(target) {
            this.target = target;
        },
        enter: function() {
            console.log('setting up the playing state');
        },
        execute: function() {
            console.log('playing!');
        },
        play: function() {
            console.log('already playing!');
        },
        stop: function() {
            this.target.changeState(this.target.states.stopping);
        },
        pause: function() {
            this.target.changeState(this.target.states.pausing);
        },
        exit: function() {
            console.log('tearing down the playing state');
        }
    },
    stopping: {
        initialize: function(target) {
            this.target = target;
        },
        enter: function() {
            console.log('setting up the stopping state');
        },
        execute: function() {
            console.log('stopping!');
        },
        play: function() {
            this.target.changeState(this.target.states.playing);
        },
        stop: function() {
            console.log('already stopped!');
        },
        pause: function() {
            this.target.changeState(this.target.states.pausing);
        },
        exit: function() {
            console.log('tearing down the stopping state');                
        }
    },
    pausing: {
        initialize: function(target) {
            this.target = target;
        },            
        enter: function() {
            console.log('setting up the pausing state');
        },
        execute: function() {
            console.log('pausing!');
        },
        play: function() {
            this.target.changeState(this.target.states.playing);
        },
        stop: function() {
            this.target.changeState(this.target.states.stopping);
        },
        pause: function() {
            console.log('already paused!');
        },
        exit: function() {
            console.log('tearing down the pausing state!');                
        }
    }
},
initialize: function() {
    this.states.playing.initialize(this);
    this.states.stopping.initialize(this);
    this.states.pausing.initialize(this);
    this.state = this.states.stopping;
},
play: function() {
    this.state.play();
},
stop: function() {
    this.state.stop();
},
pause: function() {
    this.state.pause();
},
changeState: function(state) {
    if (this.state !== state) {
        this.state.exit();
        this.state = state;
        this.state.enter();
        this.state.execute();
    }
}
</code></pre>

<p>};
```</p>

<p>Lots of code, I know. But there is serious value in digesting this pattern so stick with me here and I'll go through it bit by bit. Let's start at the top where we define our object:</p>

<p>``` js
var player = {</p>

<pre><code>state: undefined,
states: {
    playing: {
        initialize: function(target) {
            this.target = target;
        },
        enter: function() {
            console.log('setting up the playing state');
        },
        execute: function() {
            console.log('playing!');
        },
        play: function() {
            console.log('already playing!');
        },
        stop: function() {
            this.target.changeState(this.target.states.stopping);
        },
        pause: function() {
            this.target.changeState(this.target.states.pausing);
        },
        exit: function() {
            console.log('tearing down the playing state');
        }
    },
</code></pre>

<p>... .
<code>``
First we declare our object and give it a property of</code>state<code>which we set to</code>undefined` for now. We're going to be creating state object to delegate all of our method calls to so once we're ready to use our player we'll set its initial state.</p>

<p>The <code>states</code> object (note the plurality) holds all of the different state objects that our player can use. In this version we've defined <code>playing</code>, <code>stopping</code> and <code>pausing</code> but you could also add states like <code>buffering</code> or <code>initializing</code>. Keep in mind that this pattern can be applied to just about anything. For instance, if you were making a game with an old prospector his state objects could be <code>mining</code>, <code>drinking</code> and <code>sleeping</code>. The main thing to remember is that <strong>your state objects should all define the exact same public methods</strong>.</p>

<p>We can skip the <code>stopping</code> and <code>pausing</code> states since they're nearly identical to the <code>playing</code> state. Instead let's jump down to the bottom and look at the last bit.</p>

<p>``` js
initialize: function() {</p>

<pre><code>this.states.playing.initialize(this);
this.states.stopping.initialize(this);
this.states.pausing.initialize(this);
this.state = this.states.stopping;
</code></pre>

<p>},
play: function() {</p>

<pre><code>this.state.play();
</code></pre>

<p>},
stop: function() {</p>

<pre><code>this.state.stop();
</code></pre>

<p>},
pause: function() {</p>

<pre><code>this.state.pause();
</code></pre>

<p>},
changeState: function(state) {</p>

<pre><code>if (this.state !== state) {
    this.state.exit();
    this.state = state;
    this.state.enter();
    this.state.execute();
}
</code></pre>

<p>}
```</p>

<p>In our player's initialize function we give each state a reference to the player object so we can tell it to <code>changeState</code>. We also set our initial state to be the stopping state.</p>

<p>Now let's look at the <code>play</code> method. Do you see how it defers the call to whatever object is currently set as the player's <code>state</code>? Since <code>this.state</code> refers to <code>this.states.stopping</code> we're effectively calling the <code>play</code> method of the <code>stopping</code> state object. Go look at the other state objects to see how they respond to having their <code>play</code> methods called. In the case of <code>states.stopping</code>, calling <code>play</code> is going to tell its <code>target</code> (which is just a reference to the player) to <code>changeState</code>, passing in the <code>states.playing</code> state.</p>

<p><code>changeState</code> is kind of an awesome method because it does a ton of work but it does it very elegantly and efficiently. For starters it makes sure that the state we've asked to change to is actually different than our current state. Then it tells our current state to <code>exit()</code>. A state's <code>exit()</code> method is a great place to tear down any constructs that we may have built to support that action. Next it sets our current state to the new state. Lastly, it calls <code>enter()</code> (a good place to build up supporting constructs) and <code>execute()</code>, which is where we do the main work of our state. That's pretty straightforward right?</p>

<p>Since <code>play</code>, <code>pause</code> and <code>stop</code> are members of our player's public API, <strong>all of our states must also implement those methods.</strong> Otherwise you would get an error if you called <code>play()</code> on the object and its state did not support that method. Keep this in mind when you're designing your state objects.</p>

<h3>Aaaaand we're off!</h3>

<p>Let's look at our player in action:</p>

<p>```
// We start off in the stopping state
// So when we call stop...
player.initialize();
player.stop();</p>

<p>=> 'already stopped!'</p>

<p>// Let's move to the playing state
player.play();</p>

<p>=> 'tearing down the stopping state'
=> 'setting up the playing state'
=> 'playing!'</p>

<p>// Quick call pause!
player.pause();</p>

<p>=> 'tearing down the playing state'
=> 'setting up the pausing state'
=> 'pausing!'</p>

<p>// Um... call pause like 3 times cuz
// I'm a button masher!!!
player.pause();
player.pause();
player.pause();</p>

<p>=> 'already paused!'
=> 'already paused!'
=> 'already paused!'</p>

<p>// OK call play again!
player.play();</p>

<p>=> 'tearing down the pausing state!'
=> 'setting up the playing state'
=> 'playing!'
```</p>

<h3>I like it, but...</h3>

<p>Before you run for the hills due to the sheer volume of boilerplate code I want to remind you that almost all of this repetition can easily be cleaned up. If we defined a base state that all of our other states extended then they would only need to override the methods that they cared about. For instance, the <code>stopping</code> state and <code>pausing</code> state both tell their target to <code>changeState</code> when someone calls <code>play</code>. This kind of functionality is easily moved into a base state. Also if you have no need for <code>enter</code> and <code>exit</code> methods those can be removed or also thrown into the base state. I'll dig into this more tomorrow but for now play around with the example and leave some feedback if you have comments or suggestions. Thanks!</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 12:10 am</li>
<li>Mood: Tired, Drunk</li>
<li>Sleep: 7</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to use EJS in Express]]></title>
    <link href="http://robdodson.me/blog/2012/05/31/how-to-use-ejs-in-express/"/>
    <updated>2012-05-31T11:34:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/31/how-to-use-ejs-in-express</id>
    <content type="html"><![CDATA[<p>Here's a quick explanation of how to use EJS instead of Jade in your Express projects. This is super easy and covered well in the documentation but I wanted to put it here since that's what I worked on today :)</p>

<p>To start I'll create a new project from the command line:</p>

<p><code>
express foobar
cd foobar
npm install
</code></p>

<p>Now that I have my foobar project created I need to install <code>ejs</code>.</p>

<p><code>
npm install ejs
</code></p>

<p>If you're within your project directory this will place ejs in the <code>node_modules</code> dir. Let's also add it to our package.json.</p>

<p>```
{
  "name": "foobar",
  "version": "0.0.1",
  "private": true,
  "dependencies": {</p>

<pre><code>"express": "~2.5.8",
"ejs": "~0.7.1"
</code></pre>

<p>  }
}
<code>``
The tilde operator means that we require ejs verion 0.7.1 or greater but only up to the next major release. So the following are equivalent:</code>"~1.2" = ">=1.2.0 &lt;2.0.0"`. For a deeper explanation of package.json and NPM in general <a href="http://howtonode.org/introduction-to-npm">checkout this great post</a>.</p>

<h3>Leaving Jade for EJS</h3>

<p>If you're using the boilerplate that Express generates then it should be setup to use Jade as the rendering engine for its views. I think that Jade is cool but I need to baby step into Node/Express and make sure I understand everything that's going on instead of trying to consume so many different tools at once. With this in mind I decided to switch from Jade to EJS at least in the beginning because the syntax has no learning curve. To change your rendering engine you'll need to either add or edit the following call:</p>

<p><code>js
app.set('view engine', 'ejs');
</code></p>

<p>The boilerplate should have this set to <code>jade</code> inside of a configuration block. Once we've changed that line to read <code>ejs</code> we're ready to start writing some views.</p>

<h3>Setting up your layout</h3>

<p>By default Express' boilerplate will look for a file named layout in our views directory. Let's write one called <code>layout.ejs</code>:</p>

<p>``` html views/layout.ejs
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Pivotal Search&lt;/title&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;

&lt;!-- HTML5 shim, for IE6-8 support of HTML elements --&gt;
&lt;!--[if lt IE 9]&gt;
  &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;

&lt;!-- styles --&gt;
&lt;link href="stylesheets/style.css" rel="stylesheet"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;%- body %&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>This is all really straightforward with the exception of the <code>&lt;%- body %&gt;</code> line which basically works like a <code>yield</code> in erb. Whatever template we pass to Express' <code>response.render()</code> function will fill this dependency, here's an example:</p>

<p><code>js app.js
app.get('/', function(req, res) {
  res.render('index', { title: 'The index page!' })
});
</code></p>

<p>``` html views/index.ejs</p>

<div class="title">
    <%= title %>
</div>


<p>```
<img class="center" src="https://s3.amazonaws.com/robdodson/images/rendering_the_index_template.png" title="'Rendering the index template'" ></p>

<p>Furthermore we can use partials with Express and EJS like so:</p>

<p>``` html views/layout.ejs
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Pivotal Search&lt;/title&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;

&lt;!-- HTML5 shim, for IE6-8 support of HTML elements --&gt;
&lt;!--[if lt IE 9]&gt;
  &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;

&lt;!-- styles --&gt;
&lt;link href="stylesheets/style.css" rel="stylesheet"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;%- partial('header.ejs') %&gt;
&lt;%- body %&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` html views/header.ejs
<header></p>

<pre><code>My awesome header!
</code></pre>

<p></header></p>

<hr>


<p>```</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/rendering_the_header_partial.png" title="'Rendering the header partial'" ></p>

<p>And there ya go! Simple but hopefully useful if you're just getting started like I am :) - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 11:36 am</li>
<li>Mood: Eager, Alert</li>
<li>Sleep: 7</li>
<li>Hunger: 7</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
</feed>
