<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chain | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/chain/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-05-15T22:47:53-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 7]]></title>
    <link href="http://robdodson.me/blog/2012/05/15/object-oriented-scraper-backed-with-tests-pt-7/"/>
    <updated>2012-05-15T21:33:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/15/object-oriented-scraper-backed-with-tests-pt-7</id>
    <content type="html"><![CDATA[<p>During my last post I realized that including my metadata in the blog post as only a ul meant that all the words were being scraped as part of the keyword frequency search. After thinking about it for a while I think I'm going to give the keyword search method an optional value which it can use to ignore or delete certain nodes.</p>

<p>Thankfully I have my tests in place to validate what our final output should look like. Which means I'm basically hacking away at Nokogiri to get things to pass. Here's what I finally settle on:</p>

<p>```ruby
def words_by_selector(selector, ignored_selector = nil)
  node = nodes_by_selector(selector).first
  if ignored_selector</p>

<pre><code>ignored = node.css(ignored_selector)
ignored.remove()
</code></pre>

<p>  end
  words = words_from_string(node.content)
  count_frequency(words)</p>

<p>  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map { |word, count| "#{word}: #{count}"}
end
```</p>

<p>I think the code is pretty self explanatory. Moving on to the metadata we expect a Hash that looks like this:</p>

<p><code>
{
  datetime: 2012-05-13T08:03:00-07:00,
  mood: ['Happy', 'Drowsy', 'Peaceful'],
  sleep: 5.5,
  hunger: 3.0,
  coffee: 0.0
}
</code></p>

<p>As I'm playing back and forth with the metadata selector methods I'm realizing that writing non-brittle tests is extremely difficult!</p>

<p>I'm noticing that some of the metadata, when broken into Strings, don't parse very well. For instance:</p>

<p><code>Time: 8:03</code> splits up into <code>["Time", " 8", "03"]</code></p>

<p>We can use a splat operator to clean that up a bit for us:</p>

<p>```ruby
def metadata_by_selector(selector)
  node = nodes_by_selector(selector).first
  metadata = {}
  node.children.each do |child|</p>

<pre><code>key, *value = child.content.split(':')
puts "#{key}: #{value}"
</code></pre>

<p>  end    <br/>
end
```</p>

<p>The above should produce something like:</p>

<p><code>
Time: [" 8", "03 am"]
Mood: [" Happy, Drowsy, Peaceful"]
Sleep: [" 5.5"]
Hunger: [" 3"]
Coffee: [" 0"]
</code></p>

<p>Close... but still not perfect. I think the best thing to do would be to write some formatter objects or functions to handle the different kinds of metadata. We'll tackle that tomorrow.</p>

<ul>
<li>Time: 9:34pm</li>
<li>Mood: Fat, Tired, Drunk</li>
<li>Sleep: 6</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hacking the PATH variable in Sublime Text]]></title>
    <link href="http://robdodson.me/blog/2012/05/14/hacking-the-path-variable-in-sublime-text/"/>
    <updated>2012-05-14T20:26:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/14/hacking-the-path-variable-in-sublime-text</id>
    <content type="html"><![CDATA[<p>This is going to be a bit of a lightning post but I wanted to quickly show off how to edit the PATH variable that Sublime text uses. I should warn you that that I am neither an expert in Python nor am I a very seasoned Sublime user. So having said that take all of this with a grain of salt and use at your own risk.</p>

<h3>Our first (crappy) plugin!</h3>

<p>Sublime has a great plugin architecture that makes it extremely easy to add to the platform. If you create a <code>.py</code> file in the <code>~/Library/Application Support/Sublime Text 2/Packages/User/</code> folder it will be loaded as soon as Sublime starts. Writing plugins seems to be actually quite easy based on their <a href="http://www.sublimetext.com/docs/plugin-basics">documentation and examples.</a> We won't be following the typical plugin architecture since we're just trying to hack a system variable and that doesn't seem to necessitate the use of their built in modules.</p>

<p>Here's a script I'm calling <code>Pathway</code> at the moment.</p>

<p>```python
import os</p>

<p>LOCAL = '/usr/local/bin:/usr/local/sbin:'
HOME = '/Users/Rob'  ### !!! REPLACE WITH YOUR HOME PATH !!! ###
RVM = HOME + '/.rvm/bin:'</p>

<h1>Sublime's default path is</h1>

<h1>/usr/bin:/bin:/usr/sbin:/sbin</h1>

<p>os.environ['PATH'] += ':'
os.environ['PATH'] += LOCAL
os.environ['PATH'] += RVM</p>

<p>print 'PATH = ' + os.environ['PATH']
<code>``
If you add this file to the Sublime user's directory outlined above you should be able to hit cmd + \</code> to fire up the Sublime console which will print out our new PATH variable.</p>

<p>I would also recommend adding a shell plugin to Sublime. At the moment I use <a href="https://github.com/misfo/Shell-Turtlestein">Shell Turtlestein.</a>.</p>

<p>Now that I have my hacked path variable and my shell plugin I can check to see if RVM works. Using Shell Turtlestein you can hit <code>cmd-shift-c</code> to open a little console prompt. Typing <code>rvm current</code> returns our ruby version number and gemset. Nice! What's even nicer is this means I can now run Rake tasks from inside of Sublime!</p>

<p>I should point out if all you want to do is run Rake or Ant then there are already plugins for that sort of thing. My main effort in doing all this is to try to integrate the command line with Sublime a bit better. If <em>anyone</em> knows how to simply tell Sublime to use the path in my .bash_profile or .bashrc then I would gladly use that approach instead. But after crawling the forums for a while it looks like this is still a common problem with no good solution.</p>

<ul>
<li>Time: 8:26 pm</li>
<li>Mood: Happy, Peaceful, Hurried</li>
<li>Sleep: 7</li>
<li>Hunger: 6</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 6]]></title>
    <link href="http://robdodson.me/blog/2012/05/13/object-oriented-scraper-backed-with-tests-pt-6/"/>
    <updated>2012-05-13T07:52:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/13/object-oriented-scraper-backed-with-tests-pt-6</id>
    <content type="html"><![CDATA[<p>Yesterday we verified that our <code>Crawler</code> was able to hit a document and, given the right selector, pull down a list of words and their frequency on the page. We also created a custom exception to be used whenever the selector fails to pull down the right content. I'm going to repeat this process today with the <code>get_metadata_by_selector</code>. If there's time we'll try to output another file with our data, otherwise that'll be tomorrow's homeworkd :D</p>

<p>Let's take a moment to look at today's metadata to figure out what we'd like our output to reflect.</p>

<p><code>
- Time: 8:03 am
- Mood: Happy, Drowsy, Peaceful
- Sleep: 5.5
- Hunger: 3
- Coffee: 0
</code></p>

<p>That's the actual markdown that goes into the editor but it gets converted into a <code>ul</code>. I don't <em>think</em> you can pass a CSS class to markdown syntax otherwise I'd use one here. We could go back and wrap everything in regular HTML tags but since we know that our metadata is going to be the last ul per entry we'll just use that knowledge to build our selector. Obviously a more robust solution would use a CSS class so that might be a good refactoring for the future.</p>

<p>I figure for now we'll just parse the metadata into a Hash that'll look something like this:</p>

<p><code>
{
  datetime: 2012-05-13T08:03:00-07:00,
  mood: ['Happy', 'Drowsy', 'Peaceful'],
  sleep: 5.5,
  hunger: 3.0,
  coffee: 0.0
}
</code>
In the final iteration we'll toss all of our Metadata Hashes into an ordered Array so we can visualize them over time.</p>

<h3>Red, Green, Refactor</h3>

<p>Ok, time for a failing test. Let's make sure that our selector pulls something down and if it doesn't we should raise the custom <code>SelectionError</code> we defined yesterday. I'm already seeing some repetitive code in our Crawler so I'm refactoring it. Where we need to get a group of XML nodes from the document via selector I've created a private helper called <code>nodes_by_selector</code>. This is also where we'll raise our exception if nothing came back. I'm also cleaning up some of the word cruff from our public API so instead of <code>get_words_by_selector</code> it's not just <code>words_by_selector</code>. The same goes for our metadata method.</p>

<p>```ruby tentacles/lib/tentacles/crawler_rb
require 'open-uri'
require 'nokogiri'
require_relative 'selection_error'</p>

<p>module Tentacles
  class Crawler</p>

<pre><code>attr_reader :doc

def self.from_uri(uri)
  new(uri)
end

def initialize(uri)
  @uri = uri
  @doc = Nokogiri::HTML(open(@uri))
  @counts = Hash.new(0)
end

def words_by_selector(selector)
  nodes = nodes_by_selector(selector)
  nodes.each do |node|
    words = words_from_string(node.content)
    count_frequency(words)
  end

  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map { |word, count| "#{word}: #{count}"}
end

def metadata_by_selector(selector)
  nodes = nodes_by_selector(selector)
end
</code></pre>

<p>  private</p>

<pre><code>def nodes_by_selector(selector)
  nodes = doc.css(selector)
  raise Tentacles::SelectionError, 
    'The selector did not return an results!' if nodes.empty?
  nodes
end 

def words_from_string(string)
  string.downcase.scan(/[\w']+/)
end

def count_frequency(word_list)
  for word in word_list
    @counts[word] += 1
  end
  @counts
end
</code></pre>

<p>  end
end
<code>
Going back to the tests we need to refactor a bit for any place that's been broken. Immediately I saw that my `nodes_by_selector` method was not initially returning the nodes so I added that back in. The tests brought that to my attention before I had to do any potentially painful debugging. Beyond that we just need to fix up our method names:
</code>ruby tentacles/spec/crawler_spec.rb
require_relative '../lib/tentacles/crawler'
require 'fakeweb'</p>

<p>describe Tentacles::Crawler do</p>

<p>  before do</p>

<pre><code># Create a mock options object
@options = {
  uri: 'http://robdodson.me', 
  post_selector: '.entry-content',
  metadata_selector: '.personal-metadata'
}

# Create a mock web request
FakeWeb.register_uri(:get, @options[:uri],
                     :body =&gt; '&lt;div class="' + @options[:post_selector].delete(".") + 
                     '"&gt;Hello Hello Hello World World Foobar!&lt;/div&gt;')
</code></pre>

<p>  end</p>

<p>  describe "constructors" do</p>

<pre><code>describe "#from_uri" do
  it "should respond" do
    Tentacles::Crawler.should respond_to(:from_uri)
  end

  it "should return an instance" do
    crawler = Tentacles::Crawler.from_uri(@options[:uri])
    crawler.should be_an_instance_of(Tentacles::Crawler)
  end
end
</code></pre>

<p>  end</p>

<p>  describe "instances" do</p>

<pre><code>before do
  @crawler = Tentacles::Crawler.from_uri(@options[:uri])
end

subject { @crawler }

it { should respond_to(:words_by_selector) }
it { should respond_to(:metadata_by_selector) }

context "post-construct" do
  it "should have the right document" do
    @crawler.doc.content.should =~ /Hello Hello Hello World World Foobar!/
  end
end

describe "#words_by_selector" do
  it "should produce an Array of keywords" do
    expected_array = ['hello: 3', 'world: 2', 'foobar: 1']
    actual_array = @crawler.words_by_selector(@options[:post_selector])
    actual_array.should eq(expected_array)
  end

  it "should raise an exception if nothing was returned" do
    expect { @crawler.words_by_selector('some-gibberish-selector') }.to raise_error(Tentacles::SelectionError, 'The selector did not return an results!')  
  end
end

describe "#metadata_by_selector" do
  it "should raise an exception if nothing was returned" do
    expect { @crawler.metadata_by_selector('some-gibberish-selector') }.to raise_error(Tentacles::SelectionError, 'The selector did not return an results!')  
  end
end
</code></pre>

<p>  end
end
```</p>

<p>We've got a duplicate test in there where both <code>#words_by_selector</code> and <code>#metadata_by_selector</code> are checking that they both raise an exception if nothing comes down. Let's see if we can refactor those into an RSpec shared example. I'm not sure if this is a best practice or not but here's my implementation:</p>

<p>```ruby tentacles/spec/crawler_spec.rb
shared_examples_for "all selector methods" do
  describe "when selection has no nodes" do</p>

<pre><code>it "should raise an exception" do
  expect { @crawler.send(selector_method, 'some-gibberish-selector') }.to raise_error(Tentacles::SelectionError, 'The selector did not return an results!')  
end
</code></pre>

<p>  end
end</p>

<h3>...</h3>

<p>describe "#words_by_selector" do
  it_behaves_like "all selector methods" do</p>

<pre><code>let(:selector_method) { :words_by_selector }
</code></pre>

<p>  end</p>

<h1>...</h1>

<p>end</p>

<p>describe "#metadata_by_selector" do
  it_behaves_like "all selector methods" do</p>

<pre><code>let(:selector_method) { :metadata_by_selector }
</code></pre>

<p>  end
end
```</p>

<p>Basically we're putting our method name as a symbol into a variable using <code>let</code> and then calling that method in the shared_examples_for block. Notice how we're using <code>@crawler.send(selector_method, ...)</code>? In this case <code>selector_method</code> refers to our method name symbol.</p>

<p>If you run this in RSpec's nested mode it looks pretty cool:</p>

<p>```ruby
Tentacles::Crawler
  constructors</p>

<pre><code>#from_uri
  should respond
  should return an instance
</code></pre>

<p>  instances</p>

<pre><code>should respond to #words_by_selector
should respond to #metadata_by_selector
post-construct
  should have the right document
#words_by_selector
  should produce an Array of keywords
  behaves like all selector methods
    when selection has no nodes
      should raise an exception
#metadata_by_selector
  behaves like all selector methods
    when selection has no nodes
      should raise an exception
</code></pre>

<p>```</p>

<p>Ok, so we know that all of our selector methods raise the proper exception if they are called with a bunk selector. Now let's make sure we can get our metadata downloaded and structured.</p>

<p>Unfortunately I'm realizing that if the <code>ul</code> for our metadata is part of the post then those words get counted along with everything else, which is not what I want. I need to figure out how to exclude that content...</p>

<p>I could either tell my crawler to explicitly ignore that content or wrap my blog entry in an even more specific class and just select that. I guess that'll be an exercise for tomorrow :\</p>

<ul>
<li>Time: 8:03 am</li>
<li>Mood: Happy, Drowsy, Peaceful</li>
<li>Sleep: 5.5</li>
<li>Hunger: 3</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 5]]></title>
    <link href="http://robdodson.me/blog/2012/05/12/object-oriented-scraper-backed-with-tests-pt-5/"/>
    <updated>2012-05-12T07:02:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/12/object-oriented-scraper-backed-with-tests-pt-5</id>
    <content type="html"><![CDATA[<p>Last night I got the <code>Crawler</code> passing its test for <code>#get_words_by_selector</code>. This morning I realize that when someone sends in a junk selector I want to raise an exception of some kind. Since I don't know much about Ruby Exceptions I'm doing a little digging...Ruby has both <code>throw</code>/<code>catch</code> and <code>raise</code>/<code>rescue</code> so what's the difference between throw/catch and raise/rescue in Ruby?</p>

<h3>Throwing exceptions for control flow</h3>

<p>There's a great guest post by Avdi Grimm on <a href="http://rubylearning.com/blog/2011/07/12/throw-catch-raise-rescue-im-so-confused/">RubyLearning</a> which covers this topic in depth. To summarize <code>throw</code>/<code>catch</code> is mainly used when doing <em>exceptions as control flow</em>. In other words, if you need to break out of a deeply nested loop or some other expensive operation you can throw an exception symbol which can be caught someone high up the call stack. Initially this rubbed me the wrong way since I know that things like <code>goto</code> and <code>labels</code> are a bad practice. Someone else raised this point in the comments to which Avid responded:</p>

<blockquote><p>There is a fundamental difference between throw/catch and goto. Goto, in languages which support it, pays no attention to the stack. Any resources which were allocated before the goto are simply left dangling unless they are manually cleaned up.</p>

<p>throw/catch, like exception handling, unwinds the stack, triggering ensure blocks along the way. So, for example, if you throw inside an open() {…} block, the open file will be closed on the way up to the catch() block.</p></blockquote>

<h3>Raising exceptions for everything else</h3>

<p>With <code>throw</code>/<code>catch</code> out of the way that leaves <code>raise</code>/<code>rescue</code> to handle everything else. I'm willing to bet that 99% of error code should probably be raising exceptions and throw/catch should only be used in situations where you need the control flow behavior. With that knowledge in hand I need to decide between one of Ruby's built-in Exceptions or defining one of my own. Let's define one of our own so we can get that experience under our belt.</p>

<h3>Creating an exception subclass in Ruby</h3>

<p>One tip I picked up while doing my research into <code>raise</code> and <code>throw</code> is that any exception that doesn't subclass StandardError will not be caught by default. Here's an example to illustrate:</p>

<p>```ruby</p>

<h2>#</h2>

<h1>First we define an exception class which doesn't</h1>

<h1>inherit from StandardError. As a result it won't</h1>

<h1>be caught by a simple rescue. Instead we would</h1>

<h1>need to rescue by its class name</h1>

<h2>#</h2>

<p>class MyBadException &lt; Exception
end</p>

<p>def miss_bad_exception
  raise MyBadException.new
  rescue
  p "I'll never be called :("
end</p>

<p>miss_bad_exception
MyBadException: MyBadException
  from (irb):4:in <code>miss_bad_exception'
  from (irb):8
  from /Users/Rob/.rvm/rubies/ruby-1.9.3-p125/bin/irb:16:in</code><main></p>

<h1>See that calling the method produces an uncaught exception...</h1>

<h2>#</h2>

<h1>Next we'll subclass StandardError. As a result</h1>

<h1>we won't have to explicitly define our class name</h1>

<h1>for a rescue to work.</h1>

<h2>#</h2>

<p>class MyGoodException &lt; StandardError
end</p>

<p>def save_good_exception
  raise MyGoodException.new
  rescue
  p "I'm saved! My hero!"
end</p>

<p>save_good_exception
"I'm saved! My hero!"</p>

<h1>Yay! Our exception was caught!</h1>

<p><code>``
We'll call our Exception</code>SelectorError` to indicate that the provided selector did not return any results. For reference I often refer to <a href="http://rubylearning.com/satishtalim/ruby_exceptions.html">this chart on RubyLearning</a> when I want to see a list of all the available Exception classes. In our case we'll just inherit from StandardError.</p>

<p><code>ruby tentacles/lib/selection_error.rb
module Tentacles
  class SelectionError &lt; StandardError
  end
end
</code>
I don't think we actually need to do much more than that. The ability to pass a payload message should come from the super class so I think we're good to go. Here's our updated spec:</p>

<p>```ruby
it "should raise an exception if nothing was returned" do</p>

<pre><code>    expect { @crawler.get_words_by_selector('some-gibberish-selector') }.to raise_error(Tentacles::SelectionError, 'The selector did not return an results!')  
</code></pre>

<p>end
<code>``      
Initially the test fails so now we need to update our</code>Crawler` to check if nothing was returned and raise the custom exception.</p>

<p>Here's our updated <code>Crawler</code> with additional require and updated method.</p>

<p>```ruby tentacles/lib/crawler.rb
require 'open-uri'
require 'nokogiri'
require_relative 'selection_error'</p>

<p>module Tentacles
  class Crawler</p>

<pre><code>attr_reader :doc

def self.from_uri(uri)
  new(uri)
end

def initialize(uri)
  @uri = uri
  @doc = Nokogiri::HTML(open(@uri))
  @counts = Hash.new(0)
end

def get_words_by_selector(selector)
  entries = doc.css(selector)
  raise Tentacles::SelectionError, 
    'The selector did not return an results!' if entries.empty?
  entries.each do |entry|
    words = words_from_string(entry.content)
    count_frequency(words)
  end

  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map { |word, count| "#{word}: #{count}"}
end

def get_metadata_by_selector(selector)
  # TODO
end
</code></pre>

<p>  private</p>

<pre><code>def words_from_string(string)
  string.downcase.scan(/[\w']+/)
end

def count_frequency(word_list)
  for word in word_list
    @counts[word] += 1
  end
  @counts
end
</code></pre>

<p>  end
end
```</p>

<p>All tests passing, we're good to go :)</p>

<ul>
<li>Time: 7:00 am</li>
<li>Mood: Alert, Awake, Anxious</li>
<li>Sleep: 8</li>
<li>Hunger: 3</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 4]]></title>
    <link href="http://robdodson.me/blog/2012/05/11/object-oriented-scraper-backed-with-tests-pt-4/"/>
    <updated>2012-05-11T07:20:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/11/object-oriented-scraper-backed-with-tests-pt-4</id>
    <content type="html"><![CDATA[<p>Continuing from our <a href="http://robdodson.me/blog/2012/05/08/object-oriented-scraper-backed-with-tests-pt-3/">previous post</a> we're going to keep working on our <code>Crawler</code> and our specs to see if we can start pulling real data from our site.</p>

<p>The first thing I did this morning was to run my tests:
```
bundle exec rspec spec/</p>

<p>..............</p>

<p>Finished in 0.01271 seconds
14 examples, 0 failures
```
As someone totally new to TDD/BDD this is kind of an awesome feeling. I left my code for a few days and now I can come back and verify that everything still works. We can take it even further and run rspec with a documentation formatter to get some pretty printed output:</p>

<p>```ruby
bundle exec rspec spec/ -cf d</p>

<p>Tentacles::Crawler
  constructors</p>

<pre><code>#from_uri
  should respond
  should return an instance
</code></pre>

<p>  instances</p>

<pre><code>should respond to #get_words_by_selector
should respond to #get_metadata_by_selector
</code></pre>

<p>Tentacles::Options
  should respond to #uri
  should respond to #post_selector
  should respond to #metadata_selector
  #initialize</p>

<pre><code>when parsing the URI
  when URI is valid
    should display the right URI
  when URI is invalid
    should raise an exception
  when URI does not contain a scheme
    should raise an IO exception
  when URI does not contain a host
    should raise an IO exception
</code></pre>

<p>Tentacles::Runner
  should respond to #run
  when parsing the config file</p>

<pre><code>should raise an error if the config file is missing
should raise an error if the config file is invalid
</code></pre>

<p>Finished in 0.01359 seconds
14 examples, 0 failures
```</p>

<p>In rspec the <code>-c</code> flag enables color in the output. The <code>-f</code> flag sets a formatter and <code>d</code> specifies the documentation format.</p>

<p>```bash
-f, --format FORMATTER           Choose a formatter.</p>

<pre><code>                                   [p]rogress (default - dots)
                                   [d]ocumentation (group and example names)
                                   [h]tml
                                   [t]extmate
                                   custom formatter class name
</code></pre>

<p>```</p>

<p>Neat.</p>

<p>In <code>crawler_spec.rb</code> I'm going to add a test that checks to see if our instance has actually stored the content from our mocked web request.</p>

<p>```ruby
require_relative '../lib/tentacles/crawler'
require 'fakeweb'</p>

<p>describe Tentacles::Crawler do</p>

<p>  before do</p>

<pre><code># Create a mock options object
@options = {
  uri: 'http://robdodson.me', 
  post_selector: '.entry-content',
  metadata_selector: '.personal-metadata'
}

# Create a mock web request
FakeWeb.register_uri(:get, @options[:uri], :body =&gt; "Hello World! Hello San Francisco!")
</code></pre>

<p>  end</p>

<p>  describe "constructors" do</p>

<pre><code>describe "#from_uri" do
  it "should respond" do
    Tentacles::Crawler.should respond_to(:from_uri)
  end

  it "should return an instance" do
    crawler = Tentacles::Crawler.from_uri(@options[:uri])
    crawler.should be_an_instance_of(Tentacles::Crawler)
  end
end
</code></pre>

<p>  end</p>

<p>  describe "instances" do</p>

<pre><code>before do
  @crawler = Tentacles::Crawler.from_uri(@options[:uri])
end

subject { @crawler }

it { should respond_to(:get_words_by_selector) }
it { should respond_to(:get_metadata_by_selector) }

context "post-construct" do
  it "should have the right document" do
    @crawler.doc.content.should =~ /Hello World! Hello San Francisco!/
  end
end
</code></pre>

<p>  end
end
```</p>

<p>I want to write a test to parse the content for keywords but I realize now that our FakeWeb request returns a string without any classes or id's. Gotta go back and wrap it in some HTML to match our selectors. So I'm changing the mock web request to look like this:</p>

<p>```ruby</p>

<h1>Create a mock web request</h1>

<pre><code>FakeWeb.register_uri(:get, @options[:uri],
                     :body =&gt; '&lt;div class="' + @options[:post_selector] + '"&gt;Hello World! Hello San Francisco!&lt;/div&gt;')
</code></pre>

<p>```</p>

<h3>Hello Hello Hello World!</h3>

<p>After a lot of back and forth I finally get my test to pass. I realize along the way that there are a bunch of things I need to change. For starters having most of my words be the same count doesn't really help me to validate that my keyword counting is working all that well. So I'm changing our FakeWeb request and the subsequent specs which test against it.</p>

<p>```ruby</p>

<h1>Create a mock web request</h1>

<pre><code>FakeWeb.register_uri(:get, @options[:uri],
                     :body =&gt; '&lt;div class="' + @options[:post_selector].delete(".") + '"&gt;Hello Hello Hello World World Foobar!&lt;/div&gt;')
</code></pre>

<p>```</p>

<p>```ruby</p>

<pre><code>context "post-construct" do
  it "should have the right document" do
    @crawler.doc.content.should =~ /Hello Hello Hello World World Foobar!/
  end
end
</code></pre>

<p>```</p>

<p>Next I need to make sure that my <code>get_words_by_selector</code> method is accepting a selector.</p>

<p>```ruby
def get_words_by_selector(selector)</p>

<pre><code>  entries = doc.css('div.entry-content')
  entries.each do |entry|
    words = words_from_string(entry.content)
    count_frequency(words)
  end

  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map { |word, count| "#{word}: #{count}"}
end
</code></pre>

<p>```</p>

<p>I also realize that I'd like my Array of keywords to be in desceding order so I <code>reverse</code> it after the initial sort.</p>

<p>Next I'm going to write the test to verify that we've received a group of words, counted them up and tossed them into an Array in descending order:</p>

<p>```ruby</p>

<pre><code>describe "#get_words_by_selector" do
  it "should produce an Array of keywords" do
    expected_array = ['hello: 3', 'world: 2', 'foobar: 1']
    actual_array = @crawler.get_words_by_selector(@options[:post_selector])
    actual_array.should eq(expected_array)
  end
end
</code></pre>

<p>```</p>

<p>I actually wrote the test first and did everything else to make it pass. But at this point it should all be passing and we can verify that given a request with the appropriate selector we should be able to build a basic word frequency list. Yay!</p>

<ul>
<li>Time: 7:35 am</li>
<li>Mood: Calm, Awake, Curious</li>
<li>Sleep: 7</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
</feed>
