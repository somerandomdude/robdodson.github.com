<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: BDD | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/bdd/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-05-11T22:01:05-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 4]]></title>
    <link href="http://robdodson.me/blog/2012/05/11/object-oriented-scraper-backed-with-tests-pt-4/"/>
    <updated>2012-05-11T07:20:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/11/object-oriented-scraper-backed-with-tests-pt-4</id>
    <content type="html"><![CDATA[<p>Continuing from our <a href="http://robdodson.me/blog/2012/05/08/object-oriented-scraper-backed-with-tests-pt-3/">previous post</a> we're going to keep working on our <code>Crawler</code> and our specs to see if we can start pulling real data from our site.</p>

<p>The first thing I did this morning was to run my tests:
```
bundle exec rspec spec/</p>

<p>..............</p>

<p>Finished in 0.01271 seconds
14 examples, 0 failures
```
As someone totally new to TDD/BDD this is kind of an awesome feeling. I left my code for a few days and now I can come back and verify that everything still works. We can take it even further and run rspec with a documentation formatter to get some pretty printed output:</p>

<p>```ruby
bundle exec rspec spec/ -cf d</p>

<p>Tentacles::Crawler
  constructors</p>

<pre><code>#from_uri
  should respond
  should return an instance
</code></pre>

<p>  instances</p>

<pre><code>should respond to #get_words_by_selector
should respond to #get_metadata_by_selector
</code></pre>

<p>Tentacles::Options
  should respond to #uri
  should respond to #post_selector
  should respond to #metadata_selector
  #initialize</p>

<pre><code>when parsing the URI
  when URI is valid
    should display the right URI
  when URI is invalid
    should raise an exception
  when URI does not contain a scheme
    should raise an IO exception
  when URI does not contain a host
    should raise an IO exception
</code></pre>

<p>Tentacles::Runner
  should respond to #run
  when parsing the config file</p>

<pre><code>should raise an error if the config file is missing
should raise an error if the config file is invalid
</code></pre>

<p>Finished in 0.01359 seconds
14 examples, 0 failures
```</p>

<p>In rspec the <code>-c</code> flag enables color in the output. The <code>-f</code> flag sets a formatter and <code>d</code> specifies the documentation format.</p>

<p>```bash
-f, --format FORMATTER           Choose a formatter.</p>

<pre><code>                                   [p]rogress (default - dots)
                                   [d]ocumentation (group and example names)
                                   [h]tml
                                   [t]extmate
                                   custom formatter class name
</code></pre>

<p>```</p>

<p>Neat.</p>

<p>In <code>crawler_spec.rb</code> I'm going to add a test that checks to see if our instance has actually stored the content from our mocked web request.</p>

<p>```ruby
require_relative '../lib/tentacles/crawler'
require 'fakeweb'</p>

<p>describe Tentacles::Crawler do</p>

<p>  before do</p>

<pre><code># Create a mock options object
@options = {
  uri: 'http://robdodson.me', 
  post_selector: '.entry-content',
  metadata_selector: '.personal-metadata'
}

# Create a mock web request
FakeWeb.register_uri(:get, @options[:uri], :body =&gt; "Hello World! Hello San Francisco!")
</code></pre>

<p>  end</p>

<p>  describe "constructors" do</p>

<pre><code>describe "#from_uri" do
  it "should respond" do
    Tentacles::Crawler.should respond_to(:from_uri)
  end

  it "should return an instance" do
    crawler = Tentacles::Crawler.from_uri(@options[:uri])
    crawler.should be_an_instance_of(Tentacles::Crawler)
  end
end
</code></pre>

<p>  end</p>

<p>  describe "instances" do</p>

<pre><code>before do
  @crawler = Tentacles::Crawler.from_uri(@options[:uri])
end

subject { @crawler }

it { should respond_to(:get_words_by_selector) }
it { should respond_to(:get_metadata_by_selector) }

context "post-construct" do
  it "should have the right document" do
    @crawler.doc.content.should =~ /Hello World! Hello San Francisco!/
  end
end
</code></pre>

<p>  end
end
```</p>

<p>I want to write a test to parse the content for keywords but I realize now that our FakeWeb request returns a string without any classes or id's. Gotta go back and wrap it in some HTML to match our selectors. So I'm changing the mock web request to look like this:</p>

<p>```ruby</p>

<h1>Create a mock web request</h1>

<pre><code>FakeWeb.register_uri(:get, @options[:uri],
                     :body =&gt; '&lt;div class="' + @options[:post_selector] + '"&gt;Hello World! Hello San Francisco!&lt;/div&gt;')
</code></pre>

<p>```</p>

<h3>Hello Hello Hello World!</h3>

<p>After a lot of back and forth I finally get my test to pass. I realize along the way that there are a bunch of things I need to change. For starters having most of my words be the same count doesn't really help me to validate that my keyword counting is working all that well. So I'm changing our FakeWeb request and the subsequent specs which test against it.</p>

<p>```ruby</p>

<h1>Create a mock web request</h1>

<pre><code>FakeWeb.register_uri(:get, @options[:uri],
                     :body =&gt; '&lt;div class="' + @options[:post_selector].delete(".") + '"&gt;Hello Hello Hello World World Foobar!&lt;/div&gt;')
</code></pre>

<p>```</p>

<p>```ruby</p>

<pre><code>context "post-construct" do
  it "should have the right document" do
    @crawler.doc.content.should =~ /Hello Hello Hello World World Foobar!/
  end
end
</code></pre>

<p>```</p>

<p>Next I need to make sure that my <code>get_words_by_selector</code> method is accepting a selector.</p>

<p>```ruby
def get_words_by_selector(selector)</p>

<pre><code>  entries = doc.css('div.entry-content')
  entries.each do |entry|
    words = words_from_string(entry.content)
    count_frequency(words)
  end

  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map { |word, count| "#{word}: #{count}"}
end
</code></pre>

<p>```</p>

<p>I also realize that I'd like my Array of keywords to be in desceding order so I <code>reverse</code> it after the initial sort.</p>

<p>Next I'm going to write the test to verify that we've received a group of words, counted them up and tossed them into an Array in descending order:</p>

<p>```ruby</p>

<pre><code>describe "#get_words_by_selector" do
  it "should produce an Array of keywords" do
    expected_array = ['hello: 3', 'world: 2', 'foobar: 1']
    actual_array = @crawler.get_words_by_selector(@options[:post_selector])
    actual_array.should eq(expected_array)
  end
end
</code></pre>

<p>```</p>

<p>I actually wrote the test first and did everything else to make it pass. But at this point it should all be passing and we can verify that given a request with the appropriate selector we should be able to build a basic word frequency list. Yay!</p>

<ul>
<li>Time: 7:35 am</li>
<li>Mood: Calm, Awake, Curious</li>
<li>Sleep: 7</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
</feed>
