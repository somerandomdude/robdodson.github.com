<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Express | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/express/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-08-11T08:52:22-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building a Countdown Timer with Socket.io pt. 3]]></title>
    <link href="http://robdodson.me/blog/2012/06/07/building-a-countdown-timer-with-socket-dot-io-pt-3/"/>
    <updated>2012-06-07T19:41:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/07/building-a-countdown-timer-with-socket-dot-io-pt-3</id>
    <content type="html"><![CDATA[<p>Today's the day we wrap up our countdown timer and deploy it to Heroku. But before we launch this puppy we need to clean house a little and spice up the visual appeal.</p>

<h3>Refactoring the Stopwatch</h3>

<p>While the Stopwatch from our last post worked OK there are a spots that can be improved. For starters I'd like to separate the formatting of the time from the <code>onTick</code> method. Mainly because I want to be able to pull the current time out whenever someone hits reset or a new connection is made. Here's how I updated Stopwatch to accomodate these changes:</p>

<p>``` js modles/stopwatch.js
var util    = require('util'),</p>

<pre><code>events  = require('events')
_       = require('underscore');
</code></pre>

<p>// ---------------------------------------------
// Constructor
// ---------------------------------------------
function Stopwatch() {</p>

<pre><code>if(false === (this instanceof Stopwatch)) {
    return new Stopwatch();
}

this.hour = 3600000;
this.minute = 60000;
this.second = 1000;
this.time = this.hour;
this.interval = undefined;

events.EventEmitter.call(this);

// Use Underscore to bind all of our methods
// to the proper context
_.bindAll(this);
</code></pre>

<p>};</p>

<p>// ---------------------------------------------
// Inherit from EventEmitter
// ---------------------------------------------
util.inherits(Stopwatch, events.EventEmitter);</p>

<p>// ---------------------------------------------
// Methods
// ---------------------------------------------
Stopwatch.prototype.start = function() {</p>

<pre><code>if (this.interval) {
    return;
}

console.log('Starting Stopwatch!');
// note the use of _.bindAll in the constructor
// with bindAll we can pass one of our methods to
// setInterval and have it called with the proper 'this' value
this.interval = setInterval(this.onTick, this.second);
this.emit('start:stopwatch');
</code></pre>

<p>};</p>

<p>Stopwatch.prototype.stop = function() {</p>

<pre><code>console.log('Stopping Stopwatch!');
if (this.interval) {
    clearInterval(this.interval);
    this.interval = undefined;
    this.emit('stop:stopwatch');
}
</code></pre>

<p>};</p>

<p>Stopwatch.prototype.reset = function() {</p>

<pre><code>console.log('Resetting Stopwatch!');
this.time = this.hour;
this.emit('reset:stopwatch', this.formatTime(this.time));
</code></pre>

<p>};</p>

<p>Stopwatch.prototype.onTick = function() {</p>

<pre><code>this.time -= this.second;

var formattedTime = this.formatTime(this.time);
this.emit('tick:stopwatch', formattedTime);

if (this.time === 0) {
    this.stop();
}
</code></pre>

<p>};</p>

<p>Stopwatch.prototype.formatTime = function(time) {</p>

<pre><code>var remainder = time,
    numHours,
    numMinutes,
    numSeconds,
    output = "";

numHours = String(parseInt(remainder / this.hour, 10));
remainder -= this.hour * numHours;

numMinutes = String(parseInt(remainder / this.minute, 10));
remainder -= this.minute * numMinutes;

numSeconds = String(parseInt(remainder / this.second, 10));

output = _.map([numHours, numMinutes, numSeconds], function(str) {
    if (str.length === 1) {
        str = "0" + str;
    }
    return str;
}).join(":");

return output;
</code></pre>

<p>};</p>

<p>Stopwatch.prototype.getTime = function() {</p>

<pre><code>return this.formatTime(this.time);
</code></pre>

<p>};</p>

<p>// ---------------------------------------------
// Export
// ---------------------------------------------
module.exports = Stopwatch;
```</p>

<p>I also namespaced the events so they would be easier to read when mixed in with the socket.io events. During the refactoring I noticed there were a lot of actors listening to, emitting or calling something like <code>start</code>. I'm not sure if there are common socket.io namespacing patterns but I based what I did on Backbone events and I think it works out well enough.</p>

<h3>Cleaning up app.js</h3>

<p>These changes to <code>Stopwatch</code> also require us to update the <code>app.js</code> that uses it.</p>

<p>``` js app.js
var stopwatch = new Stopwatch();
stopwatch.on('tick:stopwatch', function(time) {
  io.sockets.emit('time', { time: time });
});</p>

<p>stopwatch.on('reset:stopwatch', function(time) {
  io.sockets.emit('time', { time: time });
});</p>

<p>stopwatch.start();</p>

<p>io.sockets.on('connection', function (socket) {
  io.sockets.emit('time', { time: stopwatch.getTime() });</p>

<p>  socket.on('click:start', function () {</p>

<pre><code>stopwatch.start();
</code></pre>

<p>  });</p>

<p>  socket.on('click:stop', function () {</p>

<pre><code>stopwatch.stop();
</code></pre>

<p>  });</p>

<p>  socket.on('click:reset', function () {</p>

<pre><code>stopwatch.reset();
</code></pre>

<p>  });
});
```</p>

<p>I've made it so whenever a user resets or connects to the page they get the latest time. And of course whenever the stopwatch ticks they'll get an update as well. I think it might also be nice if pressing start dispatched the latest time, I should probably add that... ;)</p>

<h3>Tweaking the views</h3>

<p>Lastly I've updated the view by adding some more buttons to correspond to the start/stop and reset methods. I've also wrapped everything in a container to make it easier to position:</p>

<p>``` html views/index.ejs</p>

<div id="wrapper">
    <div id="countdown"></div>
    <button id="start" class="thoughtbot">Start</button>
    <button id="stop" class="thoughtbot">Stop</button>
    <button id="reset" class="thoughtbot">Reset</button>
</div>


<p><code>
</code> js public/js/main.js
var socket = io.connect(window.location.hostname);</p>

<p>socket.on('time', function (data) {</p>

<pre><code>$('#countdown').html(data.time);
</code></pre>

<p>});</p>

<p>$('#start').click(function() {</p>

<pre><code>socket.emit('click:start');
</code></pre>

<p>});</p>

<p>$('#stop').click(function() {</p>

<pre><code>socket.emit('click:stop');
</code></pre>

<p>});</p>

<p>$('#reset').click(function() {</p>

<pre><code>socket.emit('click:reset');
</code></pre>

<p>});
```
Also notice that the socket events coming from the view have been namespaced as well.</p>

<h3>Improving the type</h3>

<p>Next up I want to enhance the type using <a href="http://www.google.com/webfonts">one of Google's webfonts.</a> I chose a font called <code>Black Ops One</code> which seemed appropriately militaristic. Setting it up was as easy as adding one line to my <code>layout.ejs</code></p>

<p><code>html views/layout.ejs
&lt;link href='http://fonts.googleapis.com/css?family=Black+Ops+One' rel='stylesheet' type='text/css'&gt;
</code></p>

<p>and my <code>main.css</code> file:</p>

<p>``` css public/css/main.css</p>

<h1>countdown {</h1>

<p>  font-family: 'Black Ops One', cursive;
  font-size: 90px;
}
<code>``
Finally I chose to use some funky buttons from [Chad Mazzola's CSS3 Buttons project.](https://github.com/ubuwaits/css3-buttons) I went with the Thoughtbot buttons since they were red and awesome. The styles are pretty long so I'm just going to post my entire</code>main.css` for you to see:</p>

<p>``` css public/css/main.css</p>

<h1>wrapper {</h1>

<p>  width: 475px;
  height: 171px;
  margin: 100px auto;
}</p>

<h1>countdown {</h1>

<p>  font-family: 'Black Ops One', cursive;
  font-size: 90px;
}</p>

<p>button.thoughtbot {
  background-color: #ee432e;
  background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #ee432e), color-stop(50%, #c63929), color-stop(50%, #b51700), color-stop(100%, #891100));
  background-image: -webkit-linear-gradient(top, #ee432e 0%, #c63929 50%, #b51700 50%, #891100 100%);
  background-image: -moz-linear-gradient(top, #ee432e 0%, #c63929 50%, #b51700 50%, #891100 100%);
  background-image: -ms-linear-gradient(top, #ee432e 0%, #c63929 50%, #b51700 50%, #891100 100%);
  background-image: -o-linear-gradient(top, #ee432e 0%, #c63929 50%, #b51700 50%, #891100 100%);
  background-image: linear-gradient(top, #ee432e 0%, #c63929 50%, #b51700 50%, #891100 100%);
  border: 1px solid #951100;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
  -webkit-box-shadow: inset 0px 0px 0px 1px rgba(255, 115, 100, 0.4), 0 1px 3px #333333;
  -moz-box-shadow: inset 0px 0px 0px 1px rgba(255, 115, 100, 0.4), 0 1px 3px #333333;
  box-shadow: inset 0px 0px 0px 1px rgba(255, 115, 100, 0.4), 0 1px 3px #333333;
  color: #fff;
  font: bold 20px "helvetica neue", helvetica, arial, sans-serif;
  line-height: 1;
  padding: 12px 0 14px 0;
  text-align: center;
  text-shadow: 0px -1px 1px rgba(0, 0, 0, 0.8);
  width: 150px;
}</p>

<p>button.thoughtbot:hover {
  background-color: #f37873;
  background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #f37873), color-stop(50%, #db504d), color-stop(50%, #cb0500), color-stop(100%, #a20601));
  background-image: -webkit-linear-gradient(top, #f37873 0%, #db504d 50%, #cb0500 50%, #a20601 100%);
  background-image: -moz-linear-gradient(top, #f37873 0%, #db504d 50%, #cb0500 50%, #a20601 100%);
  background-image: -ms-linear-gradient(top, #f37873 0%, #db504d 50%, #cb0500 50%, #a20601 100%);
  background-image: -o-linear-gradient(top, #f37873 0%, #db504d 50%, #cb0500 50%, #a20601 100%);
  background-image: linear-gradient(top, #f37873 0%, #db504d 50%, #cb0500 50%, #a20601 100%);
  cursor: pointer;
}</p>

<p>button.thoughtbot:active {
  background-color: #d43c28;
  background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #d43c28), color-stop(50%, #ad3224), color-stop(50%, #9c1500), color-stop(100%, #700d00));
  background-image: -webkit-linear-gradient(top, #d43c28 0%, #ad3224 50%, #9c1500 50%, #700d00 100%);
  background-image: -moz-linear-gradient(top, #d43c28 0%, #ad3224 50%, #9c1500 50%, #700d00 100%);
  background-image: -ms-linear-gradient(top, #d43c28 0%, #ad3224 50%, #9c1500 50%, #700d00 100%);
  background-image: -o-linear-gradient(top, #d43c28 0%, #ad3224 50%, #9c1500 50%, #700d00 100%);
  background-image: linear-gradient(top, #d43c28 0%, #ad3224 50%, #9c1500 50%, #700d00 100%);
  -webkit-box-shadow: inset 0px 0px 0px 1px rgba(255, 115, 100, 0.4);
  -moz-box-shadow: inset 0px 0px 0px 1px rgba(255, 115, 100, 0.4);
  box-shadow: inset 0px 0px 0px 1px rgba(255, 115, 100, 0.4);
}
```
<img class="center" src="https://s3.amazonaws.com/robdodson/images/defcon_final.png" title="'Defcon final'" ></p>

<p>SWEEEEEEET! I'll go ahead and host it on Heroku but first I have to find out what the cost of leaving Node.js/Socket.io running indefinitely would be. Till then you should be able to get a local version of all this working or <a href="https://github.com/robdodson/defcon">just clone the Github repo</a> and now you too can have your very own Defcon stopwatch. enjoy! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 7:41 pm</li>
<li>Mood: Tired, Lazy</li>
<li>Sleep: 6</li>
<li>Hunger: 3</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Countdown Timer with Socket.io pt. 2]]></title>
    <link href="http://robdodson.me/blog/2012/06/06/building-a-countdown-timer-with-socket-dot-io-pt-2/"/>
    <updated>2012-06-06T07:47:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/06/building-a-countdown-timer-with-socket-dot-io-pt-2</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/06/05/building-a-countdown-timer-with-socket-dot-io/">Continuing from yesterday's post</a> we started out with a rather crude timer and today I want to upgrade it to a full fledged model, <code>Stopwatch</code>, which dispatches events for the view to hook on to.</p>

<h3>Extend Node's EventEmitter</h3>

<p>We want to extend Node's EventEmitter object in order for our Stopwatch to dispatch its tick events. <a href="http://elegantcode.com/2011/02/21/taking-baby-steps-with-node-js-implementing-events/">Following this great article by Jan Van Ryswyck</a> I've arrived at something that looks like this:</p>

<p>``` js models/stopwatch.js
var util = require('util'),</p>

<pre><code>events = require('events');
</code></pre>

<p>function Stopwatch() {</p>

<pre><code>if(false === (this instanceof Stopwatch)) {
    return new Stopwatch();
}

events.EventEmitter.call(this);

var self = this;
setInterval(function() {
    self.emit('tick');
}, 1000);
</code></pre>

<p>};</p>

<p>util.inherits(Stopwatch, events.EventEmitter);
module.exports = Stopwatch;
```</p>

<p>In our app.js we'll need to <code>require</code> our new Stopwatch module, create an instance of it, and add a listener for the tick event. Here's the abbreviated version:</p>

<p>``` js app.js
var Stopwatch = require('./models/stopwatch');</p>

<p>...</p>

<p>var stopwatch = new Stopwatch();
stopwatch.on('tick', function() {
  console.log('stopwatch tick!');
});
```
If all goes well when you restart your server you should see 'stopwatch tick!' arriving every second.</p>

<h3>Add to the prototype the RIGHT way</h3>

<p>This next part is what tripped me up the other night and since it was rather late in the evening I was too out of it to figure out what was going wrong.</p>

<p>To recap, we've created a model called <code>Stopwatch</code>, we gave it a constructor function and we told it to extend <code>events.EventEmitter</code>.</p>

<p>Now I want to add a new method to my stopwatch but here's where you might run into a real gotcha. If you're like me you'd probably add it like this:</p>

<p>``` js models/stopwatch.js
var util = require('util'),</p>

<pre><code>events = require('events');
</code></pre>

<p>function Stopwatch() {</p>

<pre><code>if(false === (this instanceof Stopwatch)) {
    return new Stopwatch();
}

events.EventEmitter.call(this);
</code></pre>

<p>};</p>

<p>Stopwatch.prototype.foobar = function() {</p>

<pre><code>console.log('foobar!');
</code></pre>

<p>}</p>

<p>util.inherits(Stopwatch, events.EventEmitter);</p>

<p>module.exports = Stopwatch;
```</p>

<p>Aaaand your app would explode like this:</p>

<p><code>
[ERROR] TypeError
TypeError: Object #&lt;Stopwatch&gt; has no method 'foobar'
</code></p>

<p>That's because we can only add new methods <strong>after calling <code>util.inherits</code>.</strong> The proper way would look like this:</p>

<p>``` js models/stopwatch.js</p>

<p>var util = require('util'),</p>

<pre><code>events = require('events');
</code></pre>

<p>function Stopwatch() {</p>

<pre><code>if(false === (this instanceof Stopwatch)) {
    return new Stopwatch();
}

events.EventEmitter.call(this);
</code></pre>

<p>};</p>

<p>util.inherits(Stopwatch, events.EventEmitter);</p>

<p>Stopwatch.prototype.foobar = function() {</p>

<pre><code>console.log('foobar!');
</code></pre>

<p>}</p>

<p>module.exports = Stopwatch;</p>

<p>```</p>

<p>This is also the approach <a href="http://nodejs.org/api/util.html#util_util_inherits_constructor_superconstructor">taken in the documentation.</a> Guess it pays to rtfm :D</p>

<p>Here's what my final <code>Stopwatch</code> looks like:</p>

<p>``` js models/stopwatch.js
var util    = require('util'),</p>

<pre><code>events  = require('events')
_       = require('underscore');
</code></pre>

<p>// ---------------------------------------------
// Constructor
// ---------------------------------------------
function Stopwatch() {</p>

<pre><code>if(false === (this instanceof Stopwatch)) {
    return new Stopwatch();
}

this.hour = 3600000;
this.minute = 60000;
this.second = 1000;
this.time = this.hour;
this.interval = undefined;

events.EventEmitter.call(this);

// Use Underscore to bind all of our methods
// to the proper context
_.bindAll(this);
</code></pre>

<p>};</p>

<p>// ---------------------------------------------
// Inherit from EventEmitter
// ---------------------------------------------
util.inherits(Stopwatch, events.EventEmitter);</p>

<p>// ---------------------------------------------
// Methods
// ---------------------------------------------
Stopwatch.prototype.start = function() {</p>

<pre><code>console.log('Starting Stopwatch!');
// note the use of _.bindAll in the constructor
// with bindAll we can pass one of our methods to
// setInterval and have it called with the proper 'this' value
this.interval = setInterval(this.onTick, this.second);
this.emit('start');
</code></pre>

<p>};</p>

<p>Stopwatch.prototype.stop = function() {</p>

<pre><code>console.log('Stopping Stopwatch!');
if (this.interval) {
    clearInterval(this.interval);
    this.emit('stop');
}
</code></pre>

<p>};</p>

<p>Stopwatch.prototype.reset = function() {</p>

<pre><code>console.log('Resetting Stopwatch!');
this.time = this.hour;
this.emit('reset');
</code></pre>

<p>};</p>

<p>Stopwatch.prototype.onTick = function() {</p>

<pre><code>var remainder = this.time,
    numHours,
    numMinutes,
    numSeconds,
    output = "";

if (this.time === 0) {
    this.stop();
    return;
}

numHours = String(parseInt(remainder / this.hour, 10));
remainder -= this.hour * numHours;

numMinutes = String(parseInt(remainder / this.minute, 10));
remainder -= this.minute * numMinutes;

numSeconds = String(parseInt(remainder / this.second, 10));

output = _.map([numHours, numMinutes, numSeconds], function(str) {
    if (str.length === 1) {
        str = "0" + str;
    }
    return str;
}).join(":");

this.emit('tick', output);
this.time -= this.second;
</code></pre>

<p>};</p>

<p>// ---------------------------------------------
// Export
// ---------------------------------------------
module.exports = Stopwatch;
```</p>

<p>And here's how I'm using it in <code>app.js</code></p>

<p>``` js app.js
var Stopwatch = require('./models/stopwatch');</p>

<p>...</p>

<p>var stopwatch = new Stopwatch();
stopwatch.on('tick', function(time) {
  console.log('tick: ' + time);
});
stopwatch.start();
```</p>

<p>Running the above should give you something like this in your console:</p>

<p><code>
tick: 01:00:00
tick: 00:59:59
tick: 00:59:58
tick: 00:59:57
</code></p>

<p>Ok that's it for today. Tomorrow we'll connect all this goodness to a View. If you have questions or feedback feel free to leave a comment. Thanks! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 7:50 am</li>
<li>Mood: Tired</li>
<li>Sleep: 6</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Countdown Timer with Socket.io]]></title>
    <link href="http://robdodson.me/blog/2012/06/05/building-a-countdown-timer-with-socket-dot-io/"/>
    <updated>2012-06-05T08:07:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/05/building-a-countdown-timer-with-socket-dot-io</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/06/05/building-a-countdown-timer-with-socket-dot-io-pt-2/">Click here for part 2.</a></p>

<p>Yesterday I put together a very simple Node/Socket.io application and showed how to deploy it to Heroku. Today I'm going to keep going with that app to see if I can get the functionality that I want. The app is a basic stopwatch so that shouldn't be too hard. If you want to catch up <a href="http://robdodson.me/blog/2012/06/04/deploying-your-first-node-dot-js-and-socket-dot-io-app-to-heroku/">checkout yesterday's article</a> which explains setting everything up.</p>

<h3>Countdown</h3>

<p>Just to get the ball rolling I'm going to write a little code in my <code>app.js</code> file right at the bottom to setup a very crude counter.</p>

<p>``` js app.js<br/>
var countdown = 1000;
setInterval(function() {
  countdown--;
  io.sockets.emit('timer', { countdown: countdown });
}, 1000);</p>

<p>io.sockets.on('connection', function (socket) {
  socket.on('reset', function (data) {</p>

<pre><code>countdown = 1000;
io.sockets.emit('timer', { countdown: countdown });
</code></pre>

<p>  });
});
```</p>

<p>Elsewhere in my client-side js I'm going to listen for the <code>timer</code> event and update my DOM elements.</p>

<p>``` js main.js
var socket = io.connect(window.location.hostname);</p>

<p>socket.on('timer', function (data) {</p>

<pre><code>$('#counter').html(data.countdown);
</code></pre>

<p>});</p>

<p>$('#reset').click(function() {</p>

<pre><code>socket.emit('reset');
</code></pre>

<p>});
```</p>

<p>You'll also need to update your index.ejs file so it reads like this:</p>

<p>``` html views/index.ejs</p>

<div id="counter"></div>


<p><button id="reset">Reset!</button>
```</p>

<p>Every second we'll decrement our countdown variable and broadcast its new value. If a client sends us a <code>reset</code> event we'll restart the timer and immediately broadcast the update to anyone connected. I noticed that since I'm using <code>xhr-polling</code> it can sometimes take a while for the timer to show up in my browser so keep that in mind.</p>

<p>While this implementation isn't pretty it does get us a little bit further down the road. Unfortunately I've been tripped up by a bunch of Node's module issues so I have to cut tonight's post short :\</p>

<p>Hopefully better luck tomorrow. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 8:08 am</li>
<li>Mood: Sedate, Sleepy</li>
<li>Sleep: 5</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to use EJS in Express]]></title>
    <link href="http://robdodson.me/blog/2012/05/31/how-to-use-ejs-in-express/"/>
    <updated>2012-05-31T11:34:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/31/how-to-use-ejs-in-express</id>
    <content type="html"><![CDATA[<p>Here's a quick explanation of how to use EJS instead of Jade in your Express projects. This is super easy and covered well in the documentation but I wanted to put it here since that's what I worked on today :)</p>

<p>To start I'll create a new project from the command line:</p>

<p><code>
express foobar
cd foobar
npm install
</code></p>

<p>Now that I have my foobar project created I need to install <code>ejs</code>.</p>

<p><code>
npm install ejs
</code></p>

<p>If you're within your project directory this will place ejs in the <code>node_modules</code> dir. Let's also add it to our package.json.</p>

<p>```
{
  "name": "foobar",
  "version": "0.0.1",
  "private": true,
  "dependencies": {</p>

<pre><code>"express": "~2.5.8",
"ejs": "~0.7.1"
</code></pre>

<p>  }
}
<code>``
The tilde operator means that we require ejs verion 0.7.1 or greater but only up to the next major release. So the following are equivalent:</code>"~1.2" = ">=1.2.0 &lt;2.0.0"`. For a deeper explanation of package.json and NPM in general <a href="http://howtonode.org/introduction-to-npm">checkout this great post</a>.</p>

<h3>Leaving Jade for EJS</h3>

<p>If you're using the boilerplate that Express generates then it should be setup to use Jade as the rendering engine for its views. I think that Jade is cool but I need to baby step into Node/Express and make sure I understand everything that's going on instead of trying to consume so many different tools at once. With this in mind I decided to switch from Jade to EJS at least in the beginning because the syntax has no learning curve. To change your rendering engine you'll need to either add or edit the following call:</p>

<p><code>js
app.set('view engine', 'ejs');
</code></p>

<p>The boilerplate should have this set to <code>jade</code> inside of a configuration block. Once we've changed that line to read <code>ejs</code> we're ready to start writing some views.</p>

<h3>Setting up your layout</h3>

<p>By default Express' boilerplate will look for a file named layout in our views directory. Let's write one called <code>layout.ejs</code>:</p>

<p>``` html views/layout.ejs
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Pivotal Search&lt;/title&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;

&lt;!-- HTML5 shim, for IE6-8 support of HTML elements --&gt;
&lt;!--[if lt IE 9]&gt;
  &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;

&lt;!-- styles --&gt;
&lt;link href="stylesheets/style.css" rel="stylesheet"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;%- body %&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>This is all really straightforward with the exception of the <code>&lt;%- body %&gt;</code> line which basically works like a <code>yield</code> in erb. Whatever template we pass to Express' <code>response.render()</code> function will fill this dependency, here's an example:</p>

<p><code>js app.js
app.get('/', function(req, res) {
  res.render('index', { title: 'The index page!' })
});
</code></p>

<p>``` html views/index.ejs</p>

<div class="title">
    <%= title %>
</div>


<p>```
<img class="center" src="https://s3.amazonaws.com/robdodson/images/rendering_the_index_template.png" title="'Rendering the index template'" ></p>

<p>Furthermore we can use partials with Express and EJS like so:</p>

<p>``` html views/layout.ejs
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Pivotal Search&lt;/title&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;

&lt;!-- HTML5 shim, for IE6-8 support of HTML elements --&gt;
&lt;!--[if lt IE 9]&gt;
  &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;

&lt;!-- styles --&gt;
&lt;link href="stylesheets/style.css" rel="stylesheet"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;%- partial('header.ejs') %&gt;
&lt;%- body %&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` html views/header.ejs
<header></p>

<pre><code>My awesome header!
</code></pre>

<p></header></p>

<hr>


<p>```</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/rendering_the_header_partial.png" title="'Rendering the header partial'" ></p>

<p>And there ya go! Simple but hopefully useful if you're just getting started like I am :) - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 11:36 am</li>
<li>Mood: Eager, Alert</li>
<li>Sleep: 7</li>
<li>Hunger: 7</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mocking Requests with Mocha, Chai and Sinon]]></title>
    <link href="http://robdodson.me/blog/2012/05/28/mocking-requests-with-mocha-chai-and-sinon/"/>
    <updated>2012-05-28T11:20:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/28/mocking-requests-with-mocha-chai-and-sinon</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/05/27/testing-backbone-boilerplate-with-mocha-and-chai/">After a bit of a rocky start yesterday</a> I've finally got Mocha and Chai running in the browser which is great. Today I'd like to test out some of the async functionality of Mocha. This seems to be the big selling point for most people so we'll kick the tires a bit.</p>

<h3>Basic Async Tests with Mocha and Chai</h3>

<p>I wrote a little Node service that we'll consume for testing purposes. This is my first <a href="http://nodejs.org/">Node</a> and <a href="http://expressjs.com/">Express</a> app so apologies if it's lamesauce. I used the <code>express</code> command to boilerplate a project called <code>pickles</code> with some very basic routes:</p>

<p>``` js
// Routes</p>

<p>var count = 100;</p>

<p>app.get('/', function(req, res) {
  res.send('Welcome to the Pickle Store!');
});</p>

<p>app.get('/pickles', function(req, res) {
  res.json({</p>

<pre><code>count: count,
message: 'oh boy, ' + count + ' pickles!'
</code></pre>

<p>  });
});</p>

<p>app.get('/pickles/add/:num', function(req, res) {
  count += parseInt(req.params.num);
  res.json({</p>

<pre><code>add: req.params.num,
message: 'you added ' + req.params.num + ' pickles to the pickle barrel!'
</code></pre>

<p>  });
});</p>

<p>app.listen(3000, function(){
  console.log("Express server listening on port %d in %s mode", app.address().port, app.settings.env);
});
```
We'll need to make sure our node service is running for our tests to work and all of our URLs will point at localhost:3000. Obviously you wouldn't want this for a production setting but it'll be fine for demonstration purposes.</p>

<p>Here is our really simple Mocha spec. We're actually creating a <code>pickelStore</code> object in the spec file itself so we can test against it.</p>

<p>``` js test.pickles.js
var expect = chai.expect;</p>

<p>var pickleStore = {
  pickles: function() {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles',
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  },
  add: function(num) {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles/add/' + num,
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  }
};</p>

<p>describe('Pickle Store', function() {
  describe('#pickles', function() {</p>

<pre><code>pickleStore.pickles();
</code></pre>

<p>  });
});
```</p>

<p>I just want to see if the ajax methods will run and hit our Node service but I'm running into the following issue in Chrome:</p>

<p><code>
XMLHttpRequest cannot load http://localhost:3000/pickles. Origin null is not allowed by Access-Control-Allow-Origin.
</code>
Bummer... :(</p>

<p>OK, what's going on here... To StackOverflow! <a href="http://stackoverflow.com/questions/8456538/origin-null-is-not-allowed-by-access-control-allow-origin/8456586#8456586">Aaaand we have our response.</a> After a bit of googling I came across <a href="http://www.stoimen.com/blog/2010/11/19/diving-into-node-js-very-first-app/">this post</a> which mentions adding <code>res.header('Access-Control-Allow-Origin', '*');</code> to my Node responses. That does the trick. I also found <a href="http://www.stoimen.com/blog/2010/11/19/diving-into-node-js-very-first-app/">this post</a> which describes setting up <a href="https://developer.mozilla.org/en/http_access_control">CORS</a> with Express.</p>

<p>OK hopefully we're done with Node for now. I don't want this to turn into a node tutorial... Let's see if we can get the tests to perform using Mocha. We'll need some way to mock and spy on the ajax because I don't want to test the data coming from the actual service. I've realized I want to <em>simulate</em> the service for client-side Mocha tests. In a future tutorial I'll test the service itself using the Node aspect of Mocha. Kind of silly to lead off this way but whatever, moving on!</p>

<h3>Enter Sinon.js</h3>

<p>I'm going to use <a href="http://sinonjs.org/">Sinon.js</a> to help me mock, stub, fake, spy and do whatever the heck else I need to make sure my client code is solid. After downloading the js file for Sinon you can just add it to our test/index.html under the line where we added mocha.</p>

<p>``` html
<html>
<head>
  <meta charset="utf-8">
  <title>Mocha Tests</title>
  <link rel="stylesheet" href="mocha/mocha.css" />
  <script src="../assets/js/libs/jquery.js"></script>
  <script src="chai/chai.js"></script>
  <script src="mocha/mocha.js"></script>
  <script src="sinon/sinon.js"></script>
  <script>mocha.setup('bdd');</script>
  <script src="test.pickles.js"></script>
  <script></p>

<pre><code>$(function() {
  mocha.run();
})
</code></pre>

<p>  </script>
</head>
<body>
  <div id="mocha"></div>
</body>
</html>
```</p>

<p>Now we can use Sinon in our <code>test.pickles.js</code> file to get a handled on our ajax. Let's first test that an ajax call is made when we run the <code>pickles()</code> method of the <code>pickleStore</code> object. We'll make sure this first test fails, then we'll change the spec to make it pass.</p>

<p>``` js test.pickles.js
var expect = chai.expect;</p>

<p>var pickleStore = {
  pickles: function() {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles',
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  },
  add: function(num) {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles/add/' + num,
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  }
};</p>

<p>describe('Pickle Store', function() {
  describe('#pickles', function() {</p>

<pre><code>// Use Sinon to replace jQuery's ajax method
// with a spy.
beforeEach(function() {
  sinon.spy($, 'ajax');
});

// Restor jQuery's ajax method to its
// original state
afterEach(function() { 
  $.ajax.restore();
})

it('should make an ajax call', function(done) {
  pickleStore.pickles();
  expect($.ajax.calledOnce).to.be.false; // see if the spy WASN'T called
  done(); // let Mocha know we're done async testing
});
</code></pre>

<p>  });
});
```
<img class="center" src="https://s3.amazonaws.com/robdodson/images/first_failing_ajax_test.png" title="'Our first failing test with Mocha, Chai and Sinon. Yay!'" ></p>

<p>Changing this line <code>expect($.ajax.calledOnce).to.be.false;</code> from <code>false</code> to <code>true</code> should make our test pass. Yay, first async test in the bag! Next let's try to fake a response from the server. But I'm realizing that the succesful server response should <em>do</em> something to my pickleStore object, otherwise why do I care about the data? So I'm going to update pickelStore with the following success callback on its pickles method:</p>

<p>``` js test.pickles.js
var pickleStore = {
  count: 0,
  status: '',
  pickles: function() {</p>

<pre><code>var self = this;
$.ajax({
  url: 'http://localhost:3000/pickles',
  dataType: 'json',
  success: function(data) {
    self.count = parseInt(data.count);
    self.status = data.status;
  }
});
</code></pre>

<p>  },
  add: function(num) {</p>

<pre><code>$.ajax({
  url: 'http://localhost:3000/pickles/add/' + num,
  dataType: 'json',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>

<p>  }
};</p>

<p>... .
```</p>

<p>Now we can test what happens after the server sends a succesful response. But how do we get that response and how do we force the success callback? For that we'll need to use Sinon's <code>stub.yieldsTo</code> method. It's mentioned in <a href="http://sinonjs.org/docs/#stubs">the docs on this page</a> if you scroll down. <code>yieldsTo</code> lets us direct the path of our spy so it will not only pretend to be jQuery's <code>ajax</code> method, but it will also force itself into the <code>success</code> callback with an optional hash of parameters which simulate our service response. Sweet! We'll have to revise the <code>beforeEach</code> in our spec though otherwise Sinon will complain that we're wrapping <code>ajax</code> twice. The updated spec should look like this. Again, take note that we're going to make it fail first by expecting a count of 99 pickles instead of 100.</p>

<p>``` js test.pickles.js
... .</p>

<p>describe('Pickle Store', function() {
  describe('#pickles', function() {</p>

<pre><code>// Use Sinon to replace jQuery's ajax method
// with a spy. This spy will also come with
// some success data.
beforeEach(function() {
  sinon.stub($, 'ajax').yieldsTo('success', {
    count: '100',
    message: 'oh boy, 100 pickles!'
  });
});

// Restor jQuery's ajax method to its
// original state
afterEach(function() { 
  $.ajax.restore();
})

it('should make an ajax call', function(done) {
  pickleStore.pickles();
  expect($.ajax.calledOnce).to.be.true;
  done();
});

it('should update the count', function(done) {      
  pickleStore.pickles();
  expect(pickleStore.count).to.equal(99);
  done();
});
</code></pre>

<p>  });
});
```</p>

<p>Failing as expected. Aaaaand we change the expected count to 100, voila! Passing tests again!</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/passing_yield_test.png" title="'Passing test with Sinon's yieldTo'" ></p>

<p>I'm adding the test for the status update as well so our final <code>#pickles</code> spec should look like this:</p>

<p>``` js test.pickles.js
describe('Pickle Store', function() {
  describe('#pickles', function() {</p>

<pre><code>// Use Sinon to replace jQuery's ajax method
// with a spy. This spy will also come with
// some success data.
beforeEach(function() {
  sinon.stub($, 'ajax').yieldsTo('success', {
    count: '100',
    message: 'oh boy, 100 pickles!'
  });
});

// Restor jQuery's ajax method to its
// original state
afterEach(function() { 
  $.ajax.restore();
})

it('should make an ajax call', function(done) {
  pickleStore.pickles();
  expect($.ajax.calledOnce).to.be.true;
  done();
});

it('should update the count', function(done) {      
  pickleStore.pickles();
  expect(pickleStore.count).to.equal(100);
  done();
});

it('should update the status', function(done) {      
  pickleStore.pickles();
  expect(pickleStore.status).to.equal('oh boy, 100 pickles!');
  done();
});
</code></pre>

<p>  });
});
```</p>

<p>Now let's test the <code>#add</code> method before calling it a day. This method is interesting because all it can really do is update our status message. However, once it's called the value returned by <code>pickles()</code> should have incremented by whatever amount was passed to <code>add()</code>. Let's start by updating our <code>pickleStore</code> so it properly updates the status message after we've called add.</p>

<p>``` js test.pickles.js
var pickleStore = {
  count: 0,
  status: '',
  pickles: function() {</p>

<pre><code>var self = this;
$.ajax({
  url: 'http://localhost:3000/pickles',
  dataType: 'json',
  success: function(data) {
    self.count = parseInt(data.count);
    self.status = data.message;
  }
});
</code></pre>

<p>  },
  add: function(num) {</p>

<pre><code>var self = this;
$.ajax({
  url: 'http://localhost:3000/pickles/add/' + num,
  dataType: 'json',
  success: function(data) {
    self.status = data.message; // &lt;-- update the status message!
  }
});
</code></pre>

<p>  }
};
```</p>

<p>Now that that's in there we'll write a failing spec.</p>

<p>``` js test.pickles.js
describe('#add', function() {</p>

<p>  var amount = 11;</p>

<p>  beforeEach(function() {</p>

<pre><code>sinon.stub($, 'ajax').yieldsTo('success', {
  add: amount,
  message: 'you added ' + amount + ' pickles to the pickle barrel!'
});
</code></pre>

<p>  });</p>

<p>  afterEach(function() {</p>

<pre><code>$.ajax.restore();
</code></pre>

<p>  });</p>

<p>  it('should update the status with the correct amount', function(done) {</p>

<pre><code>pickleStore.add(amount);
expect(pickleStore.status).to.equal('you added ' + 99 + ' pickles to the pickle barrel!');
done();
</code></pre>

<p>  });
});
```</p>

<p>This is not unlike our previous spec, in fact it does even less since we're not checking count.</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/failing_add_test.png" title="'Another failing test.'" ></p>

<p>To make the test pass we change the 99 to <code>amount</code>. I originally wrote the add method thinking I would go back and check the total number of pickles but I've realized now that really that's more of a test for the service and not the front end. The front end shouldn't care if that arithmetic is happening properly, it should just consume data and update its UI. For tomorrow's post I'll try to get an AMD module in here so we can start playing with Backbone again. Thanks!</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 11:21 am</li>
<li>Mood: Irritated, Antsy</li>
<li>Sleep: 8</li>
<li>Hunger: 5</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
</feed>
