<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-06-15T20:05:57-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How To Write a Command Line Ruby Gem]]></title>
    <link href="http://robdodson.me/blog/2012/06/14/how-to-write-a-command-line-ruby-gem/"/>
    <updated>2012-06-14T08:17:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/14/how-to-write-a-command-line-ruby-gem</id>
    <content type="html"><![CDATA[<p>So <a href="http://robdodson.me/blog/2012/06/13/writing-a-command-line-tool-in-ruby/">yesterday we saw how to setup and run ruby scripts as executables from the command line.</a> While this is pretty rad, it definitely has its limitations. For one, it's not very portable and secondly it just isn't very flexible or powerful. If we stuck with this approach we'd need to write our own semantic versioning, we'd have to setup a way to make sure that all of our required 3rd party gems get installed properly... really it'll just be a big mess if we try to hand-roll it.</p>

<p>Instead we're going to turn to Bundler to help us manage our files and turn our command line tool into a ruby gem. I'm going to start fresh and create a totally new tool, called <code>zerp</code>. I don't know what <code>zerp</code>'s purpose will be in the long run, but today we're going to make it print some text to verify everything is working.</p>

<h2>New RVM Gemset</h2>

<p>Before I do anything with gems I want to make sure I have a cleanroom of sorts. So if anything goes horribly wrong I can just throw everything away and start over. To do this we'll use RVM to create a new gemset.</p>

<p><code>
rvm gemset create zerp
rvm gemset use zerp
</code></p>

<p>If you run <code>rvm current</code> you should see something like this: <code>ruby-1.9.3-p125@zerp</code></p>

<p>Now that we have our cleanroom we can template out a new gem.</p>

<h2>Bundle Gem</h2>

<p>If bundler is not one of our global gems we can go ahead and install it with <code>gem install bundler</code>. You can do <code>gem list</code> to see what gems are in your global set.</p>

<p>With Bundler in hand we will generate the boilerplate for our new gem:</p>

<p><code>bundle gem zerp</code></p>

<p>This will create a new folder called <code>zerp/</code> and fill it with several files. <code>cd</code> into <code>zerp/</code> and take a look around.</p>

<p><code>
drwxr-xr-x  10 Rob  staff   340B Jun 14 08:38 .
drwxr-xr-x  21 Rob  staff   714B Jun 14 08:38 ..
drwxr-xr-x  11 Rob  staff   374B Jun 14 08:38 .git
-rw-r--r--   1 Rob  staff   154B Jun 14 08:38 .gitignore
-rw-r--r--   1 Rob  staff    89B Jun 14 08:38 Gemfile
-rw-r--r--   1 Rob  staff   1.0K Jun 14 08:38 LICENSE
-rw-r--r--   1 Rob  staff   490B Jun 14 08:38 README.md
-rw-r--r--   1 Rob  staff    48B Jun 14 08:38 Rakefile
drwxr-xr-x   4 Rob  staff   136B Jun 14 08:38 lib
-rw-r--r--   1 Rob  staff   626B Jun 14 08:38 zerp.gemspec
</code></p>

<p>Bundler has already setup a git project for us, as well as including a folder structure for our library. <a href="http://rails-bestpractices.com/blog/posts/8-using-bundler-and-rvm-to-build-a-rubygem">This article from rails-bestpractices.com does a great job of explaining what everything in the boilerplate is.</a></p>

<h2>Zee Codez!</h2>

<p>Our project contains a folder called <code>lib</code> which is where we'll store our Ruby code. Open up <code>lib/zerp.rb</code>. We'll populate it with an example class called <code>Chatter</code> which'll spit out our version of Hello World.</p>

<p>``` ruby lib/zerp.rb
require "zerp/version"</p>

<p>module Zerp
  class Chatter</p>

<pre><code>def say_hello
  puts 'This is zerp. Coming in loud and clear. Over.'
end
</code></pre>

<p>  end
end
```</p>

<h2>Executable</h2>

<p>It wouldn't be much of a CLI without an executable. For that we'll need to create a folder called <code>bin</code> in the root of our project. Next create a file called <code>zerp</code> without any kind of file extension. We're going to require our <code>Chatter</code> class and tell it to <code>say_hello</code>.</p>

<p>``` ruby bin/zerp</p>

<h1>!/usr/bin/env ruby</h1>

<p>require 'zerp'</p>

<p>chatter = Zerp::Chatter.new
chatter.say_hello
```</p>

<p>The shebang <code>#!/usr/bin/env ruby</code> tells the system that it should use Ruby to execute our code. After that we require our 'zerp' module defined previously. Finally we instantiate <code>Zerp::Chatter</code> and tell it to <code>say_hello</code>. If all goes well it should respond with</p>

<p><code>
This is zerp. Coming in loud and clear. Over.
</code></p>

<p>Let's see if we can make that happen.</p>

<h2>Gemspec</h2>

<p>We're going to open the <code>zerp.gemspec</code> and make it look like so:</p>

<p>``` ruby zerp.gemspec</p>

<h1>-<em>- encoding: utf-8 -</em>-</h1>

<p>require File.expand_path('../lib/zerp/version', <strong>FILE</strong>)</p>

<p>Gem::Specification.new do |gem|
  gem.authors       = ["Rob Dodson"]
  gem.email         = ["lets.email.rob@theawesomegmails.com"]
  gem.description   = %q{When a problem comes along..You must zerp it}
  gem.summary       = %q{Now zerp it..Into shape}
  gem.homepage      = "http://robdodson.me"</p>

<p>  gem.files         = <code>git ls-files</code>.split($)
  gem.executables   = ["zerp"]
  gem.test_files    = gem.files.grep(%r{<sup>(test|spec|features)/})</sup>
  gem.name          = "zerp"
  gem.require_paths = ["lib"]
  gem.version       = Zerp::VERSION
end
```</p>

<p>The main thing I did was to correct the two 'TODO' entries, and to change the <code>gem.executables</code> line from</p>

<p><code>
gem.files.grep(%r{^bin/}).map{ |f| File.basename(f) }
</code></p>

<p>to</p>

<p><code>
gem.executables   = ["zerp"]
</code></p>

<p>For reaons unknown to me the previous code wasn't picking up my executable properly so I replaced it with <code>["zerp"]</code>. I got the idea from <a href="https://github.com/lukebayes/project-sprouts/blob/master/sprout.gemspec">Project Sprouts which also uses this technique and seems to work fine on my system.</a></p>

<p>Alright we're done! Let's test this thing!</p>

<h2>Cross your fingers</h2>

<p>To install the Gem we'll use Rake's <code>install</code> task. Go ahead and run <code>rake install</code> from the root of the project. It should create a <code>pkg</code> directory and notify us via the terminal that our gem was installed succesfully. Moment of truth time...type <code>zerp</code> into the terminal. If you see <code>This is zerp. Coming in loud and clear. Over.</code> then you're good to go. After you've committed everything to Github and setup a RubyGems account you should be able to run <code>rake release</code> to send your gem out into the world where it can wow the jaded masses and delight with all its wonders. Good Luck! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 8:18 am</li>
<li>Mood: Awake, Antsy</li>
<li>Sleep: 6</li>
<li>Hunger: 2</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing a Command Line Tool in Ruby]]></title>
    <link href="http://robdodson.me/blog/2012/06/13/writing-a-command-line-tool-in-ruby/"/>
    <updated>2012-06-13T07:29:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/13/writing-a-command-line-tool-in-ruby</id>
    <content type="html"><![CDATA[<p>Yesterday I tried to do a post on creating your first Ruby Gem as a command line tool. <a href="http://robdodson.me/blog/2012/06/12/messing-around-with-gems/">It didn't go very well.</a> In an effort to better understand what goes on with command line tools I'm going to start from the most basic, a ruby script that is in our <code>PATH</code>.</p>

<p>I've previously added the folder <code>~/bin</code> to my PATH so I know that if I drop an executable script in there I should be able to run it by just typing its name. Let's give that a shot. First we'll make a new file just called <code>sherp</code> without any file extension. Make sure to <code>chmod 755 sherpa</code> so that it's executable. Then we'll add the following:</p>

<p>``` ruby ~/bin/sherpa</p>

<h1>!/usr/bin/env ruby</h1>

<p>puts 'I am the sherpa!!!'
```</p>

<p>If I now type <code>sherpa</code> into the command line, it should fire back <code>I am the sherpa!!!</code></p>

<p>Ok cool so we've got that part working. Now let's see if we can get some arguments in there. We'll iterate the <code>ARGV</code> object to see what comes in.</p>

<p>``` ruby ~/bin/sherpa</p>

<h1>!/usr/bin/env ruby</h1>

<p>ARGV.each do |arg|</p>

<pre><code>puts arg
</code></pre>

<p>end
```</p>

<p>With that little bit of code we should be able to pass just about anything to our command and have it echoed back.</p>

<p>```
sherpa foo bar baz</p>

<p> => foo
 => bar
 => baz
```</p>

<p>Ok cool. Now let's step this up a notch or two. Let's say we want to send in commands and options. For that we'll use the built-in <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/optparse/rdoc/OptionParser.html">OptionParser</a>. Here's <a href="http://rubylearning.com/blog/2011/01/03/how-do-i-make-a-command-line-tool-in-ruby/">a link to the article I've been following which details how to use the OptionParser.</a> In my case, I'm going to tell <code>sherpa</code> to either <code>say_hello</code> or <code>say_goodbye</code>. When I pass in the <code>-n</code> flag it should accept a name, otherwise it will use the name 'Master'. So the line <code>sherpa say_hello -n Rob</code> should produce <code>Hello Rob</code> and likewise if I left off the option and just used <code>sherpa say_hello</code> it should produce <code>Hello Master</code>.</p>

<p>Here's the code to accomplish this:</p>

<p>``` ruby ~/bin</p>

<h1>!/usr/bin/env ruby</h1>

<p>require 'optparse'</p>

<p>options = {}</p>

<p>opt_parser = OptionParser.new do |opt|
  opt.banner = "Usage: opt_parser COMMAND [OPTIONS]"
  opt.separator  ""
  opt.separator  "Commands"
  opt.separator  "     name: the name the sherpa should use when addressing you"
  opt.separator  ""
  opt.separator  "Options"</p>

<p>  opt.on("-n","--name NAME","tell the sherpa what to call you") do |name|</p>

<pre><code>options[:name] = name
</code></pre>

<p>  end</p>

<p>  opt.on("-h","--help","help") do</p>

<pre><code>puts opt_parser
</code></pre>

<p>  end
end</p>

<p>opt_parser.parse!
name = options[:name] || 'Master'</p>

<p>case ARGV[0]
when "say_hello"
  puts "Hello #{name}"
when "say_goodbye"
  puts "Goodbye #{name}"
else
  puts opt_parser
end
```</p>

<p>And there we go, our first command line Ruby tool. I'll pick it up tomorrow to try to improve upon it. We're starting small but at least we have something that works!</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 7:31 am</li>
<li>Mood: Tired, Patient</li>
<li>Sleep: 6</li>
<li>Hunger: 1</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Messing around with Gems]]></title>
    <link href="http://robdodson.me/blog/2012/06/12/messing-around-with-gems/"/>
    <updated>2012-06-12T22:22:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/12/messing-around-with-gems</id>
    <content type="html"><![CDATA[<p>I want to work on a code generation tool, similar to the one offered up by Rails. However my Ruby-fu is a bit rusty at the moment so this might be an interesting struggle.</p>

<p>The first thing I'm going to do is create a new gemset with rvm. Our gem is going to be called <code>r2</code> after the much beloved R2D2 so we'll also call our gemset <code>r2</code>.</p>

<p><code>
rvm gemset create r2
rvm use 1.9.3@r2
</code></p>

<p>Ugh after spending about an 2 hours fucking around with bundler I'm getting nowhere. I'll have to pick this up tomorrow. :\ #WorstPostEver</p>

<p><img class="center" src="https://s3.amazonaws.com/robdodson/images/sadness.jpg" title="'sadness'" ></p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 10:28 pm</li>
<li>Mood: Tired, Cranky</li>
<li>Sleep: 6</li>
<li>Hunger: 8</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 8]]></title>
    <link href="http://robdodson.me/blog/2012/05/16/object-oriented-scraper-backed-with-tests-pt-8/"/>
    <updated>2012-05-16T07:42:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/16/object-oriented-scraper-backed-with-tests-pt-8</id>
    <content type="html"><![CDATA[<p>Yesterday's I refactored my specs and crawler to support ignoring selections. While I started parsing the metadata I quickly realized that certain bits were rather specific and needed to have custom parsing methods. Today I'm going to write some format objects to help with all that.</p>

<p>Our metadata on the page looks like this:</p>

<p><code>
Time: 7:42 am
Mood: Awake, Alert, Focused
Sleep: 6
Hunger: 0
Coffee: 0
</code></p>

<p>Sleep, hunger and coffee are all floats, so one object could be just <code>FloatFormat</code>. Mood should produce an <code>Array</code> of objects so we could have a <code>CollectionFormat</code>. Finally time is going to combine the time listed in the metadata and the post date. We'll make a <code>DateTimeFormat</code> for that. These could all be methods of one big Format object as well but experience tells me that you need to be careful of monolithic actors that consume tons of different data types and spit out results. Those classes have a tendency to bloat very easily as project requirements change. I think it's better to produce classes which can be extended or abstracted as needs arise.</p>

<p>So we know <em>who</em> is going to format but we still don't know <em>how</em>. I think I'd like to build a manifest which matches the metadata category to a format. Maybe something like this?</p>

<p><code>ruby
{
  'Time'    =&gt; DateTimeFormat,
  'Mood'    =&gt; CollectionFormat,
  'Sleep'   =&gt; FloatFormat,
  'Hunger'  =&gt; FloatFormat,
  'Coffee'  =&gt; FloatFormat
}
</code></p>

<p>I could probably look at each item and "detect" what kind of format it needs but I'd rather be explicit. If, for instance, I want to add another format, it's a lot easier to just change my manifest file vs. hacking on some detection scheme. I think we can just produce this manifest file in YAML and load it in at runtime. One thing I don't like about this approach is that it specifically names our format classes. You could generalize it so that it just matches a category to the desired output data, for instance <code>'Coffee' =&gt; Float</code> but then you run into problems with flexibility. What if Coffee still needed to output a float but had to go through a different Format than Hunger or Sleep? With that in mind we'll stick to the plan already laid out.</p>

<p><code>yaml tentacles/lib/tentacles/formats.yml
time:     DateTimeFormat
mood:     CollectionFormat
sleep:    FloatFormat
hunger:   FloatFormat
coffee:   FloatFormat
</code></p>

<h3>The Format object</h3>

<p>I would love it if I could use the Format object as a module and just call a method on it from Crawler. It might look like this:</p>

<p>```ruby
def metadata_by_selector(selector)
  node = nodes_by_selector(selector).first
  metadata = {}
  node.children.each do |child|</p>

<pre><code>Tentacles::Format.insert(child, metadata)         
</code></pre>

<p>  end    <br/>
end
<code>``
The only problem is</code>Format` needs to load in and parse its formats.yml file before it's any good to us. There's some interesting talk of the <a href="http://www.subelsky.com/2008/05/using-rubys-autoload-method-to.html">Module#autoload method</a> but that's not quite what I need...</p>

<p>Seems like I can't find any good documentation on this so instead we'll make it an instance of the class. Also I'm lazy so I'm going to have that instance load its own formats.yml file. Normally I like to only have one entry point for configuration files but...whatever.</p>

<h3>How do I convert a string into a class name in Ruby?</h3>

<p>Well we know we can load our YAML file but all of our format classes are going to come in as strings. I did some digging to figure out how to convert the string into an actual class that can then be instantiated. If you just want to convert a String into a class you can use <code>Object.const_get('Foobar').new</code> but that's not going to work for us since our code is wrapped in a module. To convert a string into a module class we'll need to use the name of our module: <code>Tentacles.const_get('DateTimeFormat').new</code>.</p>

<p>With that in mind I want to spec out a simple test that passes in string of metadata and receives a printed notification that the right formatter has been created. We'll then refactor it to actually use the formatter on the string.</p>

<p>```ruby tentacles/spec/format_spec.rb
require_relative '../lib/tentacles/format'
require_relative '../lib/tentacles/date_time_format'</p>

<p>describe Tentacles::Format do
  describe "when asked to parse some metadata" do</p>

<pre><code>it "should create the right formatter" do
  @format = Tentacles::Format.new
  @format.parse('Time: 8:03 am').should be_an_instance_of(Tentacles::DateTimeFormat)
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby tentacles/lib/format.rb
require 'yaml'
require_relative 'date_time_format'</p>

<p>module Tentacles
  class Format</p>

<pre><code>def initialize
  @categories = YAML.load(File.open(File.dirname(__FILE__) + '/formats.yml'))
end

def parse(data)
  category = data.split(':')[0]
  category.downcase!
  Tentacles.const_get(@categories[category]).new
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby tentacles/lib/date_time_format.rb
module Tentacles
  class DateTimeFormat</p>

<pre><code>def initialize
  puts 'DateTimeFormat created!'
end
</code></pre>

<p>  end
end
```</p>

<p>Now let's take it a step further so we can convert an actual time into a DateTime object. Here's our updated spec:</p>

<p>```ruby
require_relative '../lib/tentacles/format'
require 'date'</p>

<p>describe Tentacles::Format do
  describe "when asked to parse some metadata" do</p>

<pre><code>it "should create the right formatter" do
  @format = Tentacles::Format.new
  @format.parse('Time: 8:03 am').should be_an_instance_of(Date)
end
</code></pre>

<p>  end
end
```</p>

<p>To pull this off we'll need the help of at least 2 new gems: <a href="http://rubygems.org/gems/chronic">Chronic</a> and <a href="http://rubygems.org/gems/activesupport">ActiveSupport</a>. Chronic is a natural language parser which can convert strings into useable timestamps. ActiveSupport is a library of extensions originally created for Rails which have been abstracted into a general purpose toolset. We're going to combine these two gems to turn the phrase "8:03 am" into a Ruby DateTime.</p>

<p>Gotta first update the Gemfile with our new dependencies and run <code>bundle install</code>.</p>

<p>```ruby
source 'https://rubygems.org'</p>

<p>gem 'rspec', '2.9.0'
gem 'nokogiri', '~>1.5.2'
gem 'awesome_print', '~>1.0.2'
gem 'fakeweb', '~>1.3.0'
gem 'chronic', '~> 0.6.7'
gem 'activesupport', '~> 3.2.3'
```</p>

<p>Next we bang out a quick parse method inside of DateTimeFormat. Our Tentacles::Format is going to delegate its parse call to whichever subordinate formatter it creates. Code speaks louder than words:</p>

<p>```ruby tentacles/lib/tentacles/format.rb
require 'yaml'
require_relative 'date_time_format'</p>

<p>module Tentacles
  class Format</p>

<pre><code>def initialize
  @categories = YAML.load(File.open(File.dirname(__FILE__) + '/formats.yml'))
end

# Create a formatter based on the content of the passed
# in data. Delegate the parse call to this new formatter
def parse(data)
  category, *content = data.split(':')
  category.downcase!
  formatter = Tentacles.const_get(@categories[category]).new
  formatter.parse(content)
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby tentacles/lib/tentacles/date_time_format.rb
require 'chronic'
require 'active_support/core_ext/string/conversions.rb'</p>

<p>module Tentacles
  class DateTimeFormat</p>

<pre><code>def initialize
  puts 'DateTimeFormat created!'
end

def parse(content)
  Chronic.parse(content.join(':')).to_datetime
end
</code></pre>

<p>  end
end
```</p>

<p>With all that in place our test should pass. Nice!!!!!! We're well on our way to processing the remaining metadata. Tomorrow I'll whip up our other formats and figure out how to pull the date out of a blog post so we can combine that with the time to get a proper DateTime.</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 7:42 am</li>
<li>Mood: Awake, Alert, Focused</li>
<li>Sleep: 6</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed with Tests Pt. 7]]></title>
    <link href="http://robdodson.me/blog/2012/05/15/object-oriented-scraper-backed-with-tests-pt-7/"/>
    <updated>2012-05-15T21:33:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/05/15/object-oriented-scraper-backed-with-tests-pt-7</id>
    <content type="html"><![CDATA[<p>During my last post I realized that including my metadata in the blog post as only a ul meant that all the words were being scraped as part of the keyword frequency search. After thinking about it for a while I think I'm going to give the keyword search method an optional value which it can use to ignore or delete certain nodes.</p>

<p>Thankfully I have my tests in place to validate what our final output should look like. Which means I'm basically hacking away at Nokogiri to get things to pass. Here's what I finally settle on:</p>

<p>```ruby
def words_by_selector(selector, ignored_selector = nil)
  node = nodes_by_selector(selector).first
  if ignored_selector</p>

<pre><code>ignored = node.css(ignored_selector)
ignored.remove()
</code></pre>

<p>  end
  words = words_from_string(node.content)
  count_frequency(words)</p>

<p>  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map { |word, count| "#{word}: #{count}"}
end
```</p>

<p>I think the code is pretty self explanatory. Moving on to the metadata we expect a Hash that looks like this:</p>

<p><code>
{
  datetime: 2012-05-13T08:03:00-07:00,
  mood: ['Happy', 'Drowsy', 'Peaceful'],
  sleep: 5.5,
  hunger: 3.0,
  coffee: 0.0
}
</code></p>

<p>As I'm playing back and forth with the metadata selector methods I'm realizing that writing non-brittle tests is extremely difficult!</p>

<p>I'm noticing that some of the metadata, when broken into Strings, don't parse very well. For instance:</p>

<p><code>Time: 8:03</code> splits up into <code>["Time", " 8", "03"]</code></p>

<p>We can use a splat operator to clean that up a bit for us:</p>

<p>```ruby
def metadata_by_selector(selector)
  node = nodes_by_selector(selector).first
  metadata = {}
  node.children.each do |child|</p>

<pre><code>key, *value = child.content.split(':')
puts "#{key}: #{value}"
</code></pre>

<p>  end    <br/>
end
```</p>

<p>The above should produce something like:</p>

<p><code>
Time: [" 8", "03 am"]
Mood: [" Happy, Drowsy, Peaceful"]
Sleep: [" 5.5"]
Hunger: [" 3"]
Coffee: [" 0"]
</code></p>

<p>Close... but still not perfect. I think the best thing to do would be to write some formatter objects or functions to handle the different kinds of metadata. We'll tackle that tomorrow.</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 9:34pm</li>
<li>Mood: Fat, Tired, Drunk</li>
<li>Sleep: 6</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
</feed>
