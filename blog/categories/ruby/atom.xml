<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-06-21T01:30:17-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quick Spider Example]]></title>
    <link href="http://robdodson.me/blog/2012/06/21/quick-spider-example/"/>
    <updated>2012-06-21T01:27:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/21/quick-spider-example</id>
    <content type="html"><![CDATA[<p>``` ruby
require 'mechanize'</p>

<h1>Create a new instance of Mechanize and grab our page</h1>

<p>agent = Mechanize.new
page = agent.get('http://robdodson.me/blog/archives/')</p>

<h1>Find all the links on the page that are contained within</h1>

<h1>h1 tags.</h1>

<p>post_links = page.links.find_all { |l| l.attributes.parent.name == 'h1' }
post_links.shift</p>

<h1>Follow each link and print out its title</h1>

<p>post_links.each do |link|</p>

<pre><code>post = link.click
doc = post.parser
p doc.css('.entry-title').text
</code></pre>

<p>end
```
Having a horrible time getting anything to run tonight. The code from above is a continuation from yesterday's post except this time we're finding every link on the page, then following that link and spitting out its title. Using this formula you could build something entirely recursive which acts as a full blown spider.</p>

<p>Unfortunately getting this to integrate into the existing app is not working for me tonight. Coding anything after 11 pm is usually a bad call, so I'm going to shut it down and try again in the morning.</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 1:28 am</li>
<li>Mood: Tired, Annoyed</li>
<li>Sleep: 6</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crawling pages with Mechanize and Nokogiri]]></title>
    <link href="http://robdodson.me/blog/2012/06/20/crawling-pages-with-mechanize-and-nokogiri/"/>
    <updated>2012-06-20T00:09:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/20/crawling-pages-with-mechanize-and-nokogiri</id>
    <content type="html"><![CDATA[<p>Short post tonight because I spent so much time figuring out the code. It's late and my brain is firing on about 1 cylinder so it took longer than I expected to get everything working.</p>

<p>The scraper that I'm building is supposed to work like a spider and crawl of the pages of my blog. I wasn't sure what the best way to do that was so I started Googling and came up with <a href="http://mechanize.rubyforge.org/">Mechanize.</a> There are other tools built on top of Mechanize, like <a href="https://github.com/felipecsl/wombat">Wombat</a>, but since my task is so simple I figured I could just write everything I needed with Mechanize and Nokogiri. It's usually a better idea to work with simple tools when you're first grasping concepts so you don't get lost in the weeds of some high powered framework.</p>

<p>Since it's late I'll let the code do the talking:</p>

<p>``` ruby crawler.rb
require 'mechanize'</p>

<h1>Create a new instance of Mechanize and grab our page</h1>

<p>agent = Mechanize.new
page = agent.get('http://robdodson.me/blog/archives/')</p>

<h1>Find all the links on the page that are contained within</h1>

<h1>h1 tags.</h1>

<p>post_links = page.links.find_all { |l| l.attributes.parent.name == 'h1' }</p>

<h1>Click on one of our post links and store the response</h1>

<p>post = post_links[1].click
doc = page.parser # Same as Nokogiri::HTML(page.body)
p doc
```</p>

<p>This code is hopefully easy enough to digest. After I get the page I find all of the links which are wrapped inside of an <code>h1</code>. Just as an example I <code>click</code> a link from the list using Array syntax and store the response in another var. You <em>could</em> click all of the links by iterating through the post_links object, and that's what we'll tackle tomorrow. For now I just follow 1 link and use a convenience method to parse the page with Nokogiri. After that we have a Nokogiri <code>doc</code> ready to be manipulated however we see fit.</p>

<p><a href="https://gist.github.com/2958538">Here's a link to the Gist</a> if you'd like to tweak or play with the code. Pop it into <code>irb</code> and give it a shot. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 12:10 am</li>
<li>Mood: Tired, Introspective</li>
<li>Sleep: 4.5</li>
<li>Hunger: 2</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Outputting JSON from Ruby]]></title>
    <link href="http://robdodson.me/blog/2012/06/18/outputting-json-from-ruby/"/>
    <updated>2012-06-18T08:19:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/18/outputting-json-from-ruby</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/06/17/object-oriented-scraper-backed-with-tests-pt-dot-dot-dot-9/">Last night</a> I got the scraper to write an output.txt file which listed all the contents of <code>words_by_selector</code>. Today I want to make it write to JSON instead of plain text and I want to back it with some tests.</p>

<h2>Updating our tests</h2>

<p>Our current test for <code>words_by_selector</code> looks like this:</p>

<p><code>ruby spec/crawler_spec.rb
it "should produce the correct Array of keywords" do
  expected_array = ['hello: 3', 'world: 2', 'foobar: 1']
  actual_array = @crawler.words_by_selector(@options[:post_selector], @options[:ignored_post_selector])
  actual_array.should eq(expected_array)
end
</code>
We're going to need to break that sucker so it'll produce something more like this:</p>

<p>``` ruby spec/crawler_spec.rb
it "should produce the correct Hash of keywords" do
  expected_hash = {</p>

<pre><code>  word_count: [
    {
      word: 'hello',
      count: 3
    },
    {
      word: 'world',
      count: 2
    },
    {
      word: 'foobar',
      count: 1
    },
  ]
}
</code></pre>

<p>  actual_hash = @crawler.words_by_selector(@options[:post_selector], @options[:ignored_post_selector])
  actual_hash.should eq(expected_hash)
end
```</p>

<p>And we update <code>words_by_selector</code> to look like this:</p>

<p>``` ruby tentacles/lib/tentacles/crawler.rb
def words_by_selector(selector, ignored_selector = nil)
  node = nodes_by_selector(selector).first
  if ignored_selector</p>

<pre><code>ignored = node.css(ignored_selector)
ignored.remove()
</code></pre>

<p>  end
  words = words_from_string(node.content)
  count_frequency(words)</p>

<p>  sorted = @counts.sort_by { |word, count| count }
  sorted.reverse!
  sorted.map! do |word, count|</p>

<pre><code>{ word: word, count: count }
</code></pre>

<p>  end
  { word_count: sorted }
end
```</p>

<p>Our new test should pass. Feel free to flip one of the numbers in the expected_hash to 99 or something to see it fail.</p>

<p>Now let's make sure the runner takes the content out of the crawler and writes it to a JSON file.</p>

<p>``` ruby spec/runner_spec.rb
it "should create a directory for our output" do
  @runner.run
  Dir.exists?('../../output').should be_true
end</p>

<p>it "should output the correct JSON" do
  @runner.run
  File.open("../../output/word_count.json") do |file|</p>

<pre><code>file.each_line do |line|
  puts line
end
</code></pre>

<p>  end
end
```
And in runner.rb...</p>

<p>``` ruby tentacles/lib/tentacles/runner.rb
def run    <br/>
  @crawler = Tentacles::Crawler.from_uri(@options.uri)
  output = @crawler.words_by_selector(@options.post_selector, 'ul:last-child')</p>

<p>  Dir.mkdir('../../output') unless Dir.exists?('../../output')</p>

<p>  File.open("../../output/word_count.json", "w") do |file|</p>

<pre><code>file.puts JSON.pretty_generate(output)
</code></pre>

<p>  end
end
```</p>

<p>And there we go. Our first decent output from the crawler :D -Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 8:20 am</li>
<li>Mood: Awake</li>
<li>Sleep: 6</li>
<li>Hunger: 4</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Scraper Backed With Tests Pt...9?]]></title>
    <link href="http://robdodson.me/blog/2012/06/17/object-oriented-scraper-backed-with-tests-pt-dot-dot-dot-9/"/>
    <updated>2012-06-17T22:43:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/17/object-oriented-scraper-backed-with-tests-pt-dot-dot-dot-9</id>
    <content type="html"><![CDATA[<p>I just spent a few hours talking to my friend <a href="http://derekbradley.com/">Derek</a>(<a href="https://twitter.com/#!/derekebradley">@derekebradley</a>) about Ruby and it occured to me that I never finished this scraper project. We got awfully far with it but then it kind of died on the vine. <a href="http://robdodson.me/blog/2012/05/06/object-oriented-scraper-backed-with-tests/">Thankfully,</a> <a href="http://robdodson.me/blog/2012/05/07/object-oriented-scraper-backed-with-tests-pt-2/">I</a> <a href="http://robdodson.me/blog/2012/05/08/object-oriented-scraper-backed-with-tests-pt-3/">wrote</a> <a href="http://robdodson.me/blog/2012/05/11/object-oriented-scraper-backed-with-tests-pt-4/">it</a> <a href="http://robdodson.me/blog/2012/05/12/object-oriented-scraper-backed-with-tests-pt-5/">all</a> <a href="http://robdodson.me/blog/2012/05/13/object-oriented-scraper-backed-with-tests-pt-6/">down.</a> <a href="http://robdodson.me/blog/2012/05/15/object-oriented-scraper-backed-with-tests-pt-7/">down.</a> <a href="http://robdodson.me/blog/2012/05/16/object-oriented-scraper-backed-with-tests-pt-8/">down.</a></p>

<p>The fact of the matter is I didn't know where to take the data. I didn't have a design or a layout that I could put it all into. I want to change all that. I want to turn this into something useful. But first I have to make sense of all the code that was written so many weeks ago.</p>

<h2>Tests as documentation...bullshit.</h2>

<p>Ok ok. I should say it's <em>total</em> bullshit to call your tests the documentation because they are helpful. But the fact of the matter is you can get so crafty with RSpec that it makes the tests difficult to read in a useful way. I'm not saying they're illegible, it's just that they leverage features which adds to their thought deficit. Before you go off saying that I wrote them wrong and tests should be all the documentation you need...shutup. They're helpful but I would love it if I had written a bit of Markdown Readme to go with all this...</p>

<h2>Explain yourself</h2>

<p>Let's see if I can regurgitate what this thing currently does in plain English.</p>

<ul>
<li><p>There's a config.yml file. It says what page to scrape, what the CSS selector for a post looks like and what the CSS selector for metadata looks like. The metadata is the list at the bottom of every page listing the time, amount of sleep, coffee, etc.</p></li>
<li><p>There's a command line object, <code>tentacles</code>. It initiates <code>runner.rb</code>. <code>Runner</code> creates an instance of <code>Options</code>. <code>Options</code> loads the config.yml file and parses it, turning its properties into members of the options object.</p></li>
<li><p>It actually doesn't do anything else beyond that. <code>runner.rb</code> stops right there but we have Rspec tests which fake data and check to see if our other classes work. Those other classes are...</p></li>
<li><p><code>crawler.rb</code> should be the real meat of our program. Funny, seeing as how I wrote all this, that I totally can't remember who does what...</p></li>
<li><p><code>crawler.rb</code> has two primary methods: <code>words_by_selector</code> and <code>metadata_by_selector</code>.</p></li>
<li><p><code>words_by_selector</code> returns an array of words and the number of times they've occurred. This array should be in order from most used to least used.</p></li>
<li><p><code>metadata_by_selector</code> returns the content of one of our metadata lists.... I think.</p></li>
</ul>


<h2>Make it work</h2>

<p>With Tim Gunn's mantra we're gonna make this thing work. The tests verify that everything should be at least somewhat functioning. Since I'm a little drunk I can't do a <em>super</em> deep dive but let's see if we can get our runner to write out the contents of <code>words_by_selector</code> to a text file.</p>

<p>``` ruby runner.rb
require 'yaml'
require_relative 'options'
require_relative 'crawler'</p>

<p>module Tentacles
  class Runner</p>

<pre><code>def initialize(config)
  @options = Tentacles::Options.new(config)
end

def run      
  @crawler = Tentacles::Crawler.from_uri(@options.uri)
  output = @crawler.words_by_selector(@options.post_selector, 'ul:last-child')
  File.open("output.txt", "w") do |file|
    output.each do |line|
      file.puts line
    end
  end
end
</code></pre>

<p>  end
end
```</p>

<p>To get this working I <code>cd</code> into the lib/ folder where all the code lives and do an <code>irb -I .</code> so I can require the local files.</p>

<p><code>
require 'runner'
runner = Tentacles::Runner.new('config.yml')
runner.run
</code></p>

<p>After doing that we <em>do</em> get a text file, with copy that looks somewhat correct...</p>

<p><code>
we: 8
to: 8
npm: 6
should: 5
package: 4
our: 4
compliment: 4
git: 3
0: 3
4: 3
need: 3
2: 3
it: 3
node_modules: 3
the: 3
have: 3
be: 3
json: 2
your: 2
any: 2
dependencies: 2
module: 2
and: 2
node: 2
add: 2
xml2json: 2
how: 2
s: 2
in: 2
you: 2
json1: 2
an: 2
3: 2
awesome: 2
version: 2
</code></p>

<p>It looks like the copy from my most recent blog post, plus or minus a few words. Horrible regex aside it <em>kinda</em> works and that's what we're after. Maybe tomorrow we can turn it into some JSON :D Till then. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 10:44 pm</li>
<li>Mood: Drunk, Sleepy</li>
<li>Sleep: 3</li>
<li>Hunger: 4</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How To Write a Command Line Ruby Gem]]></title>
    <link href="http://robdodson.me/blog/2012/06/14/how-to-write-a-command-line-ruby-gem/"/>
    <updated>2012-06-14T08:17:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/14/how-to-write-a-command-line-ruby-gem</id>
    <content type="html"><![CDATA[<p>So <a href="http://robdodson.me/blog/2012/06/13/writing-a-command-line-tool-in-ruby/">yesterday we saw how to setup and run ruby scripts as executables from the command line.</a> While this is pretty rad, it definitely has its limitations. For one, it's not very portable and secondly it just isn't very flexible or powerful. If we stuck with this approach we'd need to write our own semantic versioning, we'd have to setup a way to make sure that all of our required 3rd party gems get installed properly... really it'll just be a big mess if we try to hand-roll it.</p>

<p>Instead we're going to turn to Bundler to help us manage our files and turn our command line tool into a ruby gem. I'm going to start fresh and create a totally new tool, called <code>zerp</code>. I don't know what <code>zerp</code>'s purpose will be in the long run, but today we're going to make it print some text to verify everything is working.</p>

<h2>New RVM Gemset</h2>

<p>Before I do anything with gems I want to make sure I have a cleanroom of sorts. So if anything goes horribly wrong I can just throw everything away and start over. To do this we'll use RVM to create a new gemset.</p>

<p><code>
rvm gemset create zerp
rvm gemset use zerp
</code></p>

<p>If you run <code>rvm current</code> you should see something like this: <code>ruby-1.9.3-p125@zerp</code></p>

<p>Now that we have our cleanroom we can template out a new gem.</p>

<h2>Bundle Gem</h2>

<p>If bundler is not one of our global gems we can go ahead and install it with <code>gem install bundler</code>. You can do <code>gem list</code> to see what gems are in your global set.</p>

<p>With Bundler in hand we will generate the boilerplate for our new gem:</p>

<p><code>bundle gem zerp</code></p>

<p>This will create a new folder called <code>zerp/</code> and fill it with several files. <code>cd</code> into <code>zerp/</code> and take a look around.</p>

<p><code>
drwxr-xr-x  10 Rob  staff   340B Jun 14 08:38 .
drwxr-xr-x  21 Rob  staff   714B Jun 14 08:38 ..
drwxr-xr-x  11 Rob  staff   374B Jun 14 08:38 .git
-rw-r--r--   1 Rob  staff   154B Jun 14 08:38 .gitignore
-rw-r--r--   1 Rob  staff    89B Jun 14 08:38 Gemfile
-rw-r--r--   1 Rob  staff   1.0K Jun 14 08:38 LICENSE
-rw-r--r--   1 Rob  staff   490B Jun 14 08:38 README.md
-rw-r--r--   1 Rob  staff    48B Jun 14 08:38 Rakefile
drwxr-xr-x   4 Rob  staff   136B Jun 14 08:38 lib
-rw-r--r--   1 Rob  staff   626B Jun 14 08:38 zerp.gemspec
</code></p>

<p>Bundler has already setup a git project for us, as well as including a folder structure for our library. <a href="http://rails-bestpractices.com/blog/posts/8-using-bundler-and-rvm-to-build-a-rubygem">This article from rails-bestpractices.com does a great job of explaining what everything in the boilerplate is.</a></p>

<h2>Zee Codez!</h2>

<p>Our project contains a folder called <code>lib</code> which is where we'll store our Ruby code. Open up <code>lib/zerp.rb</code>. We'll populate it with an example class called <code>Chatter</code> which'll spit out our version of Hello World.</p>

<p>``` ruby lib/zerp.rb
require "zerp/version"</p>

<p>module Zerp
  class Chatter</p>

<pre><code>def say_hello
  puts 'This is zerp. Coming in loud and clear. Over.'
end
</code></pre>

<p>  end
end
```</p>

<h2>Executable</h2>

<p>It wouldn't be much of a CLI without an executable. For that we'll need to create a folder called <code>bin</code> in the root of our project. Next create a file called <code>zerp</code> without any kind of file extension. We're going to require our <code>Chatter</code> class and tell it to <code>say_hello</code>.</p>

<p>``` ruby bin/zerp</p>

<h1>!/usr/bin/env ruby</h1>

<p>require 'zerp'</p>

<p>chatter = Zerp::Chatter.new
chatter.say_hello
```</p>

<p>The shebang <code>#!/usr/bin/env ruby</code> tells the system that it should use Ruby to execute our code. After that we require our 'zerp' module defined previously. Finally we instantiate <code>Zerp::Chatter</code> and tell it to <code>say_hello</code>. If all goes well it should respond with</p>

<p><code>
This is zerp. Coming in loud and clear. Over.
</code></p>

<p>Let's see if we can make that happen.</p>

<h2>Gemspec</h2>

<p>We're going to open the <code>zerp.gemspec</code> and make it look like so:</p>

<p>``` ruby zerp.gemspec</p>

<h1>-<em>- encoding: utf-8 -</em>-</h1>

<p>require File.expand_path('../lib/zerp/version', <strong>FILE</strong>)</p>

<p>Gem::Specification.new do |gem|
  gem.authors       = ["Rob Dodson"]
  gem.email         = ["lets.email.rob@theawesomegmails.com"]
  gem.description   = %q{When a problem comes along..You must zerp it}
  gem.summary       = %q{Now zerp it..Into shape}
  gem.homepage      = "http://robdodson.me"</p>

<p>  gem.files         = <code>git ls-files</code>.split($)
  gem.executables   = ["zerp"]
  gem.test_files    = gem.files.grep(%r{<sup>(test|spec|features)/})</sup>
  gem.name          = "zerp"
  gem.require_paths = ["lib"]
  gem.version       = Zerp::VERSION
end
```</p>

<p>The main thing I did was to correct the two 'TODO' entries, and to change the <code>gem.executables</code> line from</p>

<p><code>
gem.files.grep(%r{^bin/}).map{ |f| File.basename(f) }
</code></p>

<p>to</p>

<p><code>
gem.executables   = ["zerp"]
</code></p>

<p>For reaons unknown to me the previous code wasn't picking up my executable properly so I replaced it with <code>["zerp"]</code>. I got the idea from <a href="https://github.com/lukebayes/project-sprouts/blob/master/sprout.gemspec">Project Sprouts which also uses this technique and seems to work fine on my system.</a></p>

<p>Alright we're done! Let's test this thing!</p>

<h2>Cross your fingers</h2>

<p>To install the Gem we'll use Rake's <code>install</code> task. Go ahead and run <code>rake install</code> from the root of the project. It should create a <code>pkg</code> directory and notify us via the terminal that our gem was installed succesfully. Moment of truth time...type <code>zerp</code> into the terminal. If you see <code>This is zerp. Coming in loud and clear. Over.</code> then you're good to go. After you've committed everything to Github and setup a RubyGems account you should be able to run <code>rake release</code> to send your gem out into the world where it can wow the jaded masses and delight with all its wonders. Good Luck! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 8:18 am</li>
<li>Mood: Awake, Antsy</li>
<li>Sleep: 6</li>
<li>Hunger: 2</li>
<li>Coffee: 0</li>
</ul>

]]></content>
  </entry>
  
</feed>
