<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design Patterns | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/design-patterns/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-08-11T10:26:34-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Iterator]]></title>
    <link href="http://robdodson.me/blog/2012/08/10/javascript-design-patterns-iterator/"/>
    <updated>2012-08-10T15:45:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/10/javascript-design-patterns-iterator</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>If you're coming from Ruby or Java you probably think of an Iterator as an object which gives you a consistent interface for traversing a collection of some kind. If you're coming from JavaScript or Actionscript you probably just think of an iterator as the <code>i</code> value in a <code>for</code> loop. The term has mixed meanings but in this case we're refering to the former, an object which gives us a consistent interface for iterating over a collection of some kind. If you've never used them before that might seem kind of silly. "If I need to loop over something I'm just going to loop over it!" For many use cases that's totally fine. Where Iterator objects are useful is in situations where you might need to loop in an async fashion (stopping and restarting) or if you want to preclude an object from knowing too much about the inner workings of a collection.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Cursor</li>
</ul>


<h2>Example Time</h2>

<p>The code for an Iterator should be pretty easy to grok if you've worked with loops before. Here is a simple example which returns an Iterator for looping over an Array by every third value.</p>

<p>``` js
var iterator = (function() {</p>

<pre><code>var index = 0,
    data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    length = data.length;

return {
    next: function() {
        var element;
        if (!this.hasNext()) {
            return null;
        }
        element = data[index];
        index += 3;
        return element;
    },
    hasNext: function() {
        return index &lt; length;
    },
    rewind: function() {
        index = 0;
        return data[index];
    },
    current: function() {
        return data[index];
    }
}
</code></pre>

<p>}());
<code>``
Our iterator has a handful of useful operations including</code>next<code>,</code>hasNext<code>,</code>rewind<code>and</code>current`.</p>

<p><code>next</code> will return the next value and advance the index by 3.</p>

<p><code>hasNext</code> will check to see if calling <code>next</code> will actually return an item. Good for indicating when we've reached the end of a collection.</p>

<p><code>rewind</code> will reset the index to zero so we can loop over the collection again.</p>

<p><code>current</code> will return the current item at the index without advancing the index.</p>

<p>Let's put these into play to see how it works:</p>

<p>``` js
while(iterator.hasNext()) {</p>

<pre><code>console.log(iterator.next());
</code></pre>

<p>}</p>

<p>iterator.rewind();
console.log(iterator.current());
```</p>

<p>If we ran the above we'd see the following output in the console.</p>

<p><code>
1
4
7
10
1
</code>
Since the iterator is mainting its own state if we need to stop iteration at any point we just don't call <code>next</code>. Using exclusively <code>for</code> loops we'd have to check against a flag of some kind, store our current position and then rebuild the loop starting from that point.</p>

<h2>Not just for Arrays</h2>

<p>As I mentioned before the Iterator gives us a consistent interface for traversing a collection, which means it can iterate over <em>any</em> object. Calendar Dates, Linked Lists, Node Graphs, whatever! Here's an example of an iterator that traverses a simple Hash.</p>

<p>``` js
var iterator = (function() {</p>

<pre><code>var data = { foo: 'foo', bar: 'bar', baz: 'baz' },
    keys = Object.keys(data),
    index = 0,
    length = keys.length;

return {
    next: function() {
        var element;
        if (!this.hasNext()) {
            return null;
        }
        element = data[keys[index]];
        index++;
        return element;
    },
    hasNext: function() {
        return index &lt; length;
    },
    rewind: function() {
        index = 0;
        return data[keys[index]];
    },
    current: function() {
        return data[keys[index]];
    }
}
</code></pre>

<p>}());
```
Notice how the interface is identical to our previous Iterator? That's one of the key aspects to this pattern: Regardless of the <em>type</em> of collection, we can define a consistent interface to loop through it. It also means that the client doesn't need to know anything about the implementation of the actual collection, and by wrapping it in a closure we can prevent the client from <em>editing</em> the collection. Personally I like the idea of certain services handing out iterators rather than a wholesale dump of all the data. As always use whichever tool is appropriate for the context.</p>

<p>One quick note regarding Hashes. Previous versions of the ECMA spec did not require that Hash keys be kept in order. While most modern browsers <em>do</em> keep them in order there are some funky inconsistencies. For instance, if you write out the following Hash:</p>

<p><code>js
var hash = { 'foo': 'foo', 'bar': 'bar', '1': 'hello', '2': 'world' };
</code>
Google Chrome will swap the order of the keys such that they appear like this:</p>

<p><code>js
{ '1': 'hello', '2': 'world', 'foo': 'foo', 'bar': 'bar' };
</code>
There are some interesting discussions on StackOverflow which cover this topic but it's a bit outside the scope of this article. If you're interested you can find them here:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/5773950/how-to-keep-an-javascript-object-array-ordered-while-also-maintaining-key-lookup">How to keep an Javascript object/array ordered while also maintaining key lookups?</a></li>
<li><a href="http://stackoverflow.com/questions/3549894/javascript-data-structure-for-fast-lookup-and-ordered-looping">Javascript data structure for fast lookup and ordered looping?</a></li>
</ul>


<h2>JavaScript 1.7</h2>

<p>Although not widely supported yet, JavaScript 1.7 includes a built in Iterator object which can be used to wrap an Array or Hash with just a single line of code.</p>

<p>``` html</p>

<script type="application/javascript;version=1.7">
    var lang = { name: 'JavaScript', birthYear: 1995 };
    var it = Iterator(lang);
</script>


<p><code>``
The above script block will not work in Chrome but it should work in the latest version of Firefox. Note the</code>type` attribute of the script tag which instructs the interpreter to handle the code as JS 1.7.</p>

<p>For some further reading on the topic checkout the MDN article which covers <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators">Iterators in JavaScript 1.7</a></p>

<h2>Related Patterns</h2>

<ul>
<li>Composite: Iterators are often applied to recursive structures such as Composites.</li>
<li>Factory Method: Polymorphic iterators rely on factory methods to instantiate the appropriate Iterator subclass.</li>
<li>Memento: Often used in conjunction with the Iterator pattern. An iterator can use a memento to capture the state of an iteration. The iterator stores the memento internally.</li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Singleton]]></title>
    <link href="http://robdodson.me/blog/2012/08/08/javascript-design-patterns-singleton/"/>
    <updated>2012-08-08T19:52:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/08/javascript-design-patterns-singleton</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>Ah yes the Singleton, a pattern whose name lives in infamy. For the uninitiated a little explanation is in order. A Singleton is an object which can only be instantiated one time. Repeated calls to its constructor return the same instance and in this way one can ensure that they don't accidentally create, say, two Users in a single User application. Doesn't sound too bad, right? Well, if you're responsible then it arguably <em>is</em> OK but there are many caveats. Before I get into those though, let's throw in the formal definition <em>a la</em> the Gang of Four.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Ensure a class only has one instance, and provide a global point of access to it.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h2>The icky bits</h2>

<p>So I'm sure some of you are already a little anxious because I used the phrase "global point of access" and rightfully you should be. In OO software design <em>global</em> variables and objects are often frowned upon. They break encapsulation and more often than not cause more harm than good. You don't want the far flung bits of your app to be able to reach all the way up to the very top and fiddle around with stuff. When that starts to happen, and other objects also rely on those global variables, then any piece of code, anywhere in the project can change something which can in turn break a totally unrelated bit of functionality. Debugging becomes a nightmare because you're constantly moving from deeply nested object graphs up to the global scope and then back down again. I one time worked on a <em>major</em> application which I inherited from another developer. It was so riddled with Singletons that any change became a sisyphean ordeal of unintended consiquences and time lost debugging. Needless to say I want to put this warning front and center or else the programming gods would surely smite me.</p>

<h2>Well I'm done! Fuck this shit...</h2>

<p>OK before you start running for the hills I want to point out the ways in which Singletons can be useful and then you can make up your mind if they're right for you.</p>

<p>Let's start with the most obvious one: You're probably already using Singletons!</p>

<p>Ever written any code that looks like this?</p>

<p>``` js
var user = {</p>

<pre><code>firstName: 'John',
lastName: 'Doe',
sayName: function() {
    return this.firstName + ' ' + this.lastName;
}
</code></pre>

<p>};
```</p>

<p>Yep, that's a Singleton. Once you create an object literal in JavaScript you've reserved a little piece of memory and no other object will ever be just like that one. Now, depending on the scope you might have only created a local variable but if that <code>user</code> is sitting outside a function then it's globally available to anyone who wants to fiddle with it. I guess the most famous Singleton probably looks like this: <code>$</code>. To put it another way, ever notice how you can use jQuery anywhere in your app after you've included it on the page...? Boom! Singleton!</p>

<p><em>mind blown</em>  ... <em>face off</em> ...</p>

<h2>OK, So they have their uses I guess</h2>

<p>Yes as much as some are probably loathe to admit it, Singletons are quite useful in JavaScript. And as jQuery demonstrates their primary use is to namespace your code.
While other languages like Java or C# have namespaces built in, JavaScript has to emulate them using simple objects.</p>

<p>Consider the following scenario: You have a series of functions hanging out on the page that you frequently use in your program.</p>

<p>``` js
function login() {</p>

<pre><code>// do some login shtuffs
</code></pre>

<p>}</p>

<p>function logout() {</p>

<pre><code>// do some logout shtuffs
</code></pre>

<p>}</p>

<p>function addToCart() {</p>

<pre><code>// blah, blah blah...
</code></pre>

<p>}
```
A few things are going on here...</p>

<p><em>1. Our functions are polluting the global space.</em>
Since they are just floating around on the page they have to attach to something. With no explicitely declared parent object they get hooked on to the globally available <code>window</code> object.</p>

<p><em>2. They're in danger of being overwritten</em>
If we were to accidentally define another global <code>addToCart</code> function or if we brought in a library whose author did the same, it would overwrite the original leading to a really gnarly debugging situation.</p>

<p>Let's revise this by creating one (and only one) global object which our code can branch off of.</p>

<p>``` js
var NAMESPACE = {};</p>

<p>NAMESPACE.login = function() {</p>

<pre><code>// do some login shtuffs
</code></pre>

<p>}</p>

<p>NAMESPACE.logout = function() {</p>

<pre><code>// do some logout shtuffs
</code></pre>

<p>}</p>

<p>NAMESPACE.addToCart = function() {</p>

<pre><code>// blah, blah blah...
</code></pre>

<p>}
<code>``
Now so long as no one creates an object which also has the name</code>NAMESPACE` our code should be safe. From here we can do all sorts of things. We can nest more object literals or we can create constructor functions:</p>

<p>``` js
var NAMESPACE = {};</p>

<p>NAMESPACE.Widget = function(foo, bar) {</p>

<pre><code>// Some awesome widget code
</code></pre>

<p>}</p>

<p>NAMESPACE.Widget.prototype.doSomethingAwesome = function() {</p>

<pre><code>// do something awesome!!!
</code></pre>

<p>}</p>

<p>var myWidget = new NAMESPACE.Widget('hello', 'world');
```
Take a look at <a href="https://github.com/mrdoob/three.js/">the Three.js library which</a> relies heavily on this pattern to structure its code.</p>

<h2>But I like constructors!</h2>

<p>OK so maybe object literals aren't your thing. That's understandable so let me show you a few other ways of writing Singletons.</p>

<p>These first few come from Stoyan Stefanov's excellent book <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns.</a></p>

<p><strong>Singleton with a cached static property</strong></p>

<p>``` js
function User() {</p>

<pre><code>// do we have an existing instance?
if (typeof User.instance === 'object') {
    return User.instance;
}

// proceed as normal
this.firstName = 'John';
this.lastName = 'Doe';

// cache
User.instance = this;

// implicit return
// return this;
</code></pre>

<p>}
<code>``
The cached static property is publicly available which adds a little danger (someone could say</code>Universe.instance = foo`) but this version is very straightforward and doesn't require closures and funky prototype work. If you're lazy this might be a good approach.</p>

<p><strong>Singleton with a closure</strong></p>

<p>``` js
function User() {</p>

<pre><code>// the cached instance
var instance;

// rewrite the constructor
User = function() {
    return instance;
};

// carry over the prototype
User.prototype = this;

// the instance
instance = new User();

// reset the constructor pointer
instance.constructor = User;

// all the functionality
instance.firstName = 'John';
instance.lastName = 'Doe';

return instance;
</code></pre>

<p>}
```</p>

<p>This version takes a bit of fiddling to get the prototype to work as expected because we rewrite the constructor. The upshot is that <code>instance</code> is now private (being contained within the closure).</p>

<p><strong>Singleton with a self executing function</strong></p>

<p>``` js
var User;
(function() {</p>

<pre><code>var instance;

User = function User() {
    if (instance) {
        return instance;
    }

    instance = this;

    // all the functionality
    this.firstName = 'John';
    this.lastName = 'Doe';
};
</code></pre>

<p>}());
```
By wrapping the instance variable in a self executing function we make it private. This version doesn't require any prototype or constructor reassignment but it may potentially confuse people who aren't comfortable with self executing functions.</p>

<p>Addy Osmani also defines a Singleton pattern in his book <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript">Essential JavaScript Design Patterns.</a></p>

<p>``` js
var mySingleton = (function () {</p>

<p>  // Instance stores a reference to the Singleton
  var instance;</p>

<p>  function init() {</p>

<pre><code>// Singleton

// Private methods and variables
function privateMethod(){
    console.log( "I am private" );
}

var privateVariable = "Im also private";

return {

  // Public methods and variables
  publicMethod: function () {
    console.log( "The public can see me!" );
  },

  publicProperty: "I am also public"
};
</code></pre>

<p>  };</p>

<p>  return {</p>

<pre><code>// Get the Singleton instance if one exists
// or create one if it doesn't
getInstance: function () {

  if ( !instance ) {
    instance = init();
  }

  return instance;
}
</code></pre>

<p>  };</p>

<p>})();</p>

<p>// Usage:</p>

<p>var singleA = mySingleton;
var singleB = mySingleton;
console.log( singleA === singleB ); // true
```</p>

<p>This much more elaborate example allows us to define both private and public methods of our Singleton object at the cost of being a bit more complex than all the others.</p>

<p>As Addy is quick to point out:</p>

<blockquote><p>Whilst the Singleton has valid uses, often when we find ourselves needing it in JavaScript it's a sign that we may need to re-evaluate our design.</p>

<p>They're often an indication that modules in a system are either tightly coupled or that logic is overly spread across multiple parts of a codebase. Singletons can be more difficult to test due to issues ranging from hidden dependencies, the difficulty in creating multiple instances, difficulty in stubbing dependencies and so on.</p></blockquote>

<p>Definitely read <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript">his full article</a> on the subject since it contains a handful of links to interesting side topics.</p>

<h2>Related Patterns</h2>

<p>Many patterns can be implemented using the Singleton pattern. See Abstract Factory, Builder, and Prototype.</p>

<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Strategy]]></title>
    <link href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy/"/>
    <updated>2012-08-03T15:12:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>The Strategy pattern is one of my personal favorites and you've probably seen or used it in some fashion without even knowing it. Its primary purpose is to help you separate the parts of an object which are subject to change from the rest of the static bits. Using Strategy objects versus subclasses can often result in much more flexible code since you're creating a suite of easily swappable algorithms.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Policy</li>
</ul>


<h2>Contrived Example Time!</h2>

<p>Let's say you're making a game and you have a Character class. This game has all sorts of different terrain types so your character can run through open fields, walk slowly through swamps or swim under the ocean. Since you don't know what kind of other terrains the game designer is going to think up you decide that it would be a bad idea to give each character <code>run</code>, <code>walk</code>, and <code>swim</code> methods. After all, what if suddenly the character needs to <code>fly</code> or <code>crawl</code>? What if they're wounded and they need to <code>limp</code>? This situation could potentially get out of hand very fast...</p>

<p>There's a good chance you've seen or written code like this before:</p>

<p>``` js
function move() {</p>

<pre><code>if (state === 'walking') {
    // do some walk animation
} else if (state === 'running') {
    // do some running animation
} else if (state === 'swimming') {
    // do some swimming animation
}
</code></pre>

<p>}
```</p>

<p>When you see a big conditional like that or a switch statement it's time to stop and wonder if there's a better way. For instance if we need to subclass our Character we're going to have to override that big conditional. What if we only want to replace the <code>swimming</code> bit? We'll have to copy and paste the code from the super class for <code>walking</code> and <code>running</code> and then write new code specifically for <code>swimming</code>. And of course if <code>walking</code> and <code>running</code> ever change we're totally screwed.</p>

<h3>We need a Strategy to deal with this</h3>

<p>Ok so we know that our character is going to be a real contortionist and need to run and jump and crab-walk all over the place. What if we took the code that made her run and we put it in its own object? How about we just define a Class for movements and we do this for all the different kinds of motion? Then when we need to move our Character we'll just tell it to defer to one of these Movement objects.</p>

<p>``` js
var Movement = function(func) {</p>

<pre><code>this.move = func;
</code></pre>

<p>};</p>

<p>Movement.prototype.execute = function() {</p>

<pre><code>this.move();
</code></pre>

<p>};</p>

<p>var running = new Movement(function() {</p>

<pre><code>console.log("Hey I'm running!");
</code></pre>

<p>});</p>

<p>var walking = new Movement(function() {</p>

<pre><code>console.log("Just walking along...");
</code></pre>

<p>});
```</p>

<p>Now when we want to tell our character to move in a different way we'll just update which Movement object its currently referencing.</p>

<p>``` js
function changeMovementType(movement) {</p>

<pre><code>this.movement = movement;
</code></pre>

<p>}</p>

<p>function move() {</p>

<pre><code>this.movement.execute();
</code></pre>

<p>}
```</p>

<p>In practice you might have something that looks like this:</p>

<p>``` js
var running = new Movement(function() {</p>

<pre><code>console.log("Hey I'm running!");
</code></pre>

<p>});</p>

<p>var walking = new Movement(function() {</p>

<pre><code>console.log("Just walking along...");
</code></pre>

<p>});</p>

<p>// Create a hero and walk through a peaceful forest...</p>

<p>var hero = new Character();
hero.changeMovementType(walking);
hero.move();</p>

<p>// ... OH NO MOTHERFUCKIN' DINOSAURS!!!</p>

<p>hero.changeMovementType(running);
hero.move();
```</p>

<p>Now it's easy for us to add as many different kinds of motion as our little game designer can dream up. Want to give the character gas-powered robotic legs? No problem!</p>

<p>``` js
var robotlegs = new Movement(function() {</p>

<pre><code>console.log("Cruisin for oil...Look out humans!");
</code></pre>

<p>});</p>

<p>hero.changeMovementType(robotlegs);
hero.move();
```</p>

<h2>When to use it</h2>

<p>When you have a part of your Class that's subject to change frequently or perhaps you have many related subclasses which only differ in behavior it's often a good time to consider using a Strategy pattern.</p>

<p>Another benefit of the Strategy pattern is that it can hide complex logic or data that the client doesn't need to know about.</p>

<h2>The Painting App</h2>

<p>For a real world example of when to use Strategy objects consider your typical painting program. Often times you will offer a variety of different brush types to your user but you don’t want to have to change the fundamentals of how a mark shows up on screen every time the user decides to switch from a round to a square brush. Why not wrap those specific implementations in their own brush objects and later on when the user clicks to draw something to screen we’ll just defer to one of those brushes.</p>

<p>``` js
// Grab a reference to the canvas and the drawing context
$canvas = $('#painter');
context = $canvas[0].getContext('2d');</p>

<p>// Define our brush strategy objects
brushes = {
  outline: {</p>

<pre><code>  draw: function(e, context) {
      context.strokeRect(e.pageX - offsetLeft, e.pageY - offsetTop, 10, 10);
  }
</code></pre>

<p>  },
  square: {</p>

<pre><code>  draw: function(e, context) {
      context.fillRect(e.pageX - offsetLeft, e.pageY - offsetTop, 10, 10);
  }
</code></pre>

<p>  },
  circle: {</p>

<pre><code>  draw: function(e, context) {
      context.arc(e.pageX - offsetLeft, e.pageY - offsetTop, 10, 0, Math.PI * 2);
      context.fill();
  }
</code></pre>

<p>  }
};</p>

<p>... .</p>

<p>brush = brushes.square;
```</p>

<p>Here we see that <code>brushes.outline</code>, <code>brushes.square</code>, and <code>brushes.circle</code> each implement a consistent interface for the <code>draw</code> call. However their exact implementation changes from one brush to the next. <code>brushes.outline</code> will only draw the stroke of a rectangle, whereas <code>brushes.square</code> and <code>brushes.circle</code> will fill their respective shapes in. Elsewhere in the program we set our initial brush to a default of brushes.square. When the users presses their mouse and moves it around screen we can defer to whichever Strategy the brush object is currently referencing:</p>

<p>``` js
// Listen for mouse events on the canvas
$canvas
  .on('mousedown', function() {</p>

<pre><code>  isDrawing = true;
</code></pre>

<p>  })
  .on('mouseup mouseleave', function() {</p>

<pre><code>  isDrawing = false;
</code></pre>

<p>  })
  .on('mousemove', function(e) {</p>

<pre><code>  if (isDrawing) {
      // Defer drawing to a Strategy object
      brush.draw(e, context);
  }
</code></pre>

<p>  });
```</p>

<p>Again notice that <code>.on('mousemove')</code> we first check to see if it’s ok to draw something and then defer to whichever Strategy is currently being referenced. Using this approach we can add limitless new brush types to the <code>brushes</code> object and easily change how our program performs at runtime. Be sure to check out the live example and the source for the full application.</p>

<h3><a href="http://robdodson.s3.amazonaws.com/javascript-design-patterns/strategy/painter/index.html">Live Example</a></h3>

<h3><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/strategy/painter">Source</a></h3>

<h2>Related Patterns</h2>

<ul>
<li>Flyweight: Strategy objects often make good flyweights.</li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Table of Contents]]></title>
    <link href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/"/>
    <updated>2012-08-03T09:39:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/03/javascript-design-patterns</id>
    <content type="html"><![CDATA[<h3>Creational</h3>

<ul>
<li>Abstract Factory</li>
<li>Builder</li>
<li>Factory Method</li>
<li>Object Pool</li>
<li>Prototype</li>
<li><a href="http://robdodson.me/blog/2012/08/08/javascript-design-patterns-singleton/">Singleton</a></li>
</ul>


<h3>Structural</h3>

<ul>
<li>Adapter</li>
<li>Bridge</li>
<li>Composite</li>
<li>Decorator</li>
<li>Facade</li>
<li>Flyweight</li>
<li>Private Class Data</li>
<li>Proxy</li>
</ul>


<h3>Behavioral</h3>

<ul>
<li>Chain of Responsibility</li>
<li>Command</li>
<li>Interpreter</li>
<li><a href="http://robdodson.me/blog/2012/08/10/javascript-design-patterns-iterator/">Iterator</a></li>
<li>Mediator</li>
<li>Memento</li>
<li>Null Object</li>
<li>Observer</li>
<li>State</li>
<li><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy/">Strategy</a></li>
<li>Template Method</li>
<li>Visitor</li>
<li>Monad Pattern / Promises</li>
</ul>


<p>I've been trying to think up <a href="http://robdodson.me/blog/2012/06/25/ending-my-first-chain/">a new chain</a> since coming back from Europe but nothing was enticing me. Then a few days ago I had a conversation with one of my friends in which we discussed using Promises in JavaScript. And later on we discussed Builders. I was doing my best to explain the two but really wished that I had a resource where I could just show some simple code examples. It occurred to me that I've always wanted to go through the <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?ie=UTF8&amp;qid=1344014497&amp;sr=8-1&amp;keywords=design+patterns">Gang of Four book</a> and just write my own interpretation of each pattern. Since I'm currently working primarily in JavaScript I thought it might be an interesting challenge to convert their examples, often in strongly typed languages, to something as dynamic and loosey-goosey as JS.</p>

<!--more-->


<p>I know there are a lot of people out there who <a href="http://www.codinghorror.com/blog/2005/09/head-first-design-patterns.html">aren't too</a> <a href="http://thinkrelevance.com/blog/2007/05/17/design-patterns-are-code-smells">keen on</a> design patterns but that's not to say that they shouldn't be used or studied. There's a lot of code out there that starts with <code>jQuery.click()</code> or <code>addEventListener</code> or <code>.on()</code> and all of them are implementations of the Observer pattern. Finding this reusable approach is the main point of patterns and along with it comes a shared vocabulary that can be passed on to other developers. Rather than saying "Let's defer the methods of our object that are subject to change to well encapsulated algorithms." We can just say "A Strategy pattern might be nice here."</p>

<p>Patterns should be used with caution as not everything fits so neatly into their paradigms. It's often said that a beginner never met a pattern he didn't like. In my experiences I've been burned by pattern overuse and at other times they have legitimately saved my ass. It's also true that many patterns don't really work or aren't appropriate for particular languages. For instance, the GoF book was written <em>primarily for languages which shared features of C++ and SmallTalk</em>. I totally agree with this sentiment but I feel like along the way we'll discover what does and doesn't make sense in a dynamic language like JS and hopefully we can toss in some new patterns of our own. Already to the list I've added Promises which I use quite frequently and find to be a wonderful alternative to JavaScript's oft seen pyramid of callbacks.
Again, this is all about learning and experimenting. In my opinion a good understanding of design patterns is a threshold that needs to be crossed at some point in your career. I'm committed to doing this every single day for the next few weeks so hopefully by the end of it we'll have a useful resource that others can benefit from. Stay tuned!</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Your Backbone Views with the State Pattern]]></title>
    <link href="http://robdodson.me/blog/2012/06/02/managing-your-backbone-views-with-the-state-pattern/"/>
    <updated>2012-06-02T18:22:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/02/managing-your-backbone-views-with-the-state-pattern</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten/">Yesterday I wrote a post to illustrate the concepts behind the State pattern</a> (one of my all time favorite tools). If you're new to this pattern and haven't read my previous post I suggest you start there and read this one after you've had a chance to play around with the ideas.</p>

<!--more-->


<p>I wanted to write about this pattern in the context of a Backbone app because I think there's a lot of value in exploring different ways to manage our Views and Models. Here's an example Video Player in which several State objects inherit from a common ancestor, <code>BaseState</code>. I chose to make <code>BaseState</code> extend <code>Backbone.Model</code> because it seemed like the best fit for this kind of thing, although typically when I implement this pattern in other languages I just use generic Objects. I would have done that here but Backbone's <code>extend</code> functionality makes the code so much cleaner.</p>

<p>``` js
var BaseState = Backbone.Model.extend({
  initialize: function(owner) {</p>

<pre><code>this.owner = owner;
</code></pre>

<p>  },
  enter: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  },
  execute: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>console.log('changing to the playing state...');
this.owner.changeState(this.owner.states.playing);
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>console.log('changing to the stopping state...')
this.owner.changeState(this.owner.states.stopping);
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>console.log('changing to the pausing state...')
this.owner.changeState(this.owner.states.pausing);
</code></pre>

<p>  },
  exit: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  }
});</p>

<p>var PlayingState = BaseState.extend({
  execute: function() {</p>

<pre><code>console.log('playing the video!');
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>console.log('already playing!');
</code></pre>

<p>  }
});</p>

<p>var StoppingState = BaseState.extend({
  enter: function() {</p>

<pre><code>console.log('we have entered the stopping state...');
</code></pre>

<p>  },
  execute: function() {</p>

<pre><code>console.log('stopping the video...');
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>console.log('already stopped!');
</code></pre>

<p>  }
});</p>

<p>var PausingState = BaseState.extend({
  execute: function() {</p>

<pre><code>console.log('pausing the video.');
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>console.log('already paused!');
</code></pre>

<p>  }
});
```</p>

<p>Every state inherits from <code>BaseState</code> which means they all create a reference to an <code>owner</code> object in their <code>initialize</code> methods. The <code>owner</code> is going to be our actual <code>VideoPlayer</code> object. Rather than having <code>videoPlayer.play</code> lead to some big weird conditional:</p>

<p>``` js
play: function() {
  if (this.status == 'playing') {</p>

<pre><code>  return;
</code></pre>

<p>  } else if (this.status == 'stopped') {</p>

<pre><code>  // play the video
</code></pre>

<p>  } else if (this.status == 'paused') {</p>

<pre><code>  // unpause and play
</code></pre>

<p>  }
  else if ...
}
```</p>

<p>we're instead going to delegate the work to our State objects. They'll handle switching from one State to the next and so long as we provide the exact same public API methods in each, they should be interchangeable. Inheriting from the same BaseState ensures that all of the States have the same public methods and each State can choose how or if it wants to override them. In our example the <code>StoppingState</code> overrides the <code>enter</code> method to display some text as we're transitioning into this state. Again, you can override some or all of the methods, <code>enter</code> and <code>exit</code> are great for building up/tearing down anything that our state might need and <code>execute</code> is where the main work of our state should happen.</p>

<p>Let's take a look at the <code>VideoPlayer</code> which is a <code>Backbone.View</code> that will leverage our State objects:</p>

<p>``` js
var VideoPlayer = Backbone.View.extend({
  initialize: function() {</p>

<pre><code>this.states = {};
this.states.playing = new PlayingState(this);
this.states.stopping = new StoppingState(this);
this.states.pausing = new PausingState(this);
this.changeState(this.states.pausing);
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>this.state.play();
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>this.state.stop();
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>this.state.pause();
</code></pre>

<p>  },
  changeState: function(state) {</p>

<pre><code>// Make sure the current state wasn't passed in
if (this.state !== state) {
  // Make sure the current state exists before
  // calling exit() on it
  if (this.state) {
    this.state.exit();
  }
  this.state = state;
  this.state.enter();
  this.state.execute();
}
</code></pre>

<p>  }
});
<code>``
You'll notice that</code>VideoPlayer<code>instantiates its own State objects when it is first created. Then whenever we call one of its public methods the call is delegated to whichever state object is currently residing in</code>this.state`.</p>

<p>Let's instantiate a new VideoPlayer to see it in action:</p>

<p>``` js
var videoPlayer = new VideoPlayer();</p>

<p>=> 'pausing the video.'</p>

<p>videoPlayer.play();</p>

<p>=> 'changing to the playing state...'
=> 'playing the video!'</p>

<p>videoPlayer.play();</p>

<p>=> 'already playing!'</p>

<p>videoPlayer.stop();</p>

<p>=> 'changing to the stopping state...'
=> 'we have entered the stopping state...'
=> 'stopping the video...'
```</p>

<p>Hopefully this gives you some food for thought the next time you're trying to wrangle some unwieldy component. I cannot count how many times I've used this pattern in other languages to tidy up and organize my code. I'm looking forward to working with it again in Backbone and I'd love to hear anyone's take on how this can be tweaked or improved. Till tomorrow! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 9:48 pm</li>
<li>Mood: Focused, Hurried</li>
<li>Sleep: 5</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
</feed>
