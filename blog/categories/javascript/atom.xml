<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-08-09T08:24:35-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Singleton]]></title>
    <link href="http://robdodson.me/blog/2012/08/08/javascript-design-patterns-singleton/"/>
    <updated>2012-08-08T19:52:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/08/javascript-design-patterns-singleton</id>
    <content type="html"><![CDATA[<p>Ah yes the Singleton, a pattern whose name lives in infamy. For the uninitiated a little explanation is in order. A Singleton is an object which can only be instantiated one time. Repeated calls to its constructor return the same instance and in this way one can ensure that they don't accidentally create, say, two Users in a single User application. Doesn't sound too bad, right? Well, if you're responsible then it arguably <em>is</em> OK but there are many caveats. Before I get into those though, let's throw in the formal definition <em>a la</em> the Gang of Four.</p>

<h2>Formal Definition</h2>

<p><blockquote><p>Ensure a class only has one instance, and provide a global point of access to it.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h2>The icky bits</h2>

<p>So I'm sure some of you are already a little anxious because I used the phrase "global point of access" and rightfully you should be. In OO software design <em>global</em> variables and objects are often frowned upon. They break encapsulation and more often than not cause more harm than good. You don't want the far flung bits of your app to be able to reach all the way up to the very top and fiddle around with stuff. When that starts to happen, and other objects also rely on those global variables, then any piece of code, anywhere in the project can change something which can in turn break a totally unrelated bit of functionality. Debugging becomes a nightmare because you're constantly moving from deeply nested object graphs up to the global scope and then back down again. I one time worked on a <em>major</em> application which I inherited from another developer. It was so riddled with Singletons that any change became a sisyphean ordeal of unintended consiquences and time lost debugging. Needless to say I want to put this warning front and center or else the programming gods would surely smite me.</p>

<h2>Well I'm done! Fuck this shit...</h2>

<p>OK before you start running for the hills I want to point out the ways in which Singletons can be useful and then you can make up your mind if they're right for you.</p>

<p>Let's start with the most obvious one: You're probably already using Singletons!</p>

<p>Ever written any code that looks like this?</p>

<p>``` js
var user = {</p>

<pre><code>firstName: 'John',
lastName: 'Doe',
sayName: function() {
    return this.firstName + ' ' + this.lastName;
}
</code></pre>

<p>};
```</p>

<p>Yep, that's a Singleton. Once you create an object literal in JavaScript you've reserved a little piece of memory and no other object will ever be just like that one. Now, depending on the scope you might have only created a local variable but if that <code>user</code> is sitting outside a function then it's globally available to anyone who wants to fiddle with it. I guess the most famous Singleton probably looks like this: <code>$</code>. To put it another way, ever notice how you can use jQuery anywhere in your app after you've included it on the page...? Boom! Singleton!</p>

<p><em>mind blown</em>  ... <em>face off</em> ...</p>

<h2>OK, So they have their uses I guess</h2>

<p>Yes as much as some are probably loathe to admit it, Singletons are quite useful in JavaScript. And as jQuery demonstrates their primary use is to namespace your code.
While other languages like Java or C# have namespaces built in, JavaScript has to emulate them using simple objects.</p>

<p>Consider the following scenario: You have a series of functions hanging out on the page that you frequently use in your program.</p>

<p>``` js
function login() {</p>

<pre><code>// do some login shtuffs
</code></pre>

<p>}</p>

<p>function logout() {</p>

<pre><code>// do some logout shtuffs
</code></pre>

<p>}</p>

<p>function addToCart() {</p>

<pre><code>// blah, blah blah...
</code></pre>

<p>}
```
A few things are going on here...</p>

<p><em>1. Our functions are polluting the global space.</em>
Since they are just floating around on the page they have to attach to something. With no explicitely declared parent object they get hooked on to the globally available <code>window</code> object.</p>

<p><em>2. They're in danger of being overwritten</em>
If we were to accidentally define another global <code>addToCart</code> function or if we brought in a library whose author did the same, it would overwrite the original leading to a really gnarly debugging situation.</p>

<p>Let's revise this by creating one (and only one) global object which our code can branch off of.</p>

<p>``` js
var NAMESPACE = {};</p>

<p>NAMESPACE.login = function() {</p>

<pre><code>// do some login shtuffs
</code></pre>

<p>}</p>

<p>NAMESPACE.logout = function() {</p>

<pre><code>// do some logout shtuffs
</code></pre>

<p>}</p>

<p>NAMESPACE.addToCart = function() {</p>

<pre><code>// blah, blah blah...
</code></pre>

<p>}
<code>``
Now so long as no one creates an object which also has the name</code>NAMESPACE` our code should be safe. From here we can do all sorts of things. We can nest more object literals or we can create constructor functions:</p>

<p>``` js
var NAMESPACE = {};</p>

<p>NAMESPACE.Widget = function(foo, bar) {</p>

<pre><code>// Some awesome widget code
</code></pre>

<p>}</p>

<p>NAMESPACE.Widget.prototype.doSomethingAwesome = function() {</p>

<pre><code>// do something awesome!!!
</code></pre>

<p>}</p>

<p>var myWidget = new NAMESPACE.Widget('hello', 'world');
```
Take a look at <a href="https://github.com/mrdoob/three.js/">the Three.js library which</a> relies heavily on this pattern to structure its code.</p>

<h2>But I like constructors!</h2>

<p>OK so maybe object literals aren't your thing. That's understandable so let me show you a few other ways of writing Singletons.</p>

<p>These first few come from Stoyan Stefanov's excellent book <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns.</a></p>

<p><strong>Singleton with a cached static property</strong></p>

<p>``` js
function User() {</p>

<pre><code>// do we have an existing instance?
if (typeof User.instance === 'object') {
    return User.instance;
}

// proceed as normal
this.firstName = 'John';
this.lastName = 'Doe';

// cache
User.instance = this;

// implicit return
// return this;
</code></pre>

<p>}
<code>``
The cached static property is publicly available which adds a little danger (someone could say</code>Universe.instance = foo`) but this version is very straightforward and doesn't require closures and funky prototype work. If you're lazy this might be a good approach.</p>

<p><strong>Singleton with a closure</strong></p>

<p>``` js
function User() {</p>

<pre><code>// the cached instance
var instance;

// rewrite the constructor
User = function() {
    return instance;
};

// carry over the prototype
User.prototype = this;

// the instance
instance = new User();

// reset the constructor pointer
instance.constructor = User;

// all the functionality
instance.firstName = 'John';
instance.lastName = 'Doe';

return instance;
</code></pre>

<p>}
```</p>

<p>This version takes a bit of fiddling to get the prototype to work as expected because we rewrite the constructor. The upshot is that <code>instance</code> is now private (being contained within the closure).</p>

<p><strong>Singleton with a self executing function</strong></p>

<p>``` js
var User;
(function() {</p>

<pre><code>var instance;

User = function User() {
    if (instance) {
        return instance;
    }

    instance = this;

    // all the functionality
    this.firstName = 'John';
    this.lastName = 'Doe';
};
</code></pre>

<p>}());
```
By wrapping the instance variable in a self executing function we make it private. This version doesn't require any prototype or constructor reassignment but it may potentially confuse people who aren't comfortable with self executing functions.</p>

<p>Addy Osmani also defines a Singleton pattern in his book <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript">Essential JavaScript Design Patterns.</a></p>

<p>``` js
var mySingleton = (function () {</p>

<p>  // Instance stores a reference to the Singleton
  var instance;</p>

<p>  function init() {</p>

<pre><code>// Singleton

// Private methods and variables
function privateMethod(){
    console.log( "I am private" );
}

var privateVariable = "Im also private";

return {

  // Public methods and variables
  publicMethod: function () {
    console.log( "The public can see me!" );
  },

  publicProperty: "I am also public"
};
</code></pre>

<p>  };</p>

<p>  return {</p>

<pre><code>// Get the Singleton instance if one exists
// or create one if it doesn't
getInstance: function () {

  if ( !instance ) {
    instance = init();
  }

  return instance;
}
</code></pre>

<p>  };</p>

<p>})();</p>

<p>// Usage:</p>

<p>var singleA = mySingleton;
var singleB = mySingleton;
console.log( singleA === singleB ); // true
```</p>

<p>This much more elaborate example allows us to define both private and public methods of our Singleton object at the cost of being a bit more complex than all the others.</p>

<p>As Addy is quick to point out:</p>

<blockquote><p>Whilst the Singleton has valid uses, often when we find ourselves needing it in JavaScript it's a sign that we may need to re-evaluate our design.</p>

<p>They're often an indication that modules in a system are either tightly coupled or that logic is overly spread across multiple parts of a codebase. Singletons can be more difficult to test due to issues ranging from hidden dependencies, the difficulty in creating multiple instances, difficulty in stubbing dependencies and so on.</p></blockquote>

<p>Definitely read <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript">his full article</a> on the subject since it contains a handful of links to interesting side topics.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Strategy]]></title>
    <link href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy/"/>
    <updated>2012-08-03T15:12:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy</id>
    <content type="html"><![CDATA[<p>The Strategy pattern is one of my personal favorites and you've probably seen or used it in some fashion without even knowing it. Its primary purpose is to help you separate the parts of an object which are subject to change from the rest of the static bits. Using Strategy objects versus subclasses can often result in much more flexible code since you're creating a suite of easily swappable algorithms.</p>

<h2>Formal Definition</h2>

<p><blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Policy</li>
</ul>


<h2>Contrived Example Time!</h2>

<p>Let's say you're making a game and you have a Character class. This game has all sorts of different terrain types so your character can run through open fields, walk slowly through swamps or swim under the ocean. Since you don't know what kind of other terrains the game designer is going to think up you decide that it would be a bad idea to give each character <code>run</code>, <code>walk</code>, and <code>swim</code> methods. After all, what if suddenly the character needs to <code>fly</code> or <code>crawl</code>? What if they're wounded and they need to <code>limp</code>? This situation could potentially get out of hand very fast...</p>

<p>There's a good chance you've seen or written code like this before:</p>

<p>``` js
function move() {</p>

<pre><code>if (state === 'walking') {
    // do some walk animation
} else if (state === 'running') {
    // do some running animation
} else if (state === 'swimming') {
    // do some swimming animation
}
</code></pre>

<p>}
```</p>

<p>When you see a big conditional like that or a switch statement it's time to stop and wonder if there's a better way. For instance if we need to subclass our Character we're going to have to override that big conditional. What if we only want to replace the <code>swimming</code> bit? We'll have to copy and paste the code from the super class for <code>walking</code> and <code>running</code> and then write new code specifically for <code>swimming</code>. And of course if <code>walking</code> and <code>running</code> ever change we're totally screwed.</p>

<h3>We need a Strategy to deal with this</h3>

<p>Ok so we know that our character is going to be a real contortionist and need to run and jump and crab-walk all over the place. What if we took the code that made her run and we put it in its own object? How about we just define a Class for movements and we do this for all the different kinds of motion? Then when we need to move our Character we'll just tell it to defer to one of these Movement objects.</p>

<p>``` js
var Movement = function(func) {</p>

<pre><code>this.move = func;
</code></pre>

<p>};</p>

<p>Movement.prototype.execute = function() {</p>

<pre><code>this.move();
</code></pre>

<p>};</p>

<p>var running = new Movement(function() {</p>

<pre><code>console.log("Hey I'm running!");
</code></pre>

<p>});</p>

<p>var walking = new Movement(function() {</p>

<pre><code>console.log("Just walking along...");
</code></pre>

<p>});
```</p>

<p>Now when we want to tell our character to move in a different way we'll just update which Movement object its currently referencing.</p>

<p>``` js
function changeMovementType(movement) {</p>

<pre><code>this.movement = movement;
</code></pre>

<p>}</p>

<p>function move() {</p>

<pre><code>this.movement.execute();
</code></pre>

<p>}
```</p>

<p>In practice you might have something that looks like this:</p>

<p>``` js
var running = new Movement(function() {</p>

<pre><code>console.log("Hey I'm running!");
</code></pre>

<p>});</p>

<p>var walking = new Movement(function() {</p>

<pre><code>console.log("Just walking along...");
</code></pre>

<p>});</p>

<p>// Create a hero and walk through a peaceful forest...</p>

<p>var hero = new Character();
hero.changeMovementType(walking);
hero.move();</p>

<p>// ... OH NO MOTHERFUCKIN' DINOSAURS!!!</p>

<p>hero.changeMovementType(running);
hero.move();
```</p>

<p>Now it's easy for us to add as many different kinds of motion as our little game designer can dream up. Want to give the character gas-powered robotic legs? No problem!</p>

<p>``` js
var robotlegs = new Movement(function() {</p>

<pre><code>console.log("Cruisin for oil...Look out humans!");
</code></pre>

<p>});</p>

<p>hero.changeMovementType(robotlegs);
hero.move();
```</p>

<h2>When to use it</h2>

<p>When you have a part of your Class that's subject to change frequently or perhaps you have many related subclasses which only differ in behavior it's often a good time to consider using a Strategy pattern.</p>

<p>Another benefit of the Strategy pattern is that it can hide complex logic or data that the client doesn't need to know about.</p>

<h2>Real World Examples</h2>

<p>Let's say you're designing a website with all kinds of different, interesting button animations. Sometimes buttons should expand when rolled over, other times they should fade and maybe some will change colors. You could have several button classes or jQuery selections but you'd be repeating a ton of code just for the sake of a little animation algorithm. Let's see if we can write some strategy objects which solve this problem for us and give us a nice toolbox to work from.</p>

<p>``` js
var ButtonAnimation = function(context, animation) {</p>

<pre><code>this.context = context;
this.animation = func;
</code></pre>

<p>}
```</p>

<h3>Bocoup example</h3>

<h2>Related Patterns</h2>

<p>Flyweight: Strategy objects often make good flyweights.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns]]></title>
    <link href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/"/>
    <updated>2012-08-03T09:39:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/03/javascript-design-patterns</id>
    <content type="html"><![CDATA[<h2>Table of Contents</h2>

<h3>Creational</h3>

<ul>
<li>Abstract Factory</li>
<li>Builder</li>
<li>Factory Method</li>
<li>Object Pool</li>
<li>Prototype</li>
<li>Singleton</li>
</ul>


<h3>Structural</h3>

<ul>
<li>Adapter</li>
<li>Bridge</li>
<li>Composite</li>
<li>Decorator</li>
<li>Facade</li>
<li>Flyweight</li>
<li>Private Class Data</li>
<li>Proxy</li>
</ul>


<h3>Behavioral</h3>

<ul>
<li>Chain of Responsibility</li>
<li>Command</li>
<li>Interpreter</li>
<li>Iterator</li>
<li>Mediator</li>
<li>Memento</li>
<li>Null Object</li>
<li>Observer</li>
<li>State</li>
<li>Strategy</li>
<li>Template Method</li>
<li>Visitor</li>
<li>Monad Pattern / Promises</li>
</ul>


<p>I've been trying to think up <a href="http://robdodson.me/blog/2012/06/25/ending-my-first-chain/">a new chain</a> since coming back from Europe but nothing was enticing me. Then a few days ago I had a conversation with one of my friends in which we discussed using Promises in JavaScript. And later on we discussed Builders. I was doing my best to explain the two but really wished that I had a resource where I could just show some simple code examples. It occurred to me that I've always wanted to go through the <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?ie=UTF8&amp;qid=1344014497&amp;sr=8-1&amp;keywords=design+patterns">Gang of Four book</a> and just write my own interpretation of each pattern. Since I'm currently working primarily in JavaScript I thought it might be an interesting challenge to convert their examples, often in strongly typed languages, to something as dynamic and loosey-goosey as JS.</p>

<p>I know there are a lot of people out there who <a href="http://www.codinghorror.com/blog/2005/09/head-first-design-patterns.html">aren't too</a> <a href="http://thinkrelevance.com/blog/2007/05/17/design-patterns-are-code-smells">keen on</a> design patterns but that's not to say that they shouldn't be used or studied. There's a lot of code out there that starts with <code>jQuery.click()</code> or <code>addEventListener</code> or <code>.on()</code> and all of them are implementations of the Observer pattern. Finding this reusable approach is the main point of patterns and along with it comes a shared vocabulary that can be passed on to other developers. Rather than saying "Let's defer the methods of our object that are subject to change to well encapsulated algorithms." We can just say "A Strategy pattern might be nice here."</p>

<p>Patterns should be used with caution as not everything fits so neatly into their paradigms. It's often said that a beginner never met a pattern he didn't like. In my experiences I've been burned by pattern overuse and at other times they have legitimately saved my ass. It's also true that many patterns don't really work or aren't appropriate for particular languages. For instance, the GoF book was written <em>primarily for languages which shared features of C++ and SmallTalk</em>. I totally agree with this sentiment but I feel like along the way we'll discover what does and doesn't make sense in a dynamic language like JS and hopefully we can toss in some new patterns of our own. Already to the list I've added Promises which I use quite frequently and find to be a wonderful alternative to JavaScript's oft seen pyramid of callbacks.
Again, this is all about learning and experimenting. In my opinion a good understanding of design patterns is a threshold that needs to be crossed at some point in your career. I'm committed to doing this every single day for the next few weeks so hopefully by the end of it we'll have a useful resource that others can benefit from. Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Your Backbone Views with the State Pattern]]></title>
    <link href="http://robdodson.me/blog/2012/06/02/managing-your-backbone-views-with-the-state-pattern/"/>
    <updated>2012-06-02T18:22:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/02/managing-your-backbone-views-with-the-state-pattern</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten/">Yesterday I wrote a post to illustrate the concepts behind the State pattern</a> (one of my all time favorite tools). If you're new to this pattern and haven't read my previous post I suggest you start there and read this one after you've had a chance to play around with the ideas.</p>

<p>I wanted to write about this pattern in the context of a Backbone app because I think there's a lot of value in exploring different ways to manage our Views and Models. Here's an example Video Player in which several State objects inherit from a common ancestor, <code>BaseState</code>. I chose to make <code>BaseState</code> extend <code>Backbone.Model</code> because it seemed like the best fit for this kind of thing, although typically when I implement this pattern in other languages I just use generic Objects. I would have done that here but Backbone's <code>extend</code> functionality makes the code so much cleaner.</p>

<p>``` js
var BaseState = Backbone.Model.extend({
  initialize: function(owner) {</p>

<pre><code>this.owner = owner;
</code></pre>

<p>  },
  enter: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  },
  execute: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>console.log('changing to the playing state...');
this.owner.changeState(this.owner.states.playing);
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>console.log('changing to the stopping state...')
this.owner.changeState(this.owner.states.stopping);
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>console.log('changing to the pausing state...')
this.owner.changeState(this.owner.states.pausing);
</code></pre>

<p>  },
  exit: function() {</p>

<pre><code>// Implement me in your state objects
</code></pre>

<p>  }
});</p>

<p>var PlayingState = BaseState.extend({
  execute: function() {</p>

<pre><code>console.log('playing the video!');
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>console.log('already playing!');
</code></pre>

<p>  }
});</p>

<p>var StoppingState = BaseState.extend({
  enter: function() {</p>

<pre><code>console.log('we have entered the stopping state...');
</code></pre>

<p>  },
  execute: function() {</p>

<pre><code>console.log('stopping the video...');
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>console.log('already stopped!');
</code></pre>

<p>  }
});</p>

<p>var PausingState = BaseState.extend({
  execute: function() {</p>

<pre><code>console.log('pausing the video.');
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>console.log('already paused!');
</code></pre>

<p>  }
});
```</p>

<p>Every state inherits from <code>BaseState</code> which means they all create a reference to an <code>owner</code> object in their <code>initialize</code> methods. The <code>owner</code> is going to be our actual <code>VideoPlayer</code> object. Rather than having <code>videoPlayer.play</code> lead to some big weird conditional:</p>

<p>``` js
play: function() {
  if (this.status == 'playing') {</p>

<pre><code>  return;
</code></pre>

<p>  } else if (this.status == 'stopped') {</p>

<pre><code>  // play the video
</code></pre>

<p>  } else if (this.status == 'paused') {</p>

<pre><code>  // unpause and play
</code></pre>

<p>  }
  else if ...
}
```</p>

<p>we're instead going to delegate the work to our State objects. They'll handle switching from one State to the next and so long as we provide the exact same public API methods in each, they should be interchangeable. Inheriting from the same BaseState ensures that all of the States have the same public methods and each State can choose how or if it wants to override them. In our example the <code>StoppingState</code> overrides the <code>enter</code> method to display some text as we're transitioning into this state. Again, you can override some or all of the methods, <code>enter</code> and <code>exit</code> are great for building up/tearing down anything that our state might need and <code>execute</code> is where the main work of our state should happen.</p>

<p>Let's take a look at the <code>VideoPlayer</code> which is a <code>Backbone.View</code> that will leverage our State objects:</p>

<p>``` js
var VideoPlayer = Backbone.View.extend({
  initialize: function() {</p>

<pre><code>this.states = {};
this.states.playing = new PlayingState(this);
this.states.stopping = new StoppingState(this);
this.states.pausing = new PausingState(this);
this.changeState(this.states.pausing);
</code></pre>

<p>  },
  play: function() {</p>

<pre><code>this.state.play();
</code></pre>

<p>  },
  stop: function() {</p>

<pre><code>this.state.stop();
</code></pre>

<p>  },
  pause: function() {</p>

<pre><code>this.state.pause();
</code></pre>

<p>  },
  changeState: function(state) {</p>

<pre><code>// Make sure the current state wasn't passed in
if (this.state !== state) {
  // Make sure the current state exists before
  // calling exit() on it
  if (this.state) {
    this.state.exit();
  }
  this.state = state;
  this.state.enter();
  this.state.execute();
}
</code></pre>

<p>  }
});
<code>``
You'll notice that</code>VideoPlayer<code>instantiates its own State objects when it is first created. Then whenever we call one of its public methods the call is delegated to whichever state object is currently residing in</code>this.state`.</p>

<p>Let's instantiate a new VideoPlayer to see it in action:</p>

<p>``` js
var videoPlayer = new VideoPlayer();</p>

<p>=> 'pausing the video.'</p>

<p>videoPlayer.play();</p>

<p>=> 'changing to the playing state...'
=> 'playing the video!'</p>

<p>videoPlayer.play();</p>

<p>=> 'already playing!'</p>

<p>videoPlayer.stop();</p>

<p>=> 'changing to the stopping state...'
=> 'we have entered the stopping state...'
=> 'stopping the video...'
```</p>

<p>Hopefully this gives you some food for thought the next time you're trying to wrangle some unwieldy component. I cannot count how many times I've used this pattern in other languages to tidy up and organize my code. I'm looking forward to working with it again in Backbone and I'd love to hear anyone's take on how this can be tweaked or improved. Till tomorrow! - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 9:48 pm</li>
<li>Mood: Focused, Hurried</li>
<li>Sleep: 5</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Take Control of your App with the JavaScript State Pattern]]></title>
    <link href="http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten/"/>
    <updated>2012-06-02T00:09:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/06/02/take-control-of-your-app-with-the-javascript-state-patten</id>
    <content type="html"><![CDATA[<p>Last week I wrote a post about <a href="http://robdodson.me/blog/2012/05/25/backbone-events-framework-communication/">communicating between views in Backbone.js</a> and since then it has easily become my most popular article. The comments have forced me to think about the ways in which I typically manage state in very large Flash applications and how that might translate to JavaScript and Backbone. Today I want to present my all time favorite design pattern, the State pattern, and illustrate how it can help you maintain control of your application. I want to warn you that I'm going to show a rather large block of what looks like repetitive code because I want the pattern to be obvious. In tomorrow's post we'll clean it up and try it out with a Backbone Model and View.</p>

<h3>The State pattern?</h3>

<p>Ok let's get started. I want to write a video player so I'm going to need an object that can handle <code>play</code>, <code>stop</code> and <code>pause</code> states. I would say that there are probably a ton of video players out there that have <code>play</code>, <code>stop</code> and <code>pause</code> methods on them, and I bet many look kind of like this:</p>

<p>``` js
play: function() {</p>

<pre><code>if (this.status == 'playing') {
    return;
} else if (this.status == 'stopped') {
    // play the video
} else if (this.status == 'paused') {
    // unpause and play
}
else if ...
</code></pre>

<p>}
```</p>

<p>Or maybe instead of a long conditional there's a switch statement or something. But <em>essentially</em> you're querying some variable somewhere to check what state the object is in and you're branching your logic as a result. Now, I would argue that this is a really brittle process and probably error prone. You could imagine that in each of those conditional blocks there might be several lines of code: preparing to play, stopping the video, tearing down this or that... Or perhaps if you're moving from one state to another you want to animate something on screen, maybe do some ajax, who knows!? Really no matter what you're doing if you're tossing it into these big conditionals it's going to become a nightmare to manage.</p>

<p>Alternatives? Ok, let's think of our video player in terms of the actions that it performs. Our player can play, it can stop and it can pause. What if instead of play, pause and stop acting as methods on our object, we make each of those states into its <em>own</em> object? So when the play state object is told to play it says 'Hey! I'm already playing. No need to change' and when it's told to stop it says 'Ah stopping, eh? Let me defer to my friend the Stop state object'.</p>

<p>To illustrate this I've written a very simple player which just logs what it's doing as you ask it to change state. I want to point out that this code is neither DRY nor very useful in a real world situation but it's intended to illustrate a point. Hopefully when you see the repetition you'll quickly say to yourself 'Hey! Those state objects could be made into a more general/abstract parent object.' That would be the correct mindset but I thought that if I skipped this part the pattern might not be obvious for those new to it.</p>

<p>``` js
var player = {</p>

<pre><code>state: undefined,
states: {
    playing: {
        initialize: function(target) {
            this.target = target;
        },
        enter: function() {
            console.log('setting up the playing state');
        },
        execute: function() {
            console.log('playing!');
        },
        play: function() {
            console.log('already playing!');
        },
        stop: function() {
            this.target.changeState(this.target.states.stopping);
        },
        pause: function() {
            this.target.changeState(this.target.states.pausing);
        },
        exit: function() {
            console.log('tearing down the playing state');
        }
    },
    stopping: {
        initialize: function(target) {
            this.target = target;
        },
        enter: function() {
            console.log('setting up the stopping state');
        },
        execute: function() {
            console.log('stopping!');
        },
        play: function() {
            this.target.changeState(this.target.states.playing);
        },
        stop: function() {
            console.log('already stopped!');
        },
        pause: function() {
            this.target.changeState(this.target.states.pausing);
        },
        exit: function() {
            console.log('tearing down the stopping state');                
        }
    },
    pausing: {
        initialize: function(target) {
            this.target = target;
        },            
        enter: function() {
            console.log('setting up the pausing state');
        },
        execute: function() {
            console.log('pausing!');
        },
        play: function() {
            this.target.changeState(this.target.states.playing);
        },
        stop: function() {
            this.target.changeState(this.target.states.stopping);
        },
        pause: function() {
            console.log('already paused!');
        },
        exit: function() {
            console.log('tearing down the pausing state!');                
        }
    }
},
initialize: function() {
    this.states.playing.initialize(this);
    this.states.stopping.initialize(this);
    this.states.pausing.initialize(this);
    this.state = this.states.stopping;
},
play: function() {
    this.state.play();
},
stop: function() {
    this.state.stop();
},
pause: function() {
    this.state.pause();
},
changeState: function(state) {
    if (this.state !== state) {
        this.state.exit();
        this.state = state;
        this.state.enter();
        this.state.execute();
    }
}
</code></pre>

<p>};
```</p>

<p>Lots of code, I know. But there is serious value in digesting this pattern so stick with me here and I'll go through it bit by bit. Let's start at the top where we define our object:</p>

<p>``` js
var player = {</p>

<pre><code>state: undefined,
states: {
    playing: {
        initialize: function(target) {
            this.target = target;
        },
        enter: function() {
            console.log('setting up the playing state');
        },
        execute: function() {
            console.log('playing!');
        },
        play: function() {
            console.log('already playing!');
        },
        stop: function() {
            this.target.changeState(this.target.states.stopping);
        },
        pause: function() {
            this.target.changeState(this.target.states.pausing);
        },
        exit: function() {
            console.log('tearing down the playing state');
        }
    },
</code></pre>

<p>... .
<code>``
First we declare our object and give it a property of</code>state<code>which we set to</code>undefined` for now. We're going to be creating state object to delegate all of our method calls to so once we're ready to use our player we'll set its initial state.</p>

<p>The <code>states</code> object (note the plurality) holds all of the different state objects that our player can use. In this version we've defined <code>playing</code>, <code>stopping</code> and <code>pausing</code> but you could also add states like <code>buffering</code> or <code>initializing</code>. Keep in mind that this pattern can be applied to just about anything. For instance, if you were making a game with an old prospector his state objects could be <code>mining</code>, <code>drinking</code> and <code>sleeping</code>. The main thing to remember is that <strong>your state objects should all define the exact same public methods</strong>.</p>

<p>We can skip the <code>stopping</code> and <code>pausing</code> states since they're nearly identical to the <code>playing</code> state. Instead let's jump down to the bottom and look at the last bit.</p>

<p>``` js
initialize: function() {</p>

<pre><code>this.states.playing.initialize(this);
this.states.stopping.initialize(this);
this.states.pausing.initialize(this);
this.state = this.states.stopping;
</code></pre>

<p>},
play: function() {</p>

<pre><code>this.state.play();
</code></pre>

<p>},
stop: function() {</p>

<pre><code>this.state.stop();
</code></pre>

<p>},
pause: function() {</p>

<pre><code>this.state.pause();
</code></pre>

<p>},
changeState: function(state) {</p>

<pre><code>if (this.state !== state) {
    this.state.exit();
    this.state = state;
    this.state.enter();
    this.state.execute();
}
</code></pre>

<p>}
```</p>

<p>In our player's initialize function we give each state a reference to the player object so we can tell it to <code>changeState</code>. We also set our initial state to be the stopping state.</p>

<p>Now let's look at the <code>play</code> method. Do you see how it defers the call to whatever object is currently set as the player's <code>state</code>? Since <code>this.state</code> refers to <code>this.states.stopping</code> we're effectively calling the <code>play</code> method of the <code>stopping</code> state object. Go look at the other state objects to see how they respond to having their <code>play</code> methods called. In the case of <code>states.stopping</code>, calling <code>play</code> is going to tell its <code>target</code> (which is just a reference to the player) to <code>changeState</code>, passing in the <code>states.playing</code> state.</p>

<p><code>changeState</code> is kind of an awesome method because it does a ton of work but it does it very elegantly and efficiently. For starters it makes sure that the state we've asked to change to is actually different than our current state. Then it tells our current state to <code>exit()</code>. A state's <code>exit()</code> method is a great place to tear down any constructs that we may have built to support that action. Next it sets our current state to the new state. Lastly, it calls <code>enter()</code> (a good place to build up supporting constructs) and <code>execute()</code>, which is where we do the main work of our state. That's pretty straightforward right?</p>

<p>Since <code>play</code>, <code>pause</code> and <code>stop</code> are members of our player's public API, <strong>all of our states must also implement those methods.</strong> Otherwise you would get an error if you called <code>play()</code> on the object and its state did not support that method. Keep this in mind when you're designing your state objects.</p>

<h3>Aaaaand we're off!</h3>

<p>Let's look at our player in action:</p>

<p>```
// We start off in the stopping state
// So when we call stop...
player.initialize();
player.stop();</p>

<p>=> 'already stopped!'</p>

<p>// Let's move to the playing state
player.play();</p>

<p>=> 'tearing down the stopping state'
=> 'setting up the playing state'
=> 'playing!'</p>

<p>// Quick call pause!
player.pause();</p>

<p>=> 'tearing down the playing state'
=> 'setting up the pausing state'
=> 'pausing!'</p>

<p>// Um... call pause like 3 times cuz
// I'm a button masher!!!
player.pause();
player.pause();
player.pause();</p>

<p>=> 'already paused!'
=> 'already paused!'
=> 'already paused!'</p>

<p>// OK call play again!
player.play();</p>

<p>=> 'tearing down the pausing state!'
=> 'setting up the playing state'
=> 'playing!'
```</p>

<h3>I like it, but...</h3>

<p>Before you run for the hills due to the sheer volume of boilerplate code I want to remind you that almost all of this repetition can easily be cleaned up. If we defined a base state that all of our other states extended then they would only need to override the methods that they cared about. For instance, the <code>stopping</code> state and <code>pausing</code> state both tell their target to <code>changeState</code> when someone calls <code>play</code>. This kind of functionality is easily moved into a base state. Also if you have no need for <code>enter</code> and <code>exit</code> methods those can be removed or also thrown into the base state. I'll dig into this more tomorrow but for now play around with the example and leave some feedback if you have comments or suggestions. Thanks!</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>

<ul>
<li>Time: 12:10 am</li>
<li>Mood: Tired, Drunk</li>
<li>Sleep: 7</li>
<li>Hunger: 0</li>
<li>Coffee: 1</li>
</ul>

]]></content>
  </entry>
  
</feed>
