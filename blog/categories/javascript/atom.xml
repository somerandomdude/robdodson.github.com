<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2012-08-29T09:11:46-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Decorator]]></title>
    <link href="http://robdodson.me/blog/2012/08/27/javascript-design-patterns-decorator/"/>
    <updated>2012-08-27T09:59:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/27/javascript-design-patterns-decorator</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>A Decorator is an object which adds functionality to another object dynamically. It can be used to enhance the behavior of an object without requiring the author to reopen its class. While Decorators might feel a little weird to implement in static languages they're extremely simple in JavaScript due to the ease with which JS passes around functions and handles dynamic types.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Wrapper</li>
</ul>


<h2>When to use it</h2>

<ul>
<li><p>When you'd like to add responsibilities to individual objects dynamically (i.e. without subclassing/inheritence).</p></li>
<li><p>When you'd like to be able to remove the functionality at a later time. An <code>undecorate</code> method, for instance.</p></li>
<li><p>When extension by subclassing would be unmanageable or lead to a class explosion. For instance, if a <code>Vehicle</code> class is subclassed by 30 other vehicle objects with only minor differences.</p></li>
</ul>


<h2>Pros and Cons</h2>

<ul>
<li><p><strong>Pro</strong>: More flexible than inheritance.</p></li>
<li><p><strong>Pro</strong>: Avoids feature-laden classes high up in the hierarchy.</p></li>
<li><p><strong>Con</strong>: A decorator and its component aren’t identical.</p></li>
<li><p><strong>Con</strong>: Lots of little objects.</p></li>
</ul>


<h2>A Brief Explanation</h2>

<p>The Decorator pattern is very similar to one we've addressed earlier, called <a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy/">Strategy.</a> The differences between the two can be subtle but usually a decorator <em>enhances</em>, layers upon or "decorates" the object or method it's wrapping. In contrast, a strategy will replace a method's algorithm completely.</p>

<p>The primary benefit of the Decorator pattern is that you can take a rather vanilla object and wrap it in more advanced behaviors. For instance a view which renders a plain window can have decorators to add different backgrounds, scroll bars, borders, etc. The underlying code, or guts, of the window object remains the same while the decorators provide a new <em>skin.</em></p>

<p>Decorators are not limited to visual components. In fact much of the <code>java.io</code> package is composed of Decorators which add additional functionality such as buffering file streams and adding line numbers. A similar application to JavaScript might involve decorating I/O in Node.js. For instance, incoming data might need to be converted to ASCII and then compressed in some way. It might not <em>always</em> need to be converted to ASCII and it might not <em>always</em> need to be compressed. In this scenario we can apply or remove I/O decorators at runtime changing the behavior of our object instead of writing a big class with a bunch of cross-cutting concerns.</p>

<h2>Enough Talk! COOOOODE!!!</h2>

<p>Ok so let's do an example. We're going to create a <code>Validator</code> class which looks at the contents of a form and adds error messages to an array if anything in the form is not correct. We want our <code>Validator</code> to be really simple so it'll just have two methods: <code>validate</code> and <code>decorate</code>. As the name implies <code>validate</code> will tell our validator to compare the form against its internal rules. We'll use <code>decorate</code> to specify those rules. The <code>decorate</code> method will accept a String, such as 'hasAge' or 'hasZipCode' which corresponds to an actual function. We'll collect these functions in a list and compare the contents of the form to each item in the list.</p>

<p>We'll start with the constructor and <code>decorate</code> method:</p>

<p>``` js
function Validator () {</p>

<pre><code>this.errors = [];
this.decoratorsList = [];
</code></pre>

<p>}</p>

<p>Validator.prototype.decorate = function(name) {</p>

<pre><code>this.decoratorsList.push(name);
</code></pre>

<p>};
<code>``
We'll collect any error messages in the</code>errors<code>array. We could write a method like</code>validator.hasErrors()` to check the length and contents of the array but for now I'll leave that unspecified. Just know that if we do come across an error we'll toss it in there.</p>

<p>The <code>decoratorsList</code> will hold all of our decorator functions. This is not how the Gang of Four does things, or how you will see the Decorator pattern presented in languages like Java or C++, but that's because they're using static languages which don't do well with functions being passed around. In our case since JavaScript functions are objects we can pass our decorators into a collection to have them called sequentially. This is the easier approach recommended by <a href="https://twitter.com/stoyanstefanov">Stoyan Stefanov</a> in <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns.</a> A little later I'll show you the "hard" approach and you can decide which you prefer ;)</p>

<p>OK moving on... Let's define some decorator functions. We'll add an object to our constructor called <code>decorators</code> and we'll attach our functions to it.</p>

<p>``` js
Validator.decorators = {};</p>

<p>Validator.decorators.hasName = {</p>

<pre><code>validate: function(form) {
    // Code to verify presence of name...

    // If no name found...
    this.errors.push('no name!');
}
</code></pre>

<p>};</p>

<p>Validator.decorators.hasAge = {</p>

<pre><code>validate: function(form) {
    // Code to verify presence of age...

    // If no age found...
    this.errors.push('no age!');
}
</code></pre>

<p>};</p>

<p>Validator.decorators.hasZipCode = {</p>

<pre><code>validate: function(form) {
    // Code to verify presence of zip code...

    // If no zip found...
    this.errors.push('no zip!');
}
</code></pre>

<p>};
```</p>

<p>Each decorator is actually an object which implements the same interface as our <code>Validator</code> object. When we have all of our decorators added to our <code>decoratorsList</code> we'll be able to loop through and call <code>validate</code> on each one.</p>

<p>``` js
Validator.prototype.validate = function(form) {</p>

<pre><code>var i,
    max,
    name;

this.form = form;

max = this.decoratorsList.length;
for (i = 0; i &lt; max; i++) {
    name = this.decoratorsList[i];
    Validator.decorators[name].validate.call(this, form);
};
</code></pre>

<p>};
<code>``
At last we come to the</code>validate<code>method. It first receives an object containing all of our form data. Next it prepares to loop through our collection of decorators. We use the name of the decorator object as a key and</code>call<code>its</code>validate<code>method, passing in</code>this<code>for our context and also the form object as an argument. This way all of the validators will execute in the context of our</code>Validator` instance and they should all have access to the form data.</p>

<p>Let's try it out!</p>

<p><code>js
var validator = new Validator();
validator.decorate('hasName');
validator.decorate('hasAge');
validator.decorate('hasZipCode');
validator.validate({}); // we'll just use a blank object in place of real form data
console.log(validator.errors);
</code></p>

<p>We aren't really doing any validation at this point so our <code>console.log</code> at the end should output an array with 3 error messages, one from each of the validator decorators. But there you go, you've now got a fully decorated <code>validate</code> function. What was once rather vanilla can have all sorts of new and interesting validations applied to it!</p>

<h2>What if my Decorators need additional arguments?</h2>

<p>The above example gets us started decorating but it leaves some room for improvement. For starters what if we want to pass additional arguments to our validation functions? Let's revamp this thing just a bit so we can get really fancy...</p>

<p>```js
function Validator () {</p>

<pre><code>this.errors = [];
this.decoratorsList = [];
</code></pre>

<p>}</p>

<p>Validator.prototype.decorate = function(name, args) {</p>

<pre><code>this.decoratorsList.push({ name: name, args: args });
</code></pre>

<p>};</p>

<p>Validator.decorators = {};</p>

<p>Validator.decorators.hasName = {</p>

<pre><code>validate: function(form, args) {
    // Code to verify presence of name...

    this.errors.push('no name!');
}
</code></pre>

<p>};</p>

<p>Validator.decorators.hasAge = {</p>

<pre><code>validate: function(form, args) {
    // Code to verify presence of age...

    this.errors.push('no age!');
}
</code></pre>

<p>};</p>

<p>Validator.decorators.hasZipCode = {</p>

<pre><code>validate: function(form, args) {
    // Code to verify presence of zip code...

    this.errors.push('no zip!');
}
</code></pre>

<p>};</p>

<p>Validator.prototype.validate = function(form) {</p>

<pre><code>var i,
    max,
    temp,
    name,
    args;

this.form = form;

max = this.decoratorsList.length;
for (i = 0; i &lt; max; i++) {
    temp = this.decoratorsList[i];
    name = temp.name;
    args = temp.args;
    Validator.decorators[name].validate.call(this, form, args);
};
</code></pre>

<p>};
<code>``
This time we are passing an optional hash to our</code>decorate` method which is stored along with its corresponding decorator object. If you've ever used validators in Rails this should feel similar. Time to see it in action!</p>

<p><code>js
var validator = new Validator();
validator.decorate('hasName', { length: 5 });
validator.decorate('hasAge', { minimum: 21 });
validator.decorate('hasZipCode');
validator.validate({}); // some form data. in this case just an anonymous object
console.log(validator.errors);
</code></p>

<h2>Time to do things the hard way...</h2>

<p>I promised I would show you the more classical example of Decorator and since I am a man of my word I <em>guess</em> you can see it... I haven't used Decorators enough to say for certain if this is an unnecessarily complex approach—perhaps it has its benefits—but I don't think I'd recommend it over our previous examples. I'm taking this code almost verbatim from <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns</a> so full credit goes to Stoyan for coming up with it.</p>

<p>In this example we're going to format a Sale price so that it can work for both U.S. and Canadian stores. This means applying different tax rates and outputting the text with different currency symbols.</p>

<p>``` js
function Sale(price) {</p>

<pre><code>this.price = price || 100;
</code></pre>

<p>}</p>

<p>Sale.prototype.getPrice = function() {</p>

<pre><code>return this.price;
</code></pre>

<p>};
<code>``
Things start off very similar to our last example. Instead of</code>validate<code>the method we're interested in this time is</code>getPrice<code>. If you've been paying attention you'll notice that in our previous example</code>validate<code>was rather complex. Yet</code>getPrice` is so...simple. Hmm...</p>

<p>Let's move on to the decorators.</p>

<p>``` js
Sale.decorators = {};</p>

<p>Sale.decorators.fedtax = {</p>

<pre><code>getPrice: function() {
    var price = this._super.getPrice();
    price += price * 5 / 100;
    return price;
}
</code></pre>

<p>};</p>

<p>Sale.decorators.quebec = {</p>

<pre><code>getPrice: function() {
    var price = this._super.getPrice();
    price += price * 7.5 / 100;
    return price;
}
</code></pre>

<p>};</p>

<p>Sale.decorators.usd = { // U.S. dollars</p>

<pre><code>getPrice: function() {
    return "$" + this._super.getPrice().toFixed(2);
}
</code></pre>

<p>};</p>

<p>Sale.decorators.cdn = { // Canadian dollars</p>

<pre><code>getPrice: function() {
    return "CDN$" + this._super.getPrice().toFixed(2);
}
</code></pre>

<p>};
<code>``
This may look similar to the last example but take note of the use of</code><em>super<code>. The</code></em>super` property is actually a reference to a parent class instance. We'll use this reference to travel up the chain of decorators, performing an operation and returning the price at each stop.</p>

<p>This leads us to the <code>decorate</code> method:</p>

<p>``` js
Sale.prototype.decorate = function (decorator) {</p>

<pre><code>var F = function () {},
overrides = this.constructor.decorators[decorator],
i,
newobj;

// Create prototype chain
F.prototype = this;
newobj = new F();
newobj._super = F.prototype;

// Mixin properties/methods of our decorator
// Overriding the ones from our prototype
for (i in overrides) {
    if (overrides.hasOwnProperty(i)) {
        newobj[i] = overrides[i];
    }
}

return newobj;
</code></pre>

<p>}
<code>``
If you're unfamiliar with JavaScript prototypes this can look a little daunting. We're using a pattern that [JavaScript Patterns](http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752) refers to as *Rented Constructor* in order to essentially take a snapshot of our current object, store it in</code>_super` and then mixin new decorator methods. Let's see it in action to clarify things a bit better.</p>

<p><code>js
var sale = new Sale(50);
sale = sale.decorate('fedtax');
sale = sale.decorate('cdn');
console.log(sale.getPrice()); // outputs $CDN52.50
</code>
You'll notice that each time we call <code>decorate</code> we have to re-assign the sale variable to a new instance. Each new instance has a reference to the previous sale object. When we finally call <code>getPrice</code> it walks up this chain of instances and calls <code>getPrice</code> on each stop along the way. In the end we have something which is functionally identical to our first example but potentially a lot harder to understand. In other words, stick with the first approach :D</p>

<h2>The Open-Closed Principle</h2>

<p>I'm going to go off on a quick tangent here because of something I saw in <a href="http://www.amazon.com/First-Design-Patterns-Elisabeth-Freeman/dp/0596007124">Head First Design Patterns.</a> There's a common heuristic in software design known as the <strong>Open-Closed Principle</strong> which states that "classes should be open for extension but closed for modification." Let's explore this concept with our Sale object.</p>

<p>Consider the following bit of code:</p>

<p>``` js
function Sale(price) {</p>

<pre><code>this.price = price || 100;
</code></pre>

<p>}</p>

<p>Sale.prototype.getPrice = function() {</p>

<pre><code>return this.price;
</code></pre>

<p>};
```
You should be able to look at this snippet of code and say that it's almost certainly bug free. Now let's pretend we aren't using decorators and our boss comes to us and says we need to add US and Canadian taxes and currency symbols.</p>

<p>"<em>Hm...I guess that means I'll need to pass those parameters into the constructor and then write some booleans or something to check if we're Canadian or US... Or maybe I'll put them all in a hash... Or...</em>"</p>

<p>Regardless of what we choose to do, if it involves opening up the class then there's a chance that we'll compromise our previous snippet of code. The more times we do this the more we increase the likelihood that we'll introduce a bug which might go uncaught for a long time. Eventually what started off as extremely simple, bug-free code, can turn into a rat's nest.</p>

<p>So, where possible, try to avoid reopening classes and find ways to extend their functionality. This can mean simply subclassing the parent, or using one of the many design patterns we'll be covering.</p>

<h3><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/decorator/">Source</a></h3>

<h2>Related Patterns</h2>

<ul>
<li><p>Adapter: A decorator is different from an adapter in that a decorator only changes an object’s responsibilities, not its interface; an adapter will give an object a completely new interface.</p></li>
<li><p>Composite: A decorator can be viewed as a degenerate composite with only one component. However, a decorator adds additional responsibilities—it isn't intended for object aggregation.</p></li>
<li><p><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy/">Strategy:</a> A decorator lets you change the skin of an object; a strategy lets you change the guts. These are two alternative ways of changing an object.</p></li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Observer]]></title>
    <link href="http://robdodson.me/blog/2012/08/16/javascript-design-patterns-observer/"/>
    <updated>2012-08-16T13:19:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/16/javascript-design-patterns-observer</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>Observer is one of the most popular design patterns and chances are you're probably already using it. If you've ever written an event listener with <code>addEventListener</code> or used one of jQuery's many versions: <code>on</code>, <code>delegate</code>, <code>live</code>, <code>click</code>, etc... then you should already be comfortable with the concept. In a nutshell the Observer pattern allows a <strong>Subject</strong> to publish updates to a group of <strong>Observers</strong>. The Subject maintains a list of Observers and provides an interface for objects to register as Observers. Otherwise the Subject doesn't care who or what is listening to it. In this way the Subject is decoupled from the Observers allowing easy replacement of one Observer for another or even one Subject for another so long as it maintains the same lexicon of events/notifications.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Dependents</li>
<li>Publish-Subscribe</li>
</ul>


<h2>When to use it</h2>

<ul>
<li><p>When the state or actions of one object depends on the state or actions of another object.</p></li>
<li><p>When changing one object necessitates a change to an unknown number of <em>other</em> objects.</p></li>
<li><p>When an object should be able to notify other objects of changes without knowing anything about these other objects.</p></li>
</ul>


<h2>Pros and Cons</h2>

<ul>
<li><p><strong>Pro:</strong> Very loose coupling between objects.</p></li>
<li><p><strong>Pro:</strong> The ability to broadcast changes and updates.</p></li>
<li><p><strong>Con:</strong> Potentially unexpected updates and sequencing issues.</p></li>
</ul>


<h2>The Many Faces of Observer</h2>

<p>Because of its popularity the Observer pattern often goes by a few different names. The primary objects are the <strong>Subject</strong> and the <strong>Observers</strong> though sometimes they are referred to as <strong>Publisher</strong>/<strong>Subscribers</strong> or <strong>Event Dispatcher</strong>/<strong>Listeners</strong>. Although you can definitely split hairs regarding the actual implementation of this pattern, in essence we're usually talking about the same thing. When the Subject's state changes it sends out notifications, unaware of who its Observers are. The Observers, in turn, perform some action in response to this update.</p>

<p>I'm going to heavily quote (*cough* <em>plagiarize</em> *cough*) the wonderful <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns by Stoyan Stefanov</a> to sum up all the parts of an Observer/Pub-Sub relationship:</p>

<p><em>"The publisher object needs to have a property <code>subscribers</code> that is an array storing all subscribers. The act of subscription is merely adding to this array. When an event occurs, the publisher loops through the list of subscribers and notifies them. The notification means calling a method of the subscriber object. Therefore, when subscribing, the subscriber provides one of its methods to the publisher’s subscribe() method.</em></p>

<p><em>The publisher can also provide unsubscribe(), which means removing from the array of subscribers. The last important method of the publisher is publish(), which will call the subscribers’ methods."</em></p>

<p>Here is Stoyan's Pub/Sub implementation. Note that the <code>on</code> function accepts a <code>context</code> argument which allows you to set the handler's context and in turn, the value of <code>this</code>. We'll discuss this a bit more later.</p>

<p>``` js</p>

<p>var publisher = {</p>

<pre><code>subscribers: {
    any: [] // event type: subscribers
},
on: function(type, fn, context) {
    type = type || 'any';
    fn = typeof fn === 'function' ? fn : context[fn];
    if (typeof this.subscribers[type] === "undefined") {
        this.subscribers[type] = [];
    }
    this.subscribers[type].push({ fn: fn, context: context || this });
},
remove: function(type, fn, context) {
    this.visitSubscribers('unsubscribe', type, fn, context);
},
fire: function(type, publication) {
    this.visitSubscribers('publish', type, publication);
},
visitSubscribers: function(action, type, arg, context) {
    var pubtype = type || 'any',
        subscribers = this.subscribers[pubtype],
        i,
        max = subscribers ? subscribers.length : 0;

    for (i = 0; i &lt; max; i += 1) {
        if (action === 'publish') {
            // Call our observers, passing along arguments
             subscribers[i].fn.call(subscribers[i].context, arg);
        } else {
            if (subscribers[i].fn === arg &amp;&amp; subscribers[i].context === context) {
                subscribers.splice(i, 1);
            }
        }
    }
}
</code></pre>

<p>};</p>

<p>```</p>

<p>In practice using the <code>publisher</code> might look something like this:</p>

<p>``` js
function handleLogin() {</p>

<pre><code>console.log('we haz a users!');
</code></pre>

<p>}</p>

<p>publisher.subscribe('login.complete', handleLogin);</p>

<p>// ... .
// Elaborate user login process...</p>

<p>publisher.publish('login.complete');
```</p>

<h2>Mind the Context</h2>

<p>In JavaScript the keyword <code>this</code> in a function will refer to the context in which the function was called. Sometimes functions are global and sometimes they're part of a larger Object. Here's a brief example to clarify:</p>

<p>``` js
var foobar = {</p>

<pre><code>doWork: function() {
    console.log('doing some work...');
    console.log(this);
}
</code></pre>

<p>}</p>

<p>foobar.doWork(); // <code>this</code> will refer to foobar</p>

<p>var doWorkClone = foobar.doWork;
doWorkClone(); // <code>this</code> will refer to window</p>

<p>var workClones = [];
workClones.push(foobar.doWork);
workClones<a href="">0</a>; // <code>this</code> will refer to the workClones Array
```</p>

<p>The first time we call <code>doWork</code> we do so in the <em>context</em> of the <code>foobar</code> object: <code>foobar.doWork()</code>. As a result the term <code>this</code> inside of the <code>doWork</code> method will refer to <code>foobar</code>.</p>

<p>The second time we call <code>doWork</code> we do so by referencing the method through a variable. We're calling <code>doWork</code> using that variable's <em>context</em>. But the variable is a global variable, it's just hanging out on the page! As a result <code>this</code> will refer to <code>window</code>.</p>

<p>In the third example we're stuffing <code>doWork</code> into an array, then referencing it by index, then calling it. In this <em>context</em> <code>doWork</code> is scoped to the <code>workClones</code> Array, since it's also an Object. A little confusing I know.</p>

<p>So why do I care?</p>

<p>Well if you go back and look at the <code>publisher</code> example you'll notice that we pass a function reference to be called whenever the Subject sends out a notification. In our case it looks like this: <code>publisher.subscribe('login.complete', handleLogin);</code> If <code>handleLogin</code> needs to use <code>this</code> we might be in a world of hurt because <code>publisher</code> is going to call <code>handleLogin</code> using itself as the value of <code>this</code>. Uh oh!</p>

<h2>Preserving Context in Observer</h2>

<p>JavaScript's context switching can be really bizarre if you've never had to manage it before. To mitigate this problem we have a handful of useful strategies.</p>

<p>The first one, which is demonstrated in the <code>publisher</code>, is to pass along a <code>context</code> whenever we subscribe a function. This is the third argument to our <code>publisher</code>'s <code>on</code> method.</p>

<p>``` js
on: function(type, fn, context) {</p>

<pre><code>    type = type || 'any';
    fn = typeof fn === 'function' ? fn : context[fn];
    if (typeof this.subscribers[type] === "undefined") {
        this.subscribers[type] = [];
    }
    this.subscribers[type].push({ fn: fn, context: context || this });
},
</code></pre>

<p><code>``
By storing the</code>context<code>we ensure that when it's time to call our function, we can do so in the correct context with the correct value for</code>this<code>. We do this through the use of JavaScript's</code>call` method which allows us to define in which context a function should execute.</p>

<p><code>js
subscribers[i].fn.call(subscribers[i].context, arg);
</code></p>

<p>This can be a very powerful feature especially for utility functions. Checkout the MDN docs for a deeper understanding of <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call">call</a> and its cousin <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply">apply.</a></p>

<p>But what if you're not using our <code>publisher</code> example? What if you're using a slightly more popular library like jQuery to manage your events? Maybe you have some code that looks like this:</p>

<p><code>`` js
// Substitute</code>on<code>for</code>click<code>or</code>delegate<code>or</code>live` or
// whatever else you're using :)</p>

<p>$('.login-button').on('click', function() {</p>

<pre><code>// tell the app the user is trying to log in!
</code></pre>

<p>});
```</p>

<p>Well in this case we might have to use a different approach. As anyone who's used jQuery knows, the value of <code>this</code> in our handler function is going to refer to the DOM element that jQuery selected. Sometimes that's really useful but other times, like in this case, it isn't going to do us much good.</p>

<h3>Closures</h3>

<p>Closures are a powerful feature of ECMAScript and they're especially useful when passing around functions. The best definition I've found for a closure comes from <a href="http://jibbering.com/faq/notes/closures/">this article:</a></p>

<blockquote><p>The simple explanation of a Closure is that ECMAScript allows inner functions; function definitions and function expressions that are inside the function bodies of other functions. And that those inner functions are allowed access to all of the local variables, parameters and declared inner functions within their outer function(s).</p></blockquote>

<p>So let's see that in action.</p>

<p>``` js</p>

<p>var loginController = {</p>

<pre><code>init: function() {
    var self = this;

    $('.login-button').on('click', function() {
        self.handleLogin(); // use self as a stand in for `this` 
    });
},
handleLogin: function() {
    console.log('handling login!');
}
</code></pre>

<p>}</p>

<p><code>``
In the above example the var</code>self<code>exists in a kind of interesting limbo: it is part of</code>loginController's<code></code>init<code>method and also part of the function registered as the</code>on('click')<code>handler. As a result, when the function is executed,</code>self<code>is still in the context of the</code>loginController<code>object and thus logs</code>handling login!`</p>

<p>Awesome! We've solved the issue of preserving scope, right? Well, yes but it's not our only option. Many people (myself included) find it annoying to sprinkle <code>var self = this</code> all over their app. To mitigate things we also have <code>Function.bind</code>.</p>

<h3>Bindings</h3>

<p>The addition of <code>Function.bind</code> in ECMAScript 5 allows us to specify in which context a function should be called, in other words, <em>binding</em> that function (and the value of <code>this</code>) to a particular context. Let's see it in action:</p>

<p>``` js
var widget = {</p>

<pre><code>name: 'My Awesome Widget!',
sayName: function() {
    console.log(this.name);
}
</code></pre>

<p>};</p>

<p>var nameFunc = widget.sayName.bind(widget);
nameFunc(); // outputs: 'My Awesome Widget!'
```</p>

<p>Calling <code>Function.bind</code> will actually create a closure preserving whatever scope we've passed in. It returns a clone of our original function but this time it is bound to a particular context. In the above example it's bound to the <code>widget</code> object. While it's cleaner than our original closure example we're still in a dilemma because we want <code>sayName</code> to ALWAYS be called in the context of <code>widget</code>. How about something like this instead: <code>widget.sayName = widget.sayName.bind(widget);</code> Hey, now we're talking! By overwriting our function and binding it to our <code>widget</code> object we've gotten very close to how classical languages like Java and Actionscript handle scope! This means it's easy to both subscribe and unsubscribe our method, safe in the knowledge that it will always use the proper scope. If you're lazy (like me) take some time to research <a href="http://underscorejs.org/">Underscore.js</a> which provides both <a href="http://underscorejs.org/#bind">bind</a> and <a href="http://underscorejs.org/#bindAll">bindAll</a> functions to ease the process of connecting your methods to their parent objects.</p>

<p>I'll save you the speech on treating JavaScript like other languages except to say anytime you're writing code to make one language act like another you should obviously research whether that's the best course of action or not. In my experience I've found that binding observers can make writing event listeners much cleaner but your mileage may vary and comments/feedback are always welcome :D</p>

<p>Also if you want to read more on <code>Function.bind</code> you can do so <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind">here on MDN.</a></p>

<h2>The Push and Pull Model</h2>

<p>Typically when you create a Subject/Observer relationship you'll want the Subject to send along additional information during its event dispatch. The amount of information can vary widely. Sometimes you'll want to send a lot of information and other times you'll want the observers to receive the event and then query for more information. When you're sending a lot of information it's referred to as the <em>push model</em> and when the Observers should query for more information it's referred to as the <em>pull model</em>. The Gang of Four describe the differences between the two:</p>

<blockquote><p>The pull model emphasizes the subject’s ignorance of its observers, whereas the push model assumes subjects know something about their observers’ needs. The push model might make observers less reusable, because Subject classes make assumptions about Observer classes that might not always be true. On the other hand, the pull model may be inefficient, because Observer classes must ascertain what changed without help from the Subject.</p></blockquote>

<p>There's no right or wrong approach but it is good to understand the differences between the two.</p>

<h2>PubSub and Observer mixins</h2>

<p>If you want a quick, easy to use event dispatcher the <a href="https://github.com/mroderick/PubSubJS">PubSubJS</a> library does a wonderful job of providing an easy to use event dispatcher. It also includes a jQuery plugin variant if that's more your style. If you're looking for something a little less global and a bit more OO checkout this utility function from <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns</a> which mixes-in the <code>publisher</code> to other objects.</p>

<p>``` js
function makePublisher(o) {</p>

<pre><code>var i;   
for (i in publisher) {     
    if (publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] === "function") {
        o[i] = publisher[i];     
    }   
}
o.subscribers = {
    any: []
};
</code></pre>

<p>}
```</p>

<h3><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/observer/">Source</a></h3>

<h2>Related Patterns</h2>

<ul>
<li>Promise: A Promise is an observable token given from one object to another. Promises wrap an operation and notify their observers when the operation either succeeds or fails.</li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Iterator]]></title>
    <link href="http://robdodson.me/blog/2012/08/10/javascript-design-patterns-iterator/"/>
    <updated>2012-08-10T15:45:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/10/javascript-design-patterns-iterator</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>If you're coming from Ruby or Java you probably think of an Iterator as an object which gives you a consistent interface for traversing a collection of some kind. If you're coming from JavaScript or Actionscript you probably just think of an iterator as the <code>i</code> value in a <code>for</code> loop. The term has mixed meanings but in this case we're refering to the former, an object which gives us a consistent interface for iterating over a collection of some kind. If you've never used them before that might seem kind of silly. "If I need to loop over something I'm just going to loop over it!" For many use cases that's totally fine. Where Iterator objects are useful is in situations where you might need to loop in an async fashion (stopping and restarting) or if you want to preclude an object from knowing too much about the inner workings of a collection.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Cursor</li>
</ul>


<h2>Example Time</h2>

<p>The code for an Iterator should be pretty easy to grok if you've worked with loops before. Here is a simple example which returns an Iterator for looping over an Array by every third value.</p>

<p>``` js
var iterator = (function() {</p>

<pre><code>var index = 0,
    data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    length = data.length;

return {
    next: function() {
        var element;
        if (!this.hasNext()) {
            return null;
        }
        element = data[index];
        index += 3;
        return element;
    },
    hasNext: function() {
        return index &lt; length;
    },
    rewind: function() {
        index = 0;
        return data[index];
    },
    current: function() {
        return data[index];
    }
}
</code></pre>

<p>}());
<code>``
Our iterator has a handful of useful operations including</code>next<code>,</code>hasNext<code>,</code>rewind<code>and</code>current`.</p>

<p><code>next</code> will return the next value and advance the index by 3.</p>

<p><code>hasNext</code> will check to see if calling <code>next</code> will actually return an item. Good for indicating when we've reached the end of a collection.</p>

<p><code>rewind</code> will reset the index to zero so we can loop over the collection again.</p>

<p><code>current</code> will return the current item at the index without advancing the index.</p>

<p>Let's put these into play to see how it works:</p>

<p>``` js
while(iterator.hasNext()) {</p>

<pre><code>console.log(iterator.next());
</code></pre>

<p>}</p>

<p>iterator.rewind();
console.log(iterator.current());
```</p>

<p>If we ran the above we'd see the following output in the console.</p>

<p><code>
1
4
7
10
1
</code>
Since the iterator is mainting its own state if we need to stop iteration at any point we just don't call <code>next</code>. Using exclusively <code>for</code> loops we'd have to check against a flag of some kind, store our current position and then rebuild the loop starting from that point.</p>

<h2>Not just for Arrays</h2>

<p>As I mentioned before the Iterator gives us a consistent interface for traversing a collection, which means it can iterate over <em>any</em> object. Calendar Dates, Linked Lists, Node Graphs, whatever! Here's an example of an iterator that traverses a simple Hash.</p>

<p>``` js
var iterator = (function() {</p>

<pre><code>var data = { foo: 'foo', bar: 'bar', baz: 'baz' },
    keys = Object.keys(data),
    index = 0,
    length = keys.length;

return {
    next: function() {
        var element;
        if (!this.hasNext()) {
            return null;
        }
        element = data[keys[index]];
        index++;
        return element;
    },
    hasNext: function() {
        return index &lt; length;
    },
    rewind: function() {
        index = 0;
        return data[keys[index]];
    },
    current: function() {
        return data[keys[index]];
    }
}
</code></pre>

<p>}());
```
Notice how the interface is identical to our previous Iterator? That's one of the key aspects to this pattern: Regardless of the <em>type</em> of collection, we can define a consistent interface to loop through it. It also means that the client doesn't need to know anything about the implementation of the actual collection, and by wrapping it in a closure we can prevent the client from <em>editing</em> the collection. Personally I like the idea of certain services handing out iterators rather than a wholesale dump of all the data. As always use whichever tool is appropriate for the context.</p>

<p>One quick note regarding Hashes. Previous versions of the ECMA spec did not require that Hash keys be kept in order. While most modern browsers <em>do</em> keep them in order there are some funky inconsistencies. For instance, if you write out the following Hash:</p>

<p><code>js
var hash = { 'foo': 'foo', 'bar': 'bar', '1': 'hello', '2': 'world' };
</code>
Google Chrome will swap the order of the keys such that they appear like this:</p>

<p><code>js
{ '1': 'hello', '2': 'world', 'foo': 'foo', 'bar': 'bar' };
</code>
There are some interesting discussions on StackOverflow which cover this topic but it's a bit outside the scope of this article. If you're interested you can find them here:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/5773950/how-to-keep-an-javascript-object-array-ordered-while-also-maintaining-key-lookup">How to keep an Javascript object/array ordered while also maintaining key lookups?</a></li>
<li><a href="http://stackoverflow.com/questions/3549894/javascript-data-structure-for-fast-lookup-and-ordered-looping">Javascript data structure for fast lookup and ordered looping?</a></li>
</ul>


<h2>JavaScript 1.7</h2>

<p>Although not widely supported yet, JavaScript 1.7 includes a built in Iterator object which can be used to wrap an Array or Hash with just a single line of code.</p>

<p>``` html</p>

<script type="application/javascript;version=1.7">
    var lang = { name: 'JavaScript', birthYear: 1995 };
    var it = Iterator(lang);
</script>


<p><code>``
The above script block will not work in Chrome but it should work in the latest version of Firefox. Note the</code>type` attribute of the script tag which instructs the interpreter to handle the code as JS 1.7.</p>

<p>For some further reading on the topic checkout the MDN article which covers <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators">Iterators in JavaScript 1.7</a></p>

<h3><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/iterator/">Source</a></h3>

<h2>Related Patterns</h2>

<ul>
<li>Composite: Iterators are often applied to recursive structures such as Composites.</li>
<li>Factory Method: Polymorphic iterators rely on factory methods to instantiate the appropriate Iterator subclass.</li>
<li>Memento: Often used in conjunction with the Iterator pattern. An iterator can use a memento to capture the state of an iteration. The iterator stores the memento internally.</li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Singleton]]></title>
    <link href="http://robdodson.me/blog/2012/08/08/javascript-design-patterns-singleton/"/>
    <updated>2012-08-08T19:52:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/08/javascript-design-patterns-singleton</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>Ah yes the Singleton, a pattern whose name lives in infamy. For the uninitiated a little explanation is in order. A Singleton is an object which can only be instantiated one time. Repeated calls to its constructor return the same instance and in this way one can ensure that they don't accidentally create, say, two Users in a single User application. Doesn't sound too bad, right? Well, if you're responsible then it arguably <em>is</em> OK but there are many caveats. Before I get into those though, let's throw in the formal definition <em>a la</em> the Gang of Four.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Ensure a class only has one instance, and provide a global point of access to it.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h2>The icky bits</h2>

<p>So I'm sure some of you are already a little anxious because I used the phrase "global point of access" and rightfully you should be. In OO software design <em>global</em> variables and objects are often frowned upon. They break encapsulation and more often than not cause more harm than good. You don't want the far flung bits of your app to be able to reach all the way up to the very top and fiddle around with stuff. When that starts to happen, and other objects also rely on those global variables, then any piece of code, anywhere in the project can change something which can in turn break a totally unrelated bit of functionality. Debugging becomes a nightmare because you're constantly moving from deeply nested object graphs up to the global scope and then back down again. I one time worked on a <em>major</em> application which I inherited from another developer. It was so riddled with Singletons that any change became a sisyphean ordeal of unintended consiquences and time lost debugging. Needless to say I want to put this warning front and center or else the programming gods would surely smite me.</p>

<h2>Well I'm done! Fuck this shit...</h2>

<p>OK before you start running for the hills I want to point out the ways in which Singletons can be useful and then you can make up your mind if they're right for you.</p>

<p>Let's start with the most obvious one: You're probably already using Singletons!</p>

<p>Ever written any code that looks like this?</p>

<p>``` js
var user = {</p>

<pre><code>firstName: 'John',
lastName: 'Doe',
sayName: function() {
    return this.firstName + ' ' + this.lastName;
}
</code></pre>

<p>};
```</p>

<p>Yep, that's a Singleton. Once you create an object literal in JavaScript you've reserved a little piece of memory and no other object will ever be just like that one. Now, depending on the scope you might have only created a local variable but if that <code>user</code> is sitting outside a function then it's globally available to anyone who wants to fiddle with it. I guess the most famous Singleton probably looks like this: <code>$</code>. To put it another way, ever notice how you can use jQuery anywhere in your app after you've included it on the page...? Boom! Singleton!</p>

<p><em>mind blown</em>  ... <em>face off</em> ...</p>

<h2>OK, So they have their uses I guess</h2>

<p>Yes as much as some are probably loathe to admit it, Singletons are quite useful in JavaScript. And as jQuery demonstrates their primary use is to namespace your code.
While other languages like Java or C# have namespaces built in, JavaScript has to emulate them using simple objects.</p>

<p>Consider the following scenario: You have a series of functions hanging out on the page that you frequently use in your program.</p>

<p>``` js
function login() {</p>

<pre><code>// do some login shtuffs
</code></pre>

<p>}</p>

<p>function logout() {</p>

<pre><code>// do some logout shtuffs
</code></pre>

<p>}</p>

<p>function addToCart() {</p>

<pre><code>// blah, blah blah...
</code></pre>

<p>}
```
A few things are going on here...</p>

<p><em>1. Our functions are polluting the global space.</em>
Since they are just floating around on the page they have to attach to something. With no explicitely declared parent object they get hooked on to the globally available <code>window</code> object.</p>

<p><em>2. They're in danger of being overwritten</em>
If we were to accidentally define another global <code>addToCart</code> function or if we brought in a library whose author did the same, it would overwrite the original leading to a really gnarly debugging situation.</p>

<p>Let's revise this by creating one (and only one) global object which our code can branch off of.</p>

<p>``` js
var NAMESPACE = {};</p>

<p>NAMESPACE.login = function() {</p>

<pre><code>// do some login shtuffs
</code></pre>

<p>}</p>

<p>NAMESPACE.logout = function() {</p>

<pre><code>// do some logout shtuffs
</code></pre>

<p>}</p>

<p>NAMESPACE.addToCart = function() {</p>

<pre><code>// blah, blah blah...
</code></pre>

<p>}
<code>``
Now so long as no one creates an object which also has the name</code>NAMESPACE` our code should be safe. From here we can do all sorts of things. We can nest more object literals or we can create constructor functions:</p>

<p>``` js
var NAMESPACE = {};</p>

<p>NAMESPACE.Widget = function(foo, bar) {</p>

<pre><code>// Some awesome widget code
</code></pre>

<p>}</p>

<p>NAMESPACE.Widget.prototype.doSomethingAwesome = function() {</p>

<pre><code>// do something awesome!!!
</code></pre>

<p>}</p>

<p>var myWidget = new NAMESPACE.Widget('hello', 'world');
```
Take a look at <a href="https://github.com/mrdoob/three.js/">the Three.js library which</a> relies heavily on this pattern to structure its code.</p>

<h2>But I like constructors!</h2>

<p>OK so maybe object literals aren't your thing. That's understandable so let me show you a few other ways of writing Singletons.</p>

<p>These first few come from Stoyan Stefanov's excellent book <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns.</a></p>

<p><strong>Singleton with a cached static property</strong></p>

<p>``` js
function User() {</p>

<pre><code>// do we have an existing instance?
if (typeof User.instance === 'object') {
    return User.instance;
}

// proceed as normal
this.firstName = 'John';
this.lastName = 'Doe';

// cache
User.instance = this;

// implicit return
// return this;
</code></pre>

<p>}
<code>``
The cached static property is publicly available which adds a little danger (someone could say</code>Universe.instance = foo`) but this version is very straightforward and doesn't require closures and funky prototype work. If you're lazy this might be a good approach.</p>

<p><strong>Singleton with a closure</strong></p>

<p>``` js
function User() {</p>

<pre><code>// the cached instance
var instance;

// rewrite the constructor
User = function() {
    return instance;
};

// carry over the prototype
User.prototype = this;

// the instance
instance = new User();

// reset the constructor pointer
instance.constructor = User;

// all the functionality
instance.firstName = 'John';
instance.lastName = 'Doe';

return instance;
</code></pre>

<p>}
```</p>

<p>This version takes a bit of fiddling to get the prototype to work as expected because we rewrite the constructor. The upshot is that <code>instance</code> is now private (being contained within the closure).</p>

<p><strong>Singleton with a self executing function</strong></p>

<p>``` js
var User;
(function() {</p>

<pre><code>var instance;

User = function User() {
    if (instance) {
        return instance;
    }

    instance = this;

    // all the functionality
    this.firstName = 'John';
    this.lastName = 'Doe';
};
</code></pre>

<p>}());
```
By wrapping the instance variable in a self executing function we make it private. This version doesn't require any prototype or constructor reassignment but it may potentially confuse people who aren't comfortable with self executing functions.</p>

<p>Addy Osmani also defines a Singleton pattern in his book <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript">Essential JavaScript Design Patterns.</a></p>

<p>``` js
var mySingleton = (function () {</p>

<p>  // Instance stores a reference to the Singleton
  var instance;</p>

<p>  function init() {</p>

<pre><code>// Singleton

// Private methods and variables
function privateMethod(){
    console.log( "I am private" );
}

var privateVariable = "Im also private";

return {

  // Public methods and variables
  publicMethod: function () {
    console.log( "The public can see me!" );
  },

  publicProperty: "I am also public"
};
</code></pre>

<p>  };</p>

<p>  return {</p>

<pre><code>// Get the Singleton instance if one exists
// or create one if it doesn't
getInstance: function () {

  if ( !instance ) {
    instance = init();
  }

  return instance;
}
</code></pre>

<p>  };</p>

<p>})();</p>

<p>// Usage:</p>

<p>var singleA = mySingleton;
var singleB = mySingleton;
console.log( singleA === singleB ); // true
```</p>

<p>This much more elaborate example allows us to define both private and public methods of our Singleton object at the cost of being a bit more complex than all the others.</p>

<p>As Addy is quick to point out:</p>

<blockquote><p>Whilst the Singleton has valid uses, often when we find ourselves needing it in JavaScript it's a sign that we may need to re-evaluate our design.</p>

<p>They're often an indication that modules in a system are either tightly coupled or that logic is overly spread across multiple parts of a codebase. Singletons can be more difficult to test due to issues ranging from hidden dependencies, the difficulty in creating multiple instances, difficulty in stubbing dependencies and so on.</p></blockquote>

<p>Definitely read <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript">his full article</a> on the subject since it contains a handful of links to interesting side topics.</p>

<h2>Related Patterns</h2>

<p>Many patterns can be implemented using the Singleton pattern. See Abstract Factory, Builder, and Prototype.</p>

<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Strategy]]></title>
    <link href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy/"/>
    <updated>2012-08-03T15:12:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>The Strategy pattern is one of my personal favorites and you've probably seen or used it in some fashion without even knowing it. Its primary purpose is to help you separate the parts of an object which are subject to change from the rest of the static bits. Using Strategy objects versus subclasses can often result in much more flexible code since you're creating a suite of easily swappable algorithms.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Policy</li>
</ul>


<h2>Contrived Example Time!</h2>

<p>Let's say you're making a game and you have a Character class. This game has all sorts of different terrain types so your character can run through open fields, walk slowly through swamps or swim under the ocean. Since you don't know what kind of other terrains the game designer is going to think up you decide that it would be a bad idea to give each character <code>run</code>, <code>walk</code>, and <code>swim</code> methods. After all, what if suddenly the character needs to <code>fly</code> or <code>crawl</code>? What if they're wounded and they need to <code>limp</code>? This situation could potentially get out of hand very fast...</p>

<p>There's a good chance you've seen or written code like this before:</p>

<p>``` js
function move() {</p>

<pre><code>if (state === 'walking') {
    // do some walk animation
} else if (state === 'running') {
    // do some running animation
} else if (state === 'swimming') {
    // do some swimming animation
}
</code></pre>

<p>}
```</p>

<p>When you see a big conditional like that or a switch statement it's time to stop and wonder if there's a better way. For instance if we need to subclass our Character we're going to have to override that big conditional. What if we only want to replace the <code>swimming</code> bit? We'll have to copy and paste the code from the super class for <code>walking</code> and <code>running</code> and then write new code specifically for <code>swimming</code>. And of course if <code>walking</code> and <code>running</code> ever change we're totally screwed.</p>

<h3>We need a Strategy to deal with this</h3>

<p>Ok so we know that our character is going to be a real contortionist and need to run and jump and crab-walk all over the place. What if we took the code that made her run and we put it in its own object? How about we just define a Class for movements and we do this for all the different kinds of motion? Then when we need to move our Character we'll just tell it to defer to one of these Movement objects.</p>

<p>``` js
var Movement = function(func) {</p>

<pre><code>this.move = func;
</code></pre>

<p>};</p>

<p>Movement.prototype.execute = function() {</p>

<pre><code>this.move();
</code></pre>

<p>};</p>

<p>var running = new Movement(function() {</p>

<pre><code>console.log("Hey I'm running!");
</code></pre>

<p>});</p>

<p>var walking = new Movement(function() {</p>

<pre><code>console.log("Just walking along...");
</code></pre>

<p>});
```</p>

<p>Now when we want to tell our character to move in a different way we'll just update which Movement object its currently referencing.</p>

<p>``` js
function changeMovementType(movement) {</p>

<pre><code>this.movement = movement;
</code></pre>

<p>}</p>

<p>function move() {</p>

<pre><code>this.movement.execute();
</code></pre>

<p>}
```</p>

<p>In practice you might have something that looks like this:</p>

<p>``` js
var running = new Movement(function() {</p>

<pre><code>console.log("Hey I'm running!");
</code></pre>

<p>});</p>

<p>var walking = new Movement(function() {</p>

<pre><code>console.log("Just walking along...");
</code></pre>

<p>});</p>

<p>// Create a hero and walk through a peaceful forest...</p>

<p>var hero = new Character();
hero.changeMovementType(walking);
hero.move();</p>

<p>// ... OH NO MOTHERFUCKIN' DINOSAURS!!!</p>

<p>hero.changeMovementType(running);
hero.move();
```</p>

<p>Now it's easy for us to add as many different kinds of motion as our little game designer can dream up. Want to give the character gas-powered robotic legs? No problem!</p>

<p>``` js
var robotlegs = new Movement(function() {</p>

<pre><code>console.log("Cruisin for oil...Look out humans!");
</code></pre>

<p>});</p>

<p>hero.changeMovementType(robotlegs);
hero.move();
```</p>

<h2>When to use it</h2>

<p>When you have a part of your Class that's subject to change frequently or perhaps you have many related subclasses which only differ in behavior it's often a good time to consider using a Strategy pattern.</p>

<p>Another benefit of the Strategy pattern is that it can hide complex logic or data that the client doesn't need to know about.</p>

<h2>The Painting App</h2>

<p>For a real world example of when to use Strategy objects consider your typical painting program. Often times you will offer a variety of different brush types to your user but you don’t want to have to change the fundamentals of how a mark shows up on screen every time the user decides to switch from a round to a square brush. Why not wrap those specific implementations in their own brush objects and later on when the user clicks to draw something to screen we’ll just defer to one of those brushes.</p>

<p>``` js
// Grab a reference to the canvas and the drawing context
$canvas = $('#painter');
context = $canvas[0].getContext('2d');</p>

<p>// Define our brush strategy objects
brushes = {
  outline: {</p>

<pre><code>  draw: function(e, context) {
      context.strokeRect(e.pageX - offsetLeft, e.pageY - offsetTop, 10, 10);
  }
</code></pre>

<p>  },
  square: {</p>

<pre><code>  draw: function(e, context) {
      context.fillRect(e.pageX - offsetLeft, e.pageY - offsetTop, 10, 10);
  }
</code></pre>

<p>  },
  circle: {</p>

<pre><code>  draw: function(e, context) {
      context.arc(e.pageX - offsetLeft, e.pageY - offsetTop, 10, 0, Math.PI * 2);
      context.fill();
  }
</code></pre>

<p>  }
};</p>

<p>... .</p>

<p>brush = brushes.square;
```</p>

<p>Here we see that <code>brushes.outline</code>, <code>brushes.square</code>, and <code>brushes.circle</code> each implement a consistent interface for the <code>draw</code> call. However their exact implementation changes from one brush to the next. <code>brushes.outline</code> will only draw the stroke of a rectangle, whereas <code>brushes.square</code> and <code>brushes.circle</code> will fill their respective shapes in. Elsewhere in the program we set our initial brush to a default of brushes.square. When the users presses their mouse and moves it around screen we can defer to whichever Strategy the brush object is currently referencing:</p>

<p>``` js
// Listen for mouse events on the canvas
$canvas
  .on('mousedown', function() {</p>

<pre><code>  isDrawing = true;
</code></pre>

<p>  })
  .on('mouseup mouseleave', function() {</p>

<pre><code>  isDrawing = false;
</code></pre>

<p>  })
  .on('mousemove', function(e) {</p>

<pre><code>  if (isDrawing) {
      // Defer drawing to a Strategy object
      brush.draw(e, context);
  }
</code></pre>

<p>  });
```</p>

<p>Again notice that <code>.on('mousemove')</code> we first check to see if it’s ok to draw something and then defer to whichever Strategy is currently being referenced. Using this approach we can add limitless new brush types to the <code>brushes</code> object and easily change how our program performs at runtime. Be sure to check out the live example and the source for the full application.</p>

<h3><a href="http://robdodson.s3.amazonaws.com/javascript-design-patterns/strategy/painter/index.html">Live Example</a></h3>

<h3><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/strategy/">Source</a></h3>

<h2>Related Patterns</h2>

<ul>
<li>Flyweight: Strategy objects often make good flyweights.</li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
</feed>
